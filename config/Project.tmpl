/*
 * Copyright (C) 1993-2004 by CERN/IT/PDP/DM
 * All rights reserved
 */

DLFWEB=/var/www/html/dlf
DLFCONF=/var/www/conf/dlf

.PHONY : install clean clobber checkDESTDIR checkORACLE checkLSF checkGLOBUS checkSTK checkXROOT checkVERSION client installclient tape installtape purge

/**
 * Meaning of the different rules :
 * - all will build all the software
 * - tape will build only the tape part, that is the software that runs on the tapeservers
 * - client will build the client part, that is the software running on client nodes
 * - install will build AND install the whole software
 * - installtape will build AND install the tape part
 * - installclient will build AND install the client part
 * - clean is cleaning all intermediate files (e.g. .o) but leaves libraries and exes around
 * - clobber is cleaning all files resulting from compilation
 * - purge is clobber + the drop of all Makefiles
 * - the check rules are testing the presence of one component and exiting if they fail
 *   + checkORACLE checkLSF checkGLOBUS checkSTK checkXROOT checkMEMCACHED checkXFS are obvious
 *   + checkDESTDIR checks whether the DESTDIR environment variable is set
 *   + checkVERSION checks whether the MAJOR/MINOR_CASTOR_VERSION environment variables
 *     are set
 */

all: checkORACLE checkGLOBUS checkXROOT checkMEMCACHED checkXFS tape client
tape: checkSTK
install: checkDESTDIR checkVERSION all installtape installclient

EXPORTMAN ?= $(DESTDIR)/usr/share
checkDESTDIR:
	@if [ -z "$(DESTDIR)" ]; then \
	  echo "Please set DESTDIR environment variable before invoking make install."; \
	  exit 1; \
	fi;

checkORACLE:
	@if [ -z $(ORACLE_HOME) ]; then \
	  echo "Please define ORACLE_HOME environment variable before invoking make."; \
	  exit 1; \
	fi; \
	if [ ! -r $(ORACLE_LIBDIR)/libclntsh.so ]; then \
	  echo "Could not find libclntsh.so in $(ORACLE_LIBDIR). Giving up."; \
	  exit 1; \
	fi; \
	if [ ! -r $(ORACLE_BIN)/proc ]; then \
	  echo "Could not find proc executable in $(ORACLE_BIN). Giving up."; \
	  exit 1; \
	fi

LSF_LIB_LOCATION ?= $(LIBDIR)
LSF_LOCATION ?= $(dir $(LSF_LIB_LOCATION))
checkLSF:
	@if [ ! -r $(LSF_LOCATION)/include/lsf/lsbatch.h ]; then \
	  echo "Unable to find LSF header files at $(LSF_LOCATION). Giving up."; \
	  exit 1; \
	fi; \
	if [ ! -r $(LSF_LIB_LOCATION)/liblsf.so ]; then \
	  echo "Unable to find LSF library files at $(LSF_LIB_LOCATION). Giving up."; \
	  exit 1; \
	fi

GLOBUS_LOCATION ?= /opt/globus
checkGLOBUS:
	@if [ ! -r $(GLOBUS_LOCATION)/include//**/GlobusFlavour/globus_config.h -o ! -r $(GLOBUS_LOCATION)/include//**/GlobusFlavour/globus_common.h ]; then \
	  echo "Unable to find globus header files at $(GLOBUS_LOCATION). Giving up."; \
	  exit 1; \
	fi; \
	if [ ! -r $(GLOBUS_LOCATION)/lib/libglobus_ftp_control_/**/GlobusFlavour.so ]; then \
	  echo "Unable to find globus library files at $(GLOBUS_LOCATION). Giving up."; \
	  exit 1; \
	fi

checkSTK:
	@if [ ! -z "$(CASTOR_NOSTK)" ]; then \
	  echo "Compiling without STK support."; \
	else \
	  if [ ! -e $(LIBDIR)/CDK/libapi.so -o ! -e $(LIBDIR)/CDK/libutl.so -o ! -e $(LIBDIR)/CDK/libipc.so -o ! -e $(LIBDIR)/CDK/libcl.so ]; then \
	    echo "Unable to find STK library files at $(LIBDIR). Giving up."; \
	    exit 1; \
	  fi; \
	  if [ ! -d /usr/include/CDK ]; then \
	    echo "Unable to find STK header files at /usr/include/CDK. Giving up."; \
	    exit 1; \
	  fi; \
	fi

XROOT_LIB_LOCATION ?= /opt/xrootd/lib
XROOT_LOCATION ?= $(dir $(XROOT_LIB_LOCATION))
checkXROOT:
	@if [ ! -r $(XROOT_LOCATION)/include/xrootd/XrdPosix/XrdPosixXrootd.hh ]; then \
	  echo "Unable to find XROOT header files at $(XROOT_LOCATION). Giving up."; \
	  exit 1; \
	fi; \
	if [ ! -e $(XROOT_LIB_LOCATION)/libXrdPosix.so ]; then \
	  echo "Unable to find XROOT library files at $(XROOT_LIB_LOCATION). Giving up."; \
	  exit 1; \
	fi

MEMCACHED_LIB_LOCATION ?= $(LIBDIR)
MEMCACHED_LOCATION ?= $(dir $(MEMCACHED_LIB_LOCATION))
checkMEMCACHED:
	@if [ ! -r $(MEMCACHED_LOCATION)/include/libmemcached/memcached.h ]; then \
	  echo "Unable to find memcached header files at $(MEMCACHED_LOCATION). Giving up."; \
	  exit 1; \
	fi; \
	if [ ! -e $(MEMCACHED_LIB_LOCATION)/libmemcached.so ]; then \
	  echo "Unable to find memcached library files at $(MEMCACHED_LIB_LOCATION). Giving up."; \
	  exit 1; \
	fi

XFS_LOCATION ?= /usr
checkXFS:
	@if [ ! -e $(XFS_LOCATION)/include/xfs/xfs.h ]; then \
	  echo "Unable to find xfs header files at $(XFS_LOCATION). Giving up."; \
	  exit 1; \
	fi

checkVERSION:
	@if [ -z "$(MAJOR_CASTOR_VERSION)" -o -z "$(MINOR_CASTOR_VERSION)" ]; then \
	  echo "Please define MAJOR/MINOR_CASTOR_VERSION before installing."; \
	  exit 1; \
	fi

/******************************************************************************
 * The following code deals with automatic prerequisites, that is with        *
 * automatic generation of the list of header files that a given source file  *
 * depends on and with automatic validation that these files did not change   *
 * when one checks whether to recompile the given source file.                *
 * The ideas behind this code are taken from the GNU make manual (see chapter *
 * "Generating Prerequisites Automatically") and from the article found at    *
 * http://locklessinc.com/articles/makefile_tricks/                           *
 * Nevertheless, the code is explained in deep details in the comment         *
 ******************************************************************************/

/*
 * This first macro is able to build a piece of Makefile that expresses the
 * list of dependencies of a given file. It is based on the gcc -MM
 * functionnality plus a couple of refinements.
 *
 *   The basic functionnality is to call gcc -MM on the input file ("$<") and
 * store the result in an output file ("> $@" at the end). As you guessed, this
 * macro is actually supposed to be used in a rule like this :
 * %.d : %.c
 *      $(create_d)
 * And it will thus generate the .d file out of the .c one.
 *   As gcc -MM is able to dig out all the non-system dependencies of a file and
 * create a piece of Makefile, the .d file will look like this :
 * BaseAddress.o : BaseAddress.cpp \
 *  /home/sponcec3/DEVEL/trunk/castor/BaseAddress.hpp \
 *  /home/sponcec3/DEVEL/trunk/castor/IAddress.hpp
 *
 *   However, the default output of gcc -MM misses the dependencies of the .d
 * file itself (which are the same as for the .o). Thus the .d file would not
 * be rebuilt if any dependency has changed. This is why we pipe the output of
 * gcc -MM into a sed expression. Let's detail this expression :
 *   - H means "Copy/append pattern space to hold space." (see sed man page)
 *   - at the end of the file the ${} regexp triggers. (Note the dollar sign
 *     needs to be escaped into two dollar signed due to it running within make
 *   - g means "Copy/append hold space to pattern space." (see sed man page)
 *   - s,....,; is a replacement expression where , is used as separator. We
 *     cannot use the regular / as files names will appear in place of $* and $@
 *   - p means "Print the current pattern space." (see sed man page). It goes
 * together with the -n flag that disables the default printing of pattern space.
 * The H/g trick is needed in order to deal with the multiline output of gcc -M
 * The final content of the .d file looks like this :
 * BaseAddress.o BaseAddress.d : BaseAddress.cpp \
 *  /home/sponcec3/DEVEL/trunk/castor/BaseAddress.hpp \
 *  /home/sponcec3/DEVEL/trunk/castor/IAddress.hpp
 */
create_d = gcc -MM $(CPPFLAGS) $< | sed -n "H;$$ {g;s,\($*\)\.o[ :]*,\1.o $@ : ,;p}" > $@

/*
 * this rules use the create_d macro to build dependency files from source files.
 * Another rule is needed to make the compiled files depend on the dependency
 * file on top of the source file itself. This is achieved by using "Static
 * Pattern Rules" (see GNU make manual) generated by imake from the
 * BareSharedLibraryTarget and ProgramTarget that look like :
 * objects: %.o: %.d
 * They make all targets of the objects list depend on their coresponding .d file
 */
%.d: %.c
	$(create_d)

%.d: %.cpp
	$(create_d)

/*
 * The last part is to include the generated dependency files into this
 * Makefile. This is done via the include directive.
 * Note that this step is less trivial than it seems : we do not include
 * explicit files here, but only existing dependency files. Typically, none
 * on the first compilation of a clean repository.
 * However, if no dependency file has been built so far, then we know that
 * no compilation took place so far, thus the compilation will take place now
 * and we do not need to check the dependencies to trigger it.
 * Note also that a simpler approach would have been to include all .d files
 * explicitely (using imake macros). However, the arguments to include are
 * considered as targets by the Makefile. Thus in this approach, all .d
 * files would be checked and built if necessary for each call to make,
 * even if you called make clean for example.
 * Another trick is the presence of the "fileThatDoesNotExist" item.
 * This is a workaround for the "no file name for `include'" warning that
 * SLC4 gives when the wildcard expression returns an empty string.
 * The workaround is to make sure there is something, even if this file
 * does not exist and remove the "No such file or directory" error
 * using the -include directive rather than the include. Note that this
 * does not remove any checks as wildcard will list only existing files.
 */
-include fileThatDoesNotExist $(wildcard *.d)
