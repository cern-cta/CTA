#!/usr/bin/python
# CASTOR checkreplicas
# Xavier Espinal 30-Mar-2012
# Last revision 27-May-2013 (Xavier)

'''checkreplicas search for a file footprints in castor'''
import exceptions
import sys
import getopt
try:
    import castor_tools
except Exception:
    print "Bailing out - This script runs only on privileged boxes"	
    sys.exit() 
import commands
import os
import rpyc
import time
import optparse

############################################################
# usage function
def usage(exitCode):
  print 'Usage : ' + sys.argv[0] + ' [-h|--help] fileId'
  print 'Query NameServer and Stager databases to get the footprint of a file in CASTOR'
  print 'The output is structured in two sections that matches the two main queries to the DBs (NameserverDB and StagerDB):'
  print '- Nameserver query gives info about the file: status, path, size, class, checksum, copy number, number of copies of the fileclass, and the tape Volume ID (if the file has a tape copy)'
  print '- Disk cache information gives info about the copy(ies) on disk: DiskcopyID(s), castorfileID(s), diskserver and physical filename, diskerver and filesystem status'
  print '- If there is a recall or migration job in process the information about it is displayed together with the elapsed time since the petition was filed'
  sys.exit(exitCode)

# first parse the options
try:
    options, args = getopt.getopt(sys.argv[1:], 'h', ['help'])
except Exception, e:
    print e
    usage(1)
for f, v in options:
    if f == '-h' or f == '--help':
        usage(0)
    else:
        print "unknown option : " + f
        usage(1)

# If no arg, display usage
if len(args) == 0:
    print "missing argument (fileId) \n"
    usage(1)

# If too many arguments, complain and display usage
if len(args) > 1:
    print "too many arguments"
    usage(1)

# Build the FileID field
try:
    if len(sys.argv[1])>= 12:
        cmd = "nsls -i " + sys.argv[1] + " | awk {'print $1'}"
        status, fid = commands.getstatusoutput(cmd)
        if len(fid) >= 15:
            print 'No such file on castor namespace:', sys.argv[1]
    else:
        fid=sys.argv[1]

except ValueError:
    print 'Invalid argument : "' + arg + '"'
    usage(1)

###################### DBSTUFF - Query NameServer and Stager DBs ###############################
try:
    cmfc = 0
    nsconn = castor_tools.connectToNS()
    nscur = nsconn.cursor() 
    nscur.execute('''
        SELECT getpathforfileid(:name) nspath, f.filesize fmf, f.status fms,
               f.name fmn, f.fileclass fmfc, f.csumvalue fmcs, f.mtime fmtime,
               nvl(f.stagertime, 0) fstagertime, f.csumtype fmcst, s.vid smv, s.copyno smcnb,
               s.segsize sms, s.creationtime scrtime, s.lastmodificationtime slmtime,
               c.name cmfc, c.nbcopies cmcn
          FROM cns_file_metadata f, cns_seg_metadata s, cns_class_metadata c
         WHERE f.fileid=:name AND s.s_fileid(+) = f.fileid
           AND c.classid=f.fileclass''', name=fid)
    nsqry_res = nscur.fetchall()
    if len(nsqry_res) == 0:
        print 'No namespace entry available for fileID:', fid
    for (nspath, fmf, fms, fmn, fmfc, fmcs, fmtime, fstagertime, fmcst, smv, smcnb, sms, scrtime, slmtime, cmfc, cmcn) in nsqry_res:
        output = 'FileID: %s FileStatus: %s FilePath: %s FileSize: %s FileLastMTime: %s FileNSOpenTime: %1.6f Class: %s(%s)' \
                  % (fid, fms, nspath, fmf, castor_tools.secsToDate(fmtime), fstagertime, fmfc, cmfc)
        if sms != None:
            output += '\nSegmentSize: %s SegmentCreationTime: %s SegmentLastMTime: %s CheckSum: %s(%s) FileCopyNB: %s ClassNBCopies: %s TapeVolumeID: %s' \
                      % (sms, castor_tools.secsToDate(scrtime), castor_tools.secsToDate(slmtime), fmcs, fmcst, smcnb, cmcn, smv)
        print '<-- NameServer Information -->'
        print output

    stconn = castor_tools.connectToStager()
    stcur = stconn.cursor()
    stcur.execute('''
    	SELECT diskcopy.id did, diskcopy.status dst, diskcopy.filesystem dfs, diskcopy.path dp, diskcopy.diskcopysize dcs,
             castorfile.id cfid, castorfile.filesize cfs, castorfile.creationtime cfctime, castorfile.nsopentime cfnsopentime, diskcopy.castorfile dcf,
             FileSystem.mountPoint fmt, Filesystem.diskpool fdp, Filesystem.diskserver fds, Filesystem.status fss, diskserver.name dsn, diskserver.status dss,
             migrationjob.status mjs, migrationjob.id mjid, migrationjob.creationtime mjct, migrationjob.vid mjvid, migrationjob.nbretries mjnbr,
             recalljob.status rjs, recalljob.id rjid, recalljob.vid rjvid, recalljob.creationtime rjct, diskpool.id dpid, diskpool2svcclass.child svcid, svcclass.name svcname
     	  FROM diskcopy, FileSystem, diskserver, castorfile, migrationjob, recalljob, diskpool, diskpool2svcclass, svcclass
    	 WHERE diskcopy.castorfile(+) = castorfile.id 
         AND FileSystem.id(+) = diskcopy.filesystem 
         AND diskserver.id(+) = Filesystem.diskserver 
         AND castorfile.fileid =:name 
         AND migrationjob.castorfile(+) = diskcopy.castorfile 
         AND recalljob.castorfile(+) = castorfile.id  
         AND diskpool.id(+)=filesystem.diskpool 
         AND diskpool2svcclass.parent(+) = filesystem.diskpool
         AND svcclass.id(+) = diskpool2svcclass.child''', name=fid)
    stgqry_res = stcur.fetchall()
    if len(stgqry_res) == 0:
        print 'No metadata available for fileID:', fid, '(or incorrect stager)'

# Protection against missing NS information for the single inherited NameServer query variable: cns_class_metadata.name - I'm defaulting this one when the NSID has been removed from NS so diskchache not crash
    if cmfc == 0:
        cmfc = 'no_info'

    for (did, dst, dfs, dp, dcs, cfid, cfs, cfctime, cfnsopentime, dcf, fmt, fdp, fds, fss, dsn, dss, mjs, mjid, mjct, mjvid, mjnbr, rjs, rjid, rjvid, rjct, dpid, svcid, svcname) in stgqry_res:
# MagicNumbers (CASTOR return codes translation)
        dssd = {None:'NODISKSERVER_YET', 0:'DISKSERVER IN PRODUCTION', 1:'DISKSERVER IN DRAINING', 2:'DISKSERVER IS DISABLED'}
        fssd = {None:'NOFILESYSTEM_YET', 0:'FILESYSTEM IN PRODUCTION', 1:'FILESYSTEM IN DRAINING', 2:'FILESYSTEM IS DISABLED'}
        dscsd = {None:'NODISKCOOPY_YET', 0:'DISKCOPY VALID', 1:'DISKCOPY WAITDISK2DISKCOPY', 2:'DISKCOPY WAITTAPERECALL', 3:'DISKCOPY DELETED', 4:'DISKCOPY FAILED', 5:'DISKCOPY WAITFS', 6:'DISKCOPY STAGEOUT', 7:'DISKCOPY INVALID', 9:'DISKCOPY BEINGDELETED', 11:'DISKCOPY WAITFS_SCHEDULING'}
        mjsd = {None:'NOMIGRATIONJOB', 0:'MIGRATIONJOB PENDING', 1:'MIGRATIONJOB SELECTED', 2:'MIGRATIONJOB WAITINGONRECALL', 3:'MIGRATIONJOB RETRY'}
        rjsd = {None:'NORECALLJOB', 1:'RECALLJOB PENDING', 2:'RECALLJOB SELECTED', 3:'RECALLJOB RETRYMOUNT'}

        output = 'DiskCopy: %s (%s) DiskCopySize: %s CastorfileId: %s CastorfileSize: %s CastorfileLastMTime: %s CastorfileNSOpenTime: %1.6f Svcclass: %s DiskCopyPath: %s:%s%s (%s/%s) FileClass: %s' \
                 % (did, dscsd[dst], dcs, dcf, cfs, castor_tools.secsToDate(cfctime), cfnsopentime, svcname, dsn,fmt,dp, dssd[dss], fssd[fss], cmfc)
        print '<-- Disk Cache Information -->'
        print output
        if mjsd[mjs] !='NOMIGRATIONJOB':
            print '<-- Migration Job information -->'  
            output2='MigrationJobStatus: %s (since %2.2f(h)) MJId: %s MJVolumeID: %s MJRetryNb: %s' %(mjsd[mjs], (time.time()-mjct)/3600, mjid, mjvid, mjnbr)
            print output2
        if rjsd[rjs] !='NORECALLJOB':
            print '<-- Recall Job information -->'
            output3='RecallJobStatus: %s since %2.2f(h) RJId: %s RJVID:%s' % (rjsd[rjs], (time.time()-rjct)/3600, rjid, rjvid) 
            print output3

# close DB connections
    castor_tools.disconnectDB(nsconn)
    castor_tools.disconnectDB(stconn)
except Exception:
    import traceback
    traceback.print_exc()
