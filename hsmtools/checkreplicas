#!/usr/bin/perl -w
#
# *****************************************************************************/# *
# * Displays diskcopy status for a (set of) fileid(s)
# *
# * @author Ignacio.Reguero@cern.ch
# * Based on diskServer_qry from the Castor-dev team.
# *****************************************************************************/
#
use strict;
use diagnostics;
#use lib "/afs/cern.ch/project/castor/deployment/tools/lib/perl/CASTOR";
use lib "/usr/lib/perl/CASTOR";
use castor_tools;
use DBD::Oracle qw(:ora_types);

$ENV{ORACLE_HOME}  ||= "/afs/cern.ch/project/oracle/\@sys/prod";
$ENV{TNS_ADMIN}    ||= "/afs/cern.ch/project/oracle/admin";
$ENV{PATH} = "/bin:/usr/bin:/sbin:/usr/sbin";

# usage function
sub usage {
  printf("Usage : %s [-h] [-r|--rfdir] [-c|--checksum] fileId | castorpath [...]\n", $0);
}

# first parse the options
my $help;
my $dorfdir;
my $dochecksum;
if (0 == Getopt::Long::GetOptions ('h|help' => \$help, 'r|rfdir' => \$dorfdir, 'c|checksum' => \$dochecksum)) {
  usage();
  exit(1);
}

if ($help) {
  usage();
  exit(0);
}

my @FsStatus = ("FILESYSTEM_PRODUCTION",
                "FILESYSTEM_DRAINING",
                "FILESYSTEM_DISABLED",
                "FILESYSTEM_NONE");
my @TcStatus = ("TAPECOPY_CREATED",
		"TAPECOPY_TOBEMIGRATED",
		"TAPECOPY_WAITINSTREAMS",
		"TAPECOPY_SELECTED",
		"TAPECOPY_TOBERECALLED",
		"TAPECOPY_STAGED",
		"TAPECOPY_FAILED",
		"TAPECOPY_WAITPOLICY",
		"TAPECOPY_REC_RETRY",
		"TAPECOPY_MIG_RETRY");
my @TapeStatus = ("TAPE_UNUSED",
                  "TAPE_PENDING",
                  "TAPE_WAITDRIVE",
                  "TAPE_WAITMOUNT",
                  "TAPE_MOUNTED",
                  "TAPE_FINISHED",
                  "TAPE_FAILED",
                  "TAPE_UNKNOWN",
                  "TAPE_WAITPOLICY");
my @SegmentStatus = ("SEGMENT_UNPROCESSED",
                     "SEGMENT_1", 
                     "SEGMENT_2", 
                     "SEGMENT_3", 
                     "SEGMENT_4", 
                     "SEGMENT_FILECOPIED", 
                     "SEGMENT_FAILED", 
                     "SEGMENT_SELECTED", 
                     "SEGMENT_RETRIED"); 
my @ServerStatus = ("DISKSERVER_PRODUCTION",
                    "DISKSERVER_DRAINING",
                    "DISKSERVER_DISABLED",
                    "DISKSERVER_NONE");
my @StreamStatCd = ( "STREAM_PENDING",
                     "STREAM_WAITDRIVE",
                     "STREAM_WAITMOUNT",
                     "STREAM_RUNNING",
                     "STREAM_WAITSPACE",
                     "STREAM_CREATED",
                     "STREAM_STOPPED",
                     "STREAM_WAITPOLICY");

my $filepath;
my $tapensstat;
my $segmentstat;
my $copynum;
my $filesegmentnum;
my $vid;
my $fileseqnumintape;
my $blockid;
my $segmentsize;
my $compfactor;
my $checksumtype;
my $checksum;
my $filename;
my $fileclassid;
my $perm;
my $one;
my $user;
my $group;
my $nslsfilesize;
my $nsmonth;
my $nsdate;
my $nstime;
my $rest;
my $debug = 0;

my @results;
my @vids;
my @checksums;
my %server;
my %serverstat;
my %mountpoint;
my %status;
my %diskpool;
my %svcclassid;
$server{0} = "\tnone";
$serverstat{0} = 3;
$mountpoint{0} = "none ";
$status{0} = 3;
$diskpool{0} = "none";


sub getstatus() {
    my $filepath = shift;

    my $filestatus = `/usr/bin/nsls -l --class $filepath 2>&1`;
    my $shit;
    if ($filestatus =~ m/No such file or directory/i) {
      printf ("nsls -l --class: $filestatus");
      exit(1);
    }
    if ($filestatus =~ m/Permission denied/i) {
      printf ("nsls -l --class: $filestatus");
      exit(1);
    }
    #($shit, $fileclassid, $perm, $one, $user, $group, $nslsfilesize, $nsmonth, $nsdate, $nstime, $rest) = split (/\s+/, $filestatus);
    ( $fileclassid, $perm, $one, $user, $group, $nslsfilesize, $nsmonth, $nsdate, $nstime, $rest) = split (/\s+/, $filestatus);
    if ($fileclassid !~ /\d+/) {
      ($shit, $fileclassid, $perm, $one, $user, $group, $nslsfilesize, $nsmonth, $nsdate, $nstime, $rest) = split (/\s+/, $filestatus);
    }
    printf ("fileclassid= $fileclassid\n") if ($debug);
    printf ("perm= $perm\n") if ($debug);
    printf ("nsls -l --class: $filestatus");
    undef @vids;
    undef @checksums;
    if ($perm =~ m/^m\S+$/i ){ # migrated
      printf ("File migrated\n");
      open (NSLST, "/usr/bin/nsls -T --checksum $filepath |") or die "cannot open nsls -T --checksum $filepath - $!\n";
      while (<NSLST>) {
        ($segmentstat, $copynum, $filesegmentnum, $vid, $fileseqnumintape, $blockid, $segmentsize, $compfactor, $checksumtype, $checksum, $filename) = split (/\s+/, $_);
        printf ("nsls -T --checksum: $_");
        push (@vids, $vid);
        push (@checksums, $checksum);
        if ($segmentsize != $nslsfilesize){
          printf ("Warning: NSLS SIZE=$nslsfilesize SEGMENT SIZE=$segmentsize,\n");
          printf ("Could fix with segment size:\n");
          print ("/usr/bin/nssetfsize --size=$segmentsize $filepath\n");
        }
      }
      close(NSLST);
    } else {
      printf ("File not migrated\n");
    }
    open (NSLCLASS, "nslistclass --id $fileclassid |") or die "cannot open /usr/bin/nslistclass --id $fileclassid - $!\n";
    while (<NSLCLASS>) {
      if ( m/CLASS_NAME\s+(\S+)/i ){
        printf ("FileClass ID=$fileclassid NAME=$1\n");
      }
      if ( m/NBCOPIES\s+(\d+)/i ){
        my $nbcopies = $1;
        if ($nbcopies == 0){
          printf ("No tape fileclass\n");
        } else {
          printf ("Tape fileclass with $nbcopies copy\n");
        }
      }
    }
    close(NSLCLASS);
    for my $vid (@vids) {
      my $vmgrstat = `vmgrlisttape -V $vid`;
      printf ("Tape volume status = $vmgrstat");
      if ( $vmgrstat =~ m/(DISABLED|ARCHIVED|EXPORTED)/i ){
        printf ("PROBLEM with the Tape media\n");
      }
    }
    return 0;
}



# Parse command line
my $arg;
my $i;
for ($i=0; $i<=$#ARGV; $i++) {
  # avoid SQL injection by keeping only numbers
  if ($ARGV[$i]  !~ /^[0-9]/) {
    my $nsstat = `/usr/bin/nsls -i $ARGV[$i]`;
    if (length($nsstat) != 0 ) {
      my ($nothing, $file_id, $rest) = split (/\s+/, $nsstat);
      $ARGV[$i] = $file_id;
    }else{
      $ARGV[$i] = 0;
      print "Error : invalid argument \"$ARGV[$i]\"\n";
      #usage();
      #exit;
    }
  }
}

# If no arg, display usage
if ($#ARGV == -1) {
  usage();
  exit;
}

#
# Oracle connection
#
my @castor_conf = castor_conf_getOraStagerSvc();
my $Dbh = DBI->connect("dbi:Oracle:", $castor_conf[0] ,$castor_conf[1],
                    { RaiseError => 1,
		      AutoCommit => 0})
  or die "cannot connect to stgdb: $DBI::errstr";

#
# register Oracle disconnection
#
END {
    $Dbh->disconnect if $Dbh;
}

#$Dbh->trace(1);

# MAIN
for $arg (@ARGV) {
  my $Sth = $Dbh->prepare(qq{
			  select id, status, filesystem, path, castorfile
			  from diskcopy
			 where castorfile in (
				select id
				from castorfile
				where fileid=$arg)
			 });
  $Sth->execute;
nextmac:
  #printf ("\n$arg:\n");
  my $instager = 0;
  while (my @list = $Sth->fetchrow_array) {
    die("columns mismatch: @list") unless @list == 5;
    my ($id, $stat, $fsystem, $path, $castorfile) = @list;
    $instager = 1;
    push (@results, $arg, $id, $stat, $fsystem, $path, $castorfile, $instager);
    print "fileid=$arg, diskcopyid=$id, status=$stat, filesystem=$fsystem, path=$path, castorfile=$castorfile \n" if ($debug);
  }
  $Sth->finish;
  if (not ($instager)) {
    push (@results, $arg, 0, 0, 0, 0, 0, $instager);
  }
}
my $prevfileid = 0;
while (@results) {
  my $fileid = shift(@results);
  my $diskcopyid = shift(@results);
  my $stat = shift(@results);
  my $fsystem = shift(@results);
  my $path = shift(@results);
  my $castorfile = shift(@results);
  my $instager = shift(@results);

  my $readable;
  my $readablefs;
  my $readableserver;

  if (not ($instager)) {
    #$filepath = `/afs/cern.ch/project/castor/deployment/tools/bin/nsgetpath castorns $fileid 2>/dev/null`;
    $filepath = `nsgetpath castorns $fileid 2>&1`;
    if ($filepath =~ m/No such file or directory/i) {
        $filepath = "";  # Not in ns
    } elsif ($filepath =~ m/cannot query 'castorns', all name server commands are forced to query '(\S+)'/i) {
        my $nsserver =  $1;
        $filepath = `nsgetpath $nsserver $fileid 2>/dev/null`;
    }
    print "\nFile ($fileid) ";
    if (length($filepath) != 0 ) {
      chomp $filepath;
      print "$filepath not in stager\n";
      &getstatus($filepath);
    }else {
      print "not in ns / not in stager\n";
    }
  } else {
    if (! $server{$fsystem} ){
      my $Sth = $Dbh->prepare(qq{
			  select name, status
			  from diskserver
			  where id in (
				  select diskserver
				  from filesystem
				  where id=$fsystem)
                           });
      $Sth->execute;
      while (my @list = $Sth->fetchrow_array) {
        my $invalid=0;
        die("columns mismatch: @list") unless @list == 2;
        ($server{$fsystem}, $serverstat{$fsystem}) = @list;
        print "servername=$server{$fsystem}, serverstatus=$serverstat{$fsystem}\n" if ($debug);
      }
      $Sth->finish;
    }
  
    if (! $mountpoint{$fsystem} ){
      my $Sth = $Dbh->prepare(qq{
                          select FileSystem.mountPoint, FileSystem.status, diskpool.name, svcclass.id
                          from FileSystem, diskpool, svcclass
                          where FileSystem.id=$fsystem
                          and   FileSystem.diskpool=diskpool.id
                          and   svcclass.name=diskpool.name
                           });
      $Sth->execute;
      while (my @list = $Sth->fetchrow_array) {
        my $invalid=0;
        die("columns mismatch: @list") unless @list == 4;
        ($mountpoint{$fsystem}, $status{$fsystem}, $diskpool{$fsystem}, $svcclassid{$fsystem}) = @list;
      }
      $Sth->finish;
    }

    if (not defined $diskpool{$fsystem}) {
      $diskpool{$fsystem} = "undefined";
    }
    if (not defined $mountpoint{$fsystem}) {
      $mountpoint{$fsystem} = "undefined";
    }
    if ($stat <= $#DiskCopyStatus) {
      $readable = $DiskCopyStatus[$stat];
    } else {
      $readable = "Unknown status : " . $stat;
    }
    if ($status{$fsystem} <= $#FsStatus) {
      $readablefs = $FsStatus[$status{$fsystem}];
    } else {
      if (defined $status{$fsystem}) {
        $readablefs = "Unknown status : " . $status{$fsystem};
      } else {
        $readablefs = "UndefinedFilesystemStatus";
      }
    }
    if ($serverstat{$fsystem} <= $#ServerStatus) {
      $readableserver = $ServerStatus[$serverstat{$fsystem}];
    } else {
      $readableserver = "Unknown status : " . $serverstat{$fsystem};
    }
  
    if ($fileid != $prevfileid) { 
       printf ("\nNSfileid=%-10lld ",$fileid);
       printf ("Castorfile=%-10lld:\n",$castorfile);
       #$filepath = `/afs/cern.ch/project/castor/deployment/tools/bin/nsgetpath castorns $fileid 2>/dev/null`;
       $filepath = `nsgetpath castorns $fileid 2>&1`;
       if ($filepath =~ m/No such file or directory/i) {
           $filepath = "";  # Not in ns
       } elsif ($filepath =~ m/cannot query 'castorns', all name server commands are forced to query '(\S+)'/i) {
           my $nsserver =  $1;
           $filepath = `nsgetpath $nsserver $fileid 2>/dev/null`;
       }
       chomp $filepath;
       print "filepath=$filepath\n" if ($debug);
       print "fileid=$fileid\n" if ($debug);
       if (length($filepath) != 0 ) {
         chomp $filepath;
         &getstatus($filepath);
       }
    }
    printf ("DiskcopyId=%-12lld %-20s %-10s:%s%s %s %s DiskPool=%s\n",$diskcopyid,$readable,$server{$fsystem},$mountpoint{$fsystem},$path,$readableserver,$readablefs,$diskpool{$fsystem});
    #printf ("%-12lld %-20s %-10lld %-20s\n",$diskcopyid,$readable,$fsystem,$server{$fsystem});
    #printf ("$diskcopyid\t$readable\t$fsystem\t$server{$fsystem}\n");
    if ($dorfdir) {
      my $rfdirout = `/usr/bin/rfdir $server{$fsystem}:$mountpoint{$fsystem}$path 2>&1`;
      print ("rfdir: $rfdirout");
    }
  
    if ($dochecksum) {
      #my $diskchecksumout = `/afs/cern.ch/project/castor/deployment/tools/bin/adler32 $server{$fsystem}:$mountpoint{$fsystem}$path 2>&1`;
      my $diskchecksumout = `./adler32 $server{$fsystem}:$mountpoint{$fsystem}$path 2>&1`;
      print ("adler32: $diskchecksumout\n") if ($debug);
      my ($first, $equalsign, $deccheck, $hexcheck) = split (/\s+/, $diskchecksumout);
      for my $tapechecksum (@checksums) {
        my $vid = shift(@vids);
        unshift(@vids,$vid);
        my $dectapechecksum = hex($tapechecksum); # tapechecksum hex without 0x
        my $decdiskchecksum = oct($hexcheck); # hexcheck has 0x in front
        # Avoid string comparison below
        if ( $dectapechecksum == $decdiskchecksum) {
          print ("checksum OK\n");
          print ("disk checksum = $hexcheck $decdiskchecksum tape checksum = $tapechecksum $dectapechecksum VID = $vid\n") if ($debug);
        } else {
          print ("checksum WRONG\n");
          print ("disk checksum = $hexcheck $decdiskchecksum tape checksum = $tapechecksum $dectapechecksum VID = $vid\n") if ($debug);
        }
      }
    }
  
    if ($readable eq 'DISKCOPY_CANBEMIGR') {
      my $Sth = $Dbh->prepare(qq{
        select id, status
        from tapecopy
        where castorfile in (
          select id
          from castorfile
          where fileid=$fileid)
               });
      $Sth->execute;
      my @tcids;
      while (my @list = $Sth->fetchrow_array) {
        die("columns mismatch: @list") unless @list == 2;
        my ($id, $tapecopystat) = @list;
        my $readableTc;
        if ($tapecopystat <= $#TcStatus) {
          $readableTc = $TcStatus[$tapecopystat];
        } else {
          $readableTc = "Unknown status : " . $tapecopystat;
        }

        printf ("TapeCopy ID=$id $readableTc\n");
        push (@tcids, $id);
      }
      while (@tcids) {
        my $tapecopyid = shift(@tcids);
        my $instream = 0;
        my $Sth = $Dbh->prepare(qq{select stream.id, stream.status, tapepool.name from stream, tapepool where tapepool.id=stream.tapepool and stream.id in 
            (select parent from stream2tapecopy where child=$tapecopyid)
            });
        $Sth->execute;
        while (my @list = $Sth->fetchrow_array) {
          die("columns mismatch: @list") unless @list == 3;
          $instream = 1;
          my ($stream, $streamstatus, $tapepool) = @list;
          my $readableStrStat;
          if ($streamstatus <= $#StreamStatCd) {
            $readableStrStat = $StreamStatCd[$streamstatus];
          } else {
            $readableStrStat = "Unknown status : " . $streamstatus;
          }
          printf ("TapeCopy in Stream ID=$stream STATUS=$readableStrStat TAPEPOOL=$tapepool\n");
          if (($streamstatus == 3) or ($streamstatus == 6)){
            my $Sth2 = $Dbh->prepare(qq{
                select id, vid, status
                from tape
                where tpmode=1 and id in
                ( select tape from stream where id=$stream)
              });
            $Sth2->execute;
            while (my @list2 = $Sth2->fetchrow_array) {
              my $invalid=0;
              die("columns mismatch: @list2") unless @list2 == 3;
              my ($id, $dbvid, $tapedbstat) = @list2;
              my $readableTape;
              if ($tapedbstat <= $#TapeStatus) {
                $readableTape = $TapeStatus[$tapedbstat];
              } else {
                $readableTape = "Unknown status : " . $tapedbstat;
              }
              printf ("    Tape ID=$id VID=$dbvid STATUS=$readableTape\n");
              my $shoqstat = `showqueues -x |grep $dbvid`;
              printf ("    Tape queue status = ");
              if (length($shoqstat) != 0 ) {
                printf ("$shoqstat");
              }else{
                printf ("nothing in showqueues for VID=$dbvid\n");
              }
            }
            $Sth2->finish;
          } # if streamstatus == 3
        } # while
        if (not $instream) {
          printf ("TapeCopy not in any Stream\n");
        }
      }
      $Sth->finish;
      if ($dorfdir) {
        print ("# file in CANBEMIGR\n");
        my $rfdirstat = `rfdir $server{$fsystem}:$mountpoint{$fsystem}$path 2>&1`;
        if ($rfdirstat =~ m/\(error\s+\d+\s+on\s+\S+\)/i) {
          if ($rfdirstat =~ m/No such file or directory/i) {
            print ("# no file in server\n");
          } else {
            print ("rfdir failed : $rfdirstat");
          }
        } else {
          my ($rfperm, $rfone, $rfuser, $rfgroup, $rfdirfilesize, $rfmonth, $rfdate, $rftime, $rfrest) = split (/\s+/, $rfdirstat);
          #if ($perm !~ m/^m\S+$/i ){ # not migrated
            #if (1){ # filesize 0 in ns
             if ($nslsfilesize == 0){ # filesize 0 in ns
              if ($rfdirfilesize != 0){ # filesize not 0 in diskserver
                print ("# filesize 0 in ns and not 0 in diskserver\n");
                print ("/usr/bin/nssetfsize --size=$rfdirfilesize $filepath\n");
                print ("update castorfile set filesize=$rfdirfilesize where filesize=0 and id=$castorfile;\n");
                print ("commit;\n");
                print ("alternatively, if available, you may do both with\n");
                print ("./hsmtools/fixFileSize.py $fileid:$rfdirfilesize\n");
                #print ("call putDoneFunc($castorfile,$rfdirfilesize,0,$svcclassid{$fsystem});\n");
                #print ("commit;\n");
              } else { # filesize 0 both in ns and diskserver
                print ("# filesize 0 both in ns and diskserver\n");
                print ("/usr/bin/cleanLostFiles $diskcopyid\n");
              }
            } elsif ($nslsfilesize == $rfdirfilesize) {
              if ( "$rfmonth $rfdate $rftime" eq "$nsmonth $nsdate $nstime") {
                #print ("call putDoneFunc($castorfile,$rfdirfilesize,0,$svcclassid{$fsystem});\n");
                #print ("commit;\n");
              }
            } elsif ($nslsfilesize != $rfdirfilesize) {
              print ("# size mismatch\n");
              print ("# diskcopy from $rfmonth $rfdate $rftime\n");
              print ("# ns entry from $nsmonth $nsdate $nstime\n");
              print ("# Could fix with\n");
              print ("/usr/bin/nssetfsize --size=$rfdirfilesize $filepath\n");
              print ("update castorfile set filesize=$rfdirfilesize where filesize=$nslsfilesize and id=$castorfile;\n");
              print ("commit;\n");
              print ("alternatively, if available, you may do both with\n");
              print ("./hsmtools/fixFileSize.py $fileid:$rfdirfilesize\n");
            }
          #}
        }
      }
    } elsif ($readable eq 'DISKCOPY_STAGEOUT') {
      print ("# file in STAGEOUT\n");
      my $rfdirstat = `rfdir $server{$fsystem}:$mountpoint{$fsystem}$path 2>&1`;
      if ($rfdirstat =~ m/\(error\s+\d+\s+on\s+\S+\)/i) {
        if ($rfdirstat =~ m/No such file or directory/i) {
          print ("# no file in server\n");
          print ("/usr/bin/cleanLostFiles $diskcopyid\n");
        } else {
          print ("rfdir failed : $rfdirstat");
        }
      } else {
        my ($rfperm, $rfone, $rfuser, $rfgroup, $rfdirfilesize, $rfmonth, $rfdate, $rftime, $rfrest) = split (/\s+/, $rfdirstat);
        if ($perm !~ m/^m\S+$/i ){ # not migrated
          #if (1){ # filesize 0 in ns
           if ($nslsfilesize == 0){ # filesize 0 in ns
            if ($rfdirfilesize != 0){ # filesize not 0 in diskserver
              print ("# filesize 0 in ns and not 0 in diskserver\n");
              print ("/usr/bin/nssetfsize --size=$rfdirfilesize $filepath\n");
              print ("update castorfile set filesize=$rfdirfilesize where filesize=0 and id=$castorfile;\n");
              print ("commit;\n");
              print ("call putDoneFunc($castorfile,$rfdirfilesize,0,$svcclassid{$fsystem});\n");
              print ("commit;\n");
            } else { # filesize 0 both in ns and diskserver
              print ("# filesize 0 both in ns and diskserver\n");
              print ("/usr/bin/cleanLostFiles $diskcopyid\n");
            }
          } elsif ($nslsfilesize == $rfdirfilesize) { 
            #if ( "$rfmonth $rfdate $rftime" eq "$nsmonth $nsdate $nstime") {
              print ("call putDoneFunc($castorfile,$rfdirfilesize,0,$svcclassid{$fsystem});\n");
              print ("commit;\n");
            #}
          }
        } else {
          print ("# Could fix with\n");
          print ("/usr/bin/nssetfsize --size=$rfdirfilesize $filepath\n");
          print ("update castorfile set filesize=$rfdirfilesize where filesize=$nslsfilesize and id=$castorfile;\n");
          print ("call putDoneFunc($castorfile,$rfdirfilesize,0,$svcclassid{$fsystem});\n");
          print ("commit;\n");
        }
      }
    } elsif ($readable eq 'DISKCOPY_WAITDISK2DISKCOPY') {
      my $Sth = $Dbh->prepare(qq{
        select status,count(*)
        from subrequest
        where castorfile in (
          select id
          from castorfile
          where fileid=$fileid) group by status
               });
      $Sth->execute;
      printf ("SubRequest STATUS\tCOUNT(*)\n");
      while (my @list = $Sth->fetchrow_array) {
        my $invalid=0;
        die("columns mismatch: @list") unless @list == 2;
        my ($subrequeststat, $subrequestcount) = @list;
      printf ("           $subrequeststat\t\t$subrequestcount\n");
      }
      $Sth->finish;

      print ("diskcopyid=$diskcopyid\n") if ($debug);
      $Sth = $Dbh->prepare(qq{
        select id, status
        from subrequest
        where diskcopy=$diskcopyid 
               });
      $Sth->execute;
      while (my @list = $Sth->fetchrow_array) {
        my $invalid=0;
        die("columns mismatch: @list") unless @list == 2;
        my ($subrequestid, $subrequeststat) = @list;
        printf ("SubRequest ID=$subrequestid, STATUS=$subrequeststat\n");
        printf ("Could eventually restart SubRequest in stager DB with\n");
        printf ("update diskcopy set status=7 where status=1 and id=$diskcopyid;\n");
        printf ("update subrequest set status=1 where status=$subrequeststat and id=$subrequestid;\n");
        printf ("commit;\n");
      }
      $Sth->finish;
    } elsif (($readable eq 'DISKCOPY_WAITTAPERECALL') or ($readable eq 'DISKCOPY_FAILED')) {
    #} else {
      while (@vids) {
        my $vid = shift(@vids);
        my $shoqstat = `showqueues -x |grep $vid`;
        my $nothinginshowqueues = 0;
        printf ("Tape queue status = ");
        if (length($shoqstat) != 0 ) {
          printf ("$shoqstat");
        }else{
          $nothinginshowqueues = 1;
          printf ("nothing in showqueues for VID=$vid\n");
        }
        my $Sth = $Dbh->prepare(qq{
          select id, vid, status
          from tape
          where vid='$vid'
          and tpmode=0
                         });
        $Sth->execute;
        while (my @list = $Sth->fetchrow_array) {
          my $invalid=0;
          die("columns mismatch: @list") unless @list == 3;
          my ($id, $dbvid, $tapedbstat) = @list;
          my $readableTape;
          if ($tapedbstat <= $#TapeStatus) {
            $readableTape = $TapeStatus[$tapedbstat];
          } else {
            $readableTape = "Unknown status : " . $tapedbstat;
          }
          printf ("Tape ID=$id VID=$dbvid STATUS=$readableTape\n");
          if (($nothinginshowqueues) and ($readableTape eq "TAPE_WAITDRIVE")){
            printf ("VID=$vid in TAPE_WAITDRIVE and nothing in showqueues\n");
          }
        }
        $Sth->finish;
      }
      my $Sth = $Dbh->prepare(qq{
        select id, status
        from tapecopy
        where castorfile in (
          select id
          from castorfile
          where fileid=$fileid)
               });
      $Sth->execute;
      my @tcids;
      while (my @list = $Sth->fetchrow_array) {
        my $invalid=0;
        die("columns mismatch: @list") unless @list == 2;
        my ($id, $tapecopystat) = @list;
        my $readableTc;
        if ($tapecopystat <= $#TcStatus) {
          $readableTc = $TcStatus[$tapecopystat];
        } else {
          $readableTc = "Unknown status : " . $tapecopystat;
        }
        printf ("TapeCopy ID=$id $readableTc\n");
        #printf ("delete from Id2Type where id=$id;\n");
        #printf ("delete from tapecopy where id=$id;\n");
        #printf ("commit;\n");
        push (@tcids, $id);
      }
      $Sth->finish;
      while (@tcids) {
        my $tapecopyid = shift(@tcids);
        $Sth = $Dbh->prepare(qq{
          select segment.id, segment.status, tape.vid, tape.id
          from segment, tape
          where segment.copy = $tapecopyid
          and tape.id = segment.tape
               });
        $Sth->execute;
        my $readableSegment;
        while (my @list = $Sth->fetchrow_array) {
          my $invalid=0;
          die("columns mismatch: @list") unless @list == 4;
          my ($id, $segmentstat, $vid, $tapeid) = @list;
        if ($segmentstat <= $#SegmentStatus) {
          $readableSegment = $SegmentStatus[$segmentstat];
        } else {
          $readableSegment = "Unknown status : " . $segmentstat;
        }
          printf ("Segment ID=$id STATUS=$readableSegment pointing to tape ID=$tapeid VID=$vid\n");
          #printf ("delete from Id2Type where id=$id;\n");
          #printf ("delete from segment where id=$id;\n");
          #printf ("commit;\n");
        }
        $Sth->finish;
      }
      $Sth = $Dbh->prepare(qq{
        select status,count(*)
        from subrequest
        where castorfile in (
          select id
          from castorfile
          where fileid=$fileid) group by status
               });
      $Sth->execute;
      printf ("SubRequest STATUS\tCOUNT(*)\n");
      while (my @list = $Sth->fetchrow_array) {
        my $invalid=0;
        die("columns mismatch: @list") unless @list == 2;
        my ($subrequeststat, $subrequestcount) = @list;
      printf ("           $subrequeststat\t\t$subrequestcount\n");
      }
      $Sth->finish;

      print ("diskcopyid=$diskcopyid\n") if ($debug);
      $Sth = $Dbh->prepare(qq{
        select id, status
        from subrequest
        where diskcopy=$diskcopyid 
               });
      $Sth->execute;
      while (my @list = $Sth->fetchrow_array) {
        my $invalid=0;
        die("columns mismatch: @list") unless @list == 2;
        my ($subrequestid, $subrequeststat) = @list;
        printf ("SubRequest ID=$subrequestid, STATUS=$subrequeststat\n");
        printf ("Could eventually restart SubRequest in stager DB with\n");
        printf ("update diskcopy set status=7 where status=2 and id=$diskcopyid;\n");
        printf ("update subrequest set status=1 where status=$subrequeststat and id=$subrequestid;\n");
        printf ("commit;\n");
      }
      $Sth->finish;
  
    }
  }
  if ($fileid != $prevfileid){ 
    $prevfileid = $fileid;
  }
   
}

