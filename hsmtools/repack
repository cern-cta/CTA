#!/usr/bin/python
#/******************************************************************************
# *                   repack
# *
# * This file is part of the Castor project.
# * See http://castor.web.cern.ch/castor
# *
# * Copyright (C) 2003  CERN
# * This program is free software; you can redistribute it and/or
# * modify it under the terms of the GNU General Public License
# * as published by the Free Software Foundation; either version 2
# * of the License, or (at your option) any later version.
# * This program is distributed in the hope that it will be useful,
# * but WITHOUT ANY WARRANTY; without even the implied warranty of
# * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# * GNU General Public License for more details.
# * You should have received a copy of the GNU General Public License
# * along with this program; if not, write to the Free Software
# * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
# *
# * @(#)$RCSfile: castor_tools.py,v $ $Revision: 1.9 $ $Release$ $Date: 2009/03/23 15:47:41 $ $Author: sponcec3 $
# *
# * repack command line of the CASTOR project
# *
# * @author Castor Dev team, castor-dev@cern.ch
# *****************************************************************************/

"""repack command line of CASTOR."""

import os, sys, time, pwd
import getopt, socket
import castor_tools
import subprocess
import cx_Oracle

# usage function
def usage(exitCode):
    '''prints usage'''
    print 'Usage :'
    print '  repack -h/--help'
    print '  repack -V <VID>[:<VID>[:...]] -o serviceclass'
    print '  repack --bulkvolumeid <filename> -o serviceclass'
    print '  repack -R <VID>[:<VID>[:...]]'
    print '  repack --bulkdelete <filename>'
    print '  repack -s'
    print '  repack -S <VID>:<VID>[:...]]'
    print '  repack -e <VID>[:<VID>[:...]] [-n <nbErrorsDisplayed>]'
    sys.exit(exitCode)

def parseInputFile(fileName):
    '''parse the content of a file that should be a list of VIDs'''
    return [l.split('#',1)[0].strip() for l in open(fileName).readlines() if len(l.split('#',1)[0].strip()) > 0]
    
# first parse the options
try:
    options, arguments = getopt.getopt(sys.argv[1:], 'V:o:sS:R:e:hn:', ['volumeid=', 'bulkvolumeid=', 'svcclass=', 'statusAll', 'status=', 'delete=', 'bulkdelete=', 'errors=', 'help', 'nbErrorsDisplayed='])
except Exception, parsingException:
    print parsingException
    usage(1)
vids = []
vflag = False
sflag = False
rflag = False
eflag = False
svcClass = None
maxNbErrors = None
for f, v in options:
    if f == '-h' or f == '--help':
        usage(0)
    elif f == '-V' or f == '--volumeid':
        vids.extend(v.split(':'))
        vflag = True
    elif f == '--bulkvolumeid':
        vids.extend(parseInputFile(v))
        vflag = True
    elif f == '-s' or f == '--statusAll':
        sflag = True
    elif f == '-S' or f == '--status':
        vids.extend(v.split(':'))
        sflag = True
    elif f == '-R' or f == '--delete':
        vids.extend(v.split(':'))
        rflag = True
    elif f == '--bulkdelete':
        vids.extend(parseInputFile(v))
        rflag = True
    elif f == '-e' or f == '--errors':
        vids.extend(v.split(':'))
        eflag = True
    elif f == '-n' or f == '--nbErrorsDisplayed':
        try:
            maxNbErrors = int(v)
        except ValueError:
            print 'Invalid number :', v
            usage(1)
    elif f == '-o' or f == '--svcclass':
        svcClass = v
    else:
        print "unknown option : " + f
        usage(1)

# If any arg, complain and stop
if len(arguments) != 0:
    print "Unknown arguments : " + ' '.join(arguments) + "\n"
    usage(1)

# check consistency of arguments
if [vflag, sflag, rflag, eflag].count(True) > 1:
    print "Conflicting options : " + ' '.join(arguments) + "\n"
    usage(1)
if svcClass and not vflag:
    print "-o/--output_svcclass is only meaningful in conjunction with -V/--volumeid\n"
    usage(1)
if not svcClass and vflag:
    print "-o/--output_svcclass is mandatory when using -V/--volumeid\n"
    usage(1)
if maxNbErrors and not eflag:
    print "-n/--nbErrorsDisplayed is only meaningful in conjunction with -e/--errors\n"
    usage(1)
if eflag and not maxNbErrors:
    maxNbErrors = 10

def _getIdentity():
    '''Retrieves identity of the user running this script'''
    machine = socket.getfqdn()
    euid = os.getuid()
    egid = os.getgid()
    pid = os.getpid()
    username = pwd.getpwuid(euid)[0]
    sip = socket.gethostbyname(machine).split('.')
    ip = (int(sip[0]) << 24 | int(sip[1]) << 16 | int(sip[2]) << 8 | int(sip[3]))
    if ip & 0x80000000 != 0:
        ip = ip - 0x100000000
    return machine, euid, egid, pid, username, ip

_powerSuf = ['B', 'KiB', 'MiB', 'GiB', 'TiB', 'PiB']
def _humanReadableSize(size):
    '''Converts a number of bytes into human readable format'''
    if not size:
        size = 0
    order = 0
    fsize = float(size)
    while fsize >= 1000:
        fsize = fsize / 1024
        order = order + 1
    if order == 0:
        return str(size) + _powerSuf[order]
    else:
        return '%.2f' % fsize + _powerSuf[order]

_repackRequestStatuses = ['STARTING', 'ONGOING', 'FINISHED', 'FAILED', 'ABORTING', 'ABORTED', 'SUBMITTED']
def _printStatusLine(subTime, user, machine, vid, status, total, size, toRecall, toMigr, failed, migrated):
    '''prints one status line'''
    # times need to be transformed in human readable strings
    subTime = time.strftime('%d-%b-%y %H:%M', time.localtime(subTime))
    # dealing with global status
    status = _repackRequestStatuses[status]
    # human readable size
    size = _humanReadableSize(size)
    # actual printing
    if total > 0:
      # Completion % takes into account each operation (recall and migration) as 1, so that e.g. a tape with half files recalled and none migrated counts as 25% done;
      # no weight is given to recalls vs. migrations nor is the file size taken into account.
      print '%-18s%10s%30s%9s%11d%12s%10d%10d%10d%10d%7d%%%11s' % (subTime, user, machine, vid, total, size, toRecall, toMigr, failed, migrated, 100-(2*toRecall+toMigr)*50.0/total, status)
    else:
      print '%-18s%10s%30s%9s%11d%12s%10d%10d%10d%10d    N/A %11s' % (subTime, user, machine, vid, total, size, toRecall, toMigr, failed, migrated, status)

def displayStatus():
    '''displays the ongoing repacks. If vids is not empty, the output is limited to these tapes'''
    try:
        # prepare DB connection
        stconn = castor_tools.connectToStager()
        stcur = stconn.cursor()
        stcur.arraysize = 50
        stGetStatus = '''
        SELECT * FROM (
          SELECT StageRepackRequest.creationTime, StageRepackRequest.username, StageRepackRequest.machine,
                 StageRepackRequest.repackVID, StageRepackRequest.status,
                 SUM(CASE WHEN SubRequest.status IS NULL THEN 0 ELSE 1 END) total,
                 SUM(SubRequest.xsize) totsize,
                 SUM(CASE WHEN SubRequest.status IN (4, 5) THEN 1 ELSE 0 END) toRecall,
                 SUM(CASE SubRequest.status WHEN 12 THEN 1 ELSE 0 END) toMigr,
                 SUM(CASE WHEN SubRequest.status IN (7, 9) THEN 1 ELSE 0 END) failed,
                 SUM(CASE WHEN SubRequest.status IN (8, 11) THEN 1 ELSE 0 END) migrated
            FROM StageRepackRequest, SubRequest
           WHERE SubRequest.request(+) = StageRepackRequest.id
          '''
        # query only the requested VIDs. This requires hard parsing but it's still more efficient
        # than a later 'grep' and avoids the complexity of dealing with a string list as bind variable.
        if vids:
            stGetStatus += "AND StageRepackRequest.repackVID IN ('" + "','".join(vids) + "')"
        stGetStatus += '''
          GROUP BY StageRepackRequest.creationTime, StageRepackRequest.username, StageRepackRequest.machine,
                   StageRepackRequest.repackVID, StageRepackRequest.status
          UNION
          -- now get the submitted tapes: status = -1 will be printed as the last element in _repackRequestStatuses
          SELECT creationTime, userName, machine, repackVID, -1 status,
                 0 total, 0 totsize, 0 toRecall, 0 toMigr, 0 failed, 0 migrated
            FROM RepackQueue
          '''
        if vids:
            stGetStatus += "AND repackVID IN ('" + "','".join(vids) + "')"
        stGetStatus += '''
          ) ORDER BY creationTime DESC'''
        # go to DB and get back the data
        stcur.execute(stGetStatus)
        rows = stcur.fetchall()
        if len(rows) == 0:
            print 'No repack activity found'
            return
        # print out results
        print '='*149
        print 'SubmitTime              User                       Machine      Vid      Total        Size  toRecall    toMigr    Failed  Migrated  Compl%     Status'
        print '-'*149
        sumTotal = sumSize = sumToRecall = sumToMigr = sumFailed = sumMigrated = 0
        shownVids = set()
        for subTime, user, machine, vid, status, total, size, toRecall, toMigr, failed, migrated in rows:
            if not vids and vid in shownVids:
                # when showing full statistics skip the less recent requests for each VID
                continue
            shownVids.add(vid)
            _printStatusLine(subTime, user, machine, vid, status, total, size, toRecall, toMigr, failed, migrated)
            sumTotal += total
            if size > 0:
                # it may have returned None
                sumSize += size
            sumToRecall += toRecall
            sumToMigr += toMigr
            sumFailed += failed
            sumMigrated += migrated
        print '-'*149
        #  when showing full statistics, print out summary line
        if not vids and sumTotal > 0:
            if sumToRecall + sumToMigr > 0:
                globalStatus = 1  # ONGOING
            else:
                globalStatus = 2  # FINISHED
            _printStatusLine(time.time(), '-', '-', 'TOTAL', globalStatus, sumTotal, sumSize, sumToRecall, sumToMigr, sumFailed, sumMigrated)
        # close DB connection
        castor_tools.disconnectDB(stconn)
    except Exception, e:
        print e
        sys.exit(1)

def submitRepack():
    '''submits the repacking of the given tapes using the given service class'''
    try:
        # prepare DB connection
        stconn = castor_tools.connectToStager()
        try:
            stcur = stconn.cursor()
            stcur.arraysize = 50
            # precompute some useful values about us
            machine, euid, egid, pid, username, ip = _getIdentity()
            # check the service class
            stCheckSvcClass = '''
            DECLARE
              svcClassId NUMBER;
            BEGIN
              svcClassId := checkForValidSvcClass(:svcClassName, 0, 1);
            END;'''
            try:
                stcur.execute(stCheckSvcClass, svcClassName=svcClass)
            except cx_Oracle.Error, e:
                print 'Unknown service class "%s". Giving up' % svcClass
                sys.exit(1)
            # statements for checking and starting repacks
            stCheckForOngoingRepack = '''
            SELECT userName
              FROM StageRepackRequest
             WHERE repackVID = :vid
               AND status NOT IN (2, 5) -- FINISHED, ABORTED
            UNION
            SELECT userName
              FROM RepackQueue
             WHERE repackVID = :vid'''
            stRepack = '''
            BEGIN
              submitRepackRequest(:pmachine, :peuid, :pegid, :ppid, :pusername, :psvcClass, :pip, :pvid);
            END;'''
            # loop over the tapes we should deal with
            for tape in vids:
                try:
                    # check that the tape to be repacked is in a valid state
                    tapeStatus = subprocess.Popen('vmgrlisttape -V ' + tape, shell=True, stdout=subprocess.PIPE).stdout.read().split()[-1]
                    if tapeStatus.find('DISABLED') > -1 or tapeStatus.find('ARCHIVED') > -1 or tapeStatus.find('EXPORTED') > -1:
                        print 'Tape ' + tape + ' has status ' + tapeStatus + ' which is not compatible with repack, ignoring it'
                        continue
                    if tapeStatus.find('FULL') < 0:
                        print 'Tape ' + tape + ' is not marked FULL, ignoring it'
                        continue                        
                    stcur.execute(stCheckForOngoingRepack, vid=tape)
                    rows = stcur.fetchall() 
                    if len(rows) > 0:
                        print 'Tape ' + tape + ' is already being repacked by user ' + rows[0][0] + ', ignoring it'
                    else:
                        # submit repack
                        stcur.execute(stRepack, pmachine=machine, peuid=euid, pegid=egid, ppid=pid,
                                      pusername=username, psvcClass=svcClass, pip=ip, pvid=tape)
                        print 'Repack submitted for tape ' + tape
                except cx_Oracle.Error, e:
                    error, = e.args
                    print 'Caught exception when submitting repack of ' + tape + ' (' + error.message.strip('\n') + '), skipping'
                except IndexError:
                    # the output was not the expected one
                    print 'Caught exception when executing vmgrlisttape for tape ' + tape + ', skipping'
        finally:
            # close DB connection
            castor_tools.disconnectDB(stconn)
    except Exception, e:
        print e
        sys.exit(1)    

def cancelRepack():
    '''aborts the repacking of the given tapes'''
    try:
        # prepare DB connection
        stconn = castor_tools.connectToStager()
        stcur = stconn.cursor()
        stcur.arraysize = 50
        stFindRepackRequest = '''
        SELECT reqId
          FROM StageRepackRequest
         WHERE StageRepackRequest.RepackVID = :vid
           AND status IN (0, 1) -- STARTING, ONGOING
        '''
        stAbort = '''
        BEGIN
          abortRepackRequest(:pmachine, :peuid, :pegid, :ppid, :pusername, :pip, :preqid, :results);
        END;
        '''
        # precompute some useful values about us
        machine, euid, egid, pid, username, ip = _getIdentity()
        # loop over the tapes we should deal with
        for tape in vids:
            try:
                # find the ongoing repack for that tape
                stcur.execute(stFindRepackRequest, vid=tape)
                rows = stcur.fetchall() 
                if len(rows) == 0:
                    print 'Tape ' + tape + ' is not being repacked. Nothing to cancel.'
                else:
                    # abort the ongoing repack
                    strescur = stconn.cursor()
                    strescur.arraysize = 50
                    stcur.execute(stAbort, pmachine=machine, peuid=euid, pegid=egid, ppid=pid,
                                  pusername=username, pip=ip, preqid=rows[0][0], results=strescur)
                    # display outcome
                    answers = strescur.fetchall()
                    if len(answers) == 1 and answers[0][0] == 0:
                        print 'Failed to abort repack for tape ' + tape + ' :'
                        print answers[0][3]
                    else:
                        print 'Repack aborted for tape ' + tape
                        gotErrors = False
                        for fid, nshost, errorCode, errorMessage in answers:
                            if errorCode != 0:
                                if not gotErrors:
                                    print 'The following files had errors :'
                                    gotErrors = True
                                print "%d@%s : (%d)%s" % (fid, nshost, errorCode, errorMessage)
                    # close cursor
                    strescur.close()
                # commit this tape's repack
                stconn.commit()
            except cx_Oracle.Error, e:
                print 'Caught exception when aborting repack of ' + tape + ' :'
                error, = e.args
                print error.message
                print 'Giving up with abort of tape ' + tape
                # rollback this tape's repack
                stconn.rollback()
        # close DB connection
        castor_tools.disconnectDB(stconn)
    except Exception, e:
        print e
        sys.exit(1)    

def displayErrors():
    '''display the errors (if any) that happenned during the repacking of the given tapes'''
    try:
        # prepare DB connection
        stconn = castor_tools.connectToStager()
        stcur = stconn.cursor()
        stcur.arraysize = 50
        stGetErrors = '''
        SELECT * FROM (
          SELECT CastorFile.fileId, Job.copynb, SubRequest.errorCode, Subrequest.errorMessage
            FROM SubRequest, CastorFile,
                 (SELECT castorfile, originalcopynb AS copynb FROM MigrationJob UNION ALL
                  SELECT castorfile, copynb FROM RecallJob) Job
           WHERE SubRequest.request = (SELECT MAX(id) FROM StageRepackRequest
                                        WHERE RepackVID = :vid)
             AND CastorFile.id = SubRequest.castorFile
             AND Job.castorFile(+) = CastorFile.id
             AND SubRequest.status IN (7, 9, 10))
           WHERE ROWNUM <= %d''' % (maxNbErrors+1)
        # loop over the tapes we should deal with
        for tape in vids:
            # go to DB and get back the data
            stcur.execute(stGetErrors, vid=tape)
            rows = stcur.fetchall()
            # print out results
            print '\n     *** Tape  ' + tape + '  ***\n'
            if len(rows) == 0:
                print 'no errors found\n'
                continue
            print '-'*92
            print 'Fileid         CopyNo         ErrorCode      ErrorMessage'
            print '-'*92
            for fileId, copyNo, errorCode, errorMessage in rows[:maxNbErrors]:
                if not copyNo:
                    copyNo = 'n/a'
                else:
                    copyNo = str(copyNo)
                print '%-15d%-15s%-15d%s' % (fileId, copyNo, errorCode, errorMessage)
            if len(rows) == maxNbErrors+1:
                print '\nOutput restricted to %d errors. There are more errors for this tape' % (maxNbErrors)
        # close DB connection
        castor_tools.disconnectDB(stconn)
    except Exception, e:
        print e
        sys.exit(1)

# process the request
if vflag:
    submitRepack()
elif sflag:
    displayStatus()
elif rflag:
    cancelRepack()
elif eflag:
    displayErrors()
else:
    print "No option specified\n"
    usage(1)  
