#!/usr/bin/python
#/******************************************************************************
# *                   repack
# *
# * This file is part of the Castor project.
# * See http://castor.web.cern.ch/castor
# *
# * Copyright (C) 2003  CERN
# * This program is free software; you can redistribute it and/or
# * modify it under the terms of the GNU General Public License
# * as published by the Free Software Foundation; either version 2
# * of the License, or (at your option) any later version.
# * This program is distributed in the hope that it will be useful,
# * but WITHOUT ANY WARRANTY; without even the implied warranty of
# * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# * GNU General Public License for more details.
# * You should have received a copy of the GNU General Public License
# * along with this program; if not, write to the Free Software
# * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
# *
# *
# * repack command line of the CASTOR project
# *
# * @author Castor Dev team, castor-dev@cern.ch
# *****************************************************************************/

"""repack command line of CASTOR."""

import os, sys, time
import getopt, socket
import castor_tools
import subprocess
import cx_Oracle

# usage function
def usage(exitCode):
    '''prints usage'''
    print 'Usage :'
    print '  repack -h|--help'
    print '  repack -V <VID>[:<VID>[:...]] -o serviceclass'
    print '  repack --bulkvolumeid <filename> -o serviceclass'
    print '  repack -R <VID>[:<VID>[:...]]'
    print '  repack --bulkdelete <filename>'
    print '  repack -s|--statusAll [-x|--extra]'
    print '  repack -S <VID>:<VID>[:...]] [-x|--extra]'
    print '  repack -e <VID>[:<VID>[:...]] [-n <nbErrorsDisplayed>]'
    sys.exit(exitCode)

def parseInputFile(fileName):
    '''parse the content of a file that should be a list of VIDs'''
    return [l.split('#',1)[0].strip() for l in open(fileName).readlines() if len(l.split('#',1)[0].strip()) > 0]
    
# first parse the options
try:
    options, arguments = getopt.getopt(sys.argv[1:], 'V:o:sxS:R:e:hn:v', ['volumeid=', 'bulkvolumeid=', 'svcclass=', 'statusAll', 'extra', 'status=', 'delete=', 'bulkdelete=', 'errors=', 'help', 'nbErrorsDisplayed=', 'verbose'])
except Exception, parsingException:
    print parsingException
    usage(1)
vids = []
vflag = False
sflag = False
rflag = False
eflag = False
detailFlag = False
svcClass = None
maxNbErrors = None
verbose = False
for f, v in options:
    if f == '-h' or f == '--help':
        usage(0)
    elif f == '-V' or f == '--volumeid':
        vids.extend(v.split(':'))
        vflag = True
    elif f == '--bulkvolumeid':
        vids.extend(parseInputFile(v))
        vflag = True
    elif f == '-s' or f == '--statusAll':
        sflag = True
    elif f == '-x' or f == '--extra':
        detailFlag = True
    elif f == '-S' or f == '--status':
        vids.extend(v.split(':'))
        sflag = True
    elif f == '-R' or f == '--delete':
        vids.extend(v.split(':'))
        rflag = True
    elif f == '--bulkdelete':
        vids.extend(parseInputFile(v))
        rflag = True
    elif f == '-e' or f == '--errors':
        vids.extend(v.split(':'))
        eflag = True
    elif f == '-n' or f == '--nbErrorsDisplayed':
        try:
            maxNbErrors = int(v)
        except ValueError:
            print 'Invalid number :', v
            usage(1)
    elif f == '-o' or f == '--svcclass':
        svcClass = v
    elif f == '-v' or f == '--verbose':
        verbose = True
    else:
        print "unknown option : " + f
        usage(1)

# If any arg, complain and stop
if len(arguments) != 0:
    print "Unknown arguments : " + ' '.join(arguments) + "\n"
    usage(1)

# check consistency of arguments
if [vflag, sflag, rflag, eflag].count(True) > 1:
    print "Conflicting options : " + ' '.join(arguments) + "\n"
    usage(1)
if svcClass and not vflag:
    print "-o/--output_svcclass is only meaningful in conjunction with -V/--volumeid\n"
    usage(1)
if not svcClass and vflag:
    print "-o/--output_svcclass is mandatory when using -V/--volumeid\n"
    usage(1)
if maxNbErrors and not eflag:
    print "-n/--nbErrorsDisplayed is only meaningful in conjunction with -e/--errors\n"
    usage(1)
if eflag and not maxNbErrors:
    maxNbErrors = 10

_repackRequestStatuses = ['STARTING', 'ONGOING', 'FINISHED', 'FAILED', 'ABORTING', 'ABORTED', 'SUBMITTED']
def _printStatusLine(subTime, lastModTime, user, machine, vid, status, total, size, toRecall, toMigr, failed, migrated):
    '''prints one status line'''
    # dealing with global status
    status = _repackRequestStatuses[status]
    # compute repack elapsed time
    if lastModTime == 0:
      repackTime = '-'  # special case of the summary line
    else:
      if status == 'FINISHED' or status == 'FAILED' or status == 'ABORTED':
        repackTime = lastModTime - subTime
      else:
        repackTime = time.time() - subTime
      # format elapsed time
      repackTime = castor_tools.nbToAge(int(repackTime))
    # times need to be transformed in human readable strings
    subTime = time.strftime('%d-%b-%y %H:%M', time.localtime(subTime))
    # human readable size
    size = castor_tools.nbToDataAmount(size)
    # actual printing
    try:
      if total > 0 and status != 'STARTING':
        # Completion % takes into account each operation (recall and migration) as 1, so that e.g. a tape with half files recalled and none migrated counts as 25% done;
        # no weight is given to recalls vs. migrations nor is the file size taken into account.
        print '%-18s%10s%17s%29s%9s%11d%12s%10d%10d%10d%10d%7d%%%11s' % (subTime, repackTime, user, machine, vid, total, size, toRecall, toMigr, failed, migrated, 100-(2*toRecall+toMigr)*50.0/total, status)
      else:
        print '%-18s%10s%17s%29s%9s%11d%12s%10d%10d%10d%10d    N/A %11s' % (subTime, repackTime, user, machine, vid, total, size, toRecall, toMigr, failed, migrated, status)
    except TypeError:
      # case of reporting without details
      print '%-18s%10s%17s%29s%9s%11d%12s%11s' % (subTime, repackTime, user, machine, vid, total, size, status)


def _displaySummary(rows):
    '''prints a summary of all repack requests according to the given criteria'''
    # print out results
    print '='*117
    print 'SubmitTime        RepackTime             User                      Machine      Vid      Total        Size     Status'
    print '-'*117
    sumTotal = sumSize = 0
    globalStatus = 2  # FINISHED
    shownVids = set()
    count = 0
    for subTime, lastModTime, user, machine, vid, status, total, totsize in rows:
        if not vids and vid in shownVids:
            # when showing full statistics skip the less recent requests for each VID
            continue
        shownVids.add(vid)
        _printStatusLine(subTime, lastModTime, user, machine, vid, status, total, totsize, '-', '-', '-', '-')
        sumTotal += total
        count += 1
        if totsize > 0:
            # it may have returned None
            sumSize += totsize
        if status == 0 or status == 6:
            globalStatus = 0  # STARTING
        if (status == 1 or status == 4) and globalStatus == 2:
            globalStatus = 1  # ONGOING
    print '-'*117
    #  when showing full statistics, print out summary line
    if not vids and sumTotal > 0:
        _printStatusLine(time.time(), 0, '-', 'TOTAL', count, globalStatus, sumTotal, sumSize, '-', '-', '-', '-')

def _displayDetailed(rows):
    '''prints the details of all repack requests according to the given criteria'''
    # print out results
    print '='*165
    print 'SubmitTime        RepackTime             User                      Machine      Vid      Total        Size  toRecall    toMigr    Failed  Migrated  Compl%     Status'
    print '-'*165
    sumTotal = sumSize = sumToRecall = sumToMigr = sumFailed = sumMigrated = 0
    globalStatus = 2  # FINISHED
    shownVids = set()
    count = 0
    for subTime, lastModTime, user, machine, vid, status, total, totsize, toRecall, toMigr, failed, migrated in rows:
        if not vids and vid in shownVids:
            # when showing full statistics skip the less recent requests for each VID
            continue
        shownVids.add(vid)
        _printStatusLine(subTime, lastModTime, user, machine, vid, status, total, totsize, toRecall, toMigr, failed, migrated)
        sumTotal += total
        if totsize > 0:
            # it may have returned None
            sumSize += totsize
        count += 1
        sumToRecall += toRecall
        sumToMigr += toMigr
        sumFailed += failed
        sumMigrated += migrated
        if status == 0 or status == 6:
            globalStatus = 0  # STARTING
        if (status == 1 or status == 4) and globalStatus == 2:
            globalStatus = 1  # ONGOING
    print '-'*165
    #  when showing full statistics, print out summary line
    if not vids and sumTotal > 0:
        _printStatusLine(time.time(), 0, '-', 'TOTAL', count, globalStatus, sumTotal, sumSize, sumToRecall, sumToMigr, sumFailed, sumMigrated)

def displayStatus(detailed):
    '''displays the ongoing repacks. If vids is not empty, the output is limited to these tapes'''
    # prepare DB connection
    stconn = castor_tools.connectToStager()
    stcur = stconn.cursor()
    stcur.arraysize = 50
    if not detailed:
      stGetStatus = '''
        SELECT creationTime, lastModificationTime, username,
               machine, repackVID, status, fileCount total, totalSize totsize
          FROM StageRepackRequest
        '''
      # query only the requested VIDs. This requires hard parsing but it's still more efficient
      # than a later 'grep' and avoids the complexity of dealing with a string list as bind variable.
      if vids:
          stGetStatus += "WHERE StageRepackRequest.repackVID IN ('" + "','".join(vids) + "')"
    else:
      stGetStatus = '''
        SELECT StageRepackRequest.creationTime, StageRepackRequest.lastModificationTime, StageRepackRequest.username,
               StageRepackRequest.machine, StageRepackRequest.repackVID, StageRepackRequest.status,
               StageRepackRequest.fileCount total, StageRepackRequest.totalSize totsize,
               SUM(CASE WHEN SubRequest.status IN (4, 5) THEN 1 ELSE 0 END) toRecall,
               SUM(CASE SubRequest.status WHEN 12 THEN 1 ELSE 0 END) toMigr,
               SUM(CASE WHEN SubRequest.status IN (7, 9) THEN 1 ELSE 0 END) failed,
               SUM(CASE WHEN SubRequest.status IN (8, 11) THEN 1 ELSE 0 END) migrated
          FROM StageRepackRequest, SubRequest
         WHERE SubRequest.request(+) = StageRepackRequest.id
        '''
      # query only the requested VIDs, see above
      if vids:
          stGetStatus += "AND StageRepackRequest.repackVID IN ('" + "','".join(vids) + "')"
      stGetStatus += '''
        GROUP BY StageRepackRequest.creationTime, StageRepackRequest.lastModificationTime, StageRepackRequest.username,
                 StageRepackRequest.machine, StageRepackRequest.repackVID, StageRepackRequest.status,
                 StageRepackRequest.fileCount, StageRepackRequest.totalSize'''
    stGetStatus += ' ORDER BY StageRepackRequest.creationTime DESC'
    # go to DB and get back the data
    stcur.execute(stGetStatus)
    rows = stcur.fetchall()
    if len(rows) == 0:
        print 'No repack activity found'
        return
    # display
    if detailed:
      _displayDetailed(rows)
    else:
      _displaySummary(rows)
    # close DB connection
    castor_tools.disconnectDB(stconn)

def submitRepack():
    '''submits the repacking of the given tapes using the given service class'''
    try:
        # prepare DB connection
        stconn = castor_tools.connectToStager()
        try:
            stcur = stconn.cursor()
            stcur.arraysize = 50
            # precompute some useful values about us
            machine, euid, egid, pid, username, ip = castor_tools.getIdentity()
            # check the service class
            stCheckSvcClass = '''
            DECLARE
              svcClassId NUMBER;
            BEGIN
              svcClassId := checkForValidSvcClass(:svcClassName, 0, 1);
            END;'''
            try:
                stcur.execute(stCheckSvcClass, svcClassName=svcClass)
            except cx_Oracle.Error, e:
                print 'Unknown service class "%s". Giving up' % svcClass
                sys.exit(1)
            # statements for checking and starting repacks
            stCheckForOngoingRepack = '''
            SELECT userName
              FROM StageRepackRequest
             WHERE repackVID = :vid
               AND status NOT IN (2, 3, 5) -- FINISHED, FAILED, ABORTED
            '''
            stRepack = '''
            BEGIN
              submitRepackRequest(:pmachine, :peuid, :pegid, :ppid, :pusername, :psvcClass, :pip, :pvid);
            END;'''
            # loop over the tapes we should deal with
            for tape in vids:
                try:
                    # check that the tape to be repacked is in a valid state
                    tapeStatus = subprocess.Popen('vmgrlisttape -V ' + tape, shell=True, stdout=subprocess.PIPE).stdout.read().split()[-1]
                    if tapeStatus.find('DISABLED') > -1 or tapeStatus.find('ARCHIVED') > -1 or tapeStatus.find('EXPORTED') > -1:
                        print 'Tape ' + tape + ' has status ' + tapeStatus + ' which is not compatible with repack, ignoring it'
                        continue
                    if tapeStatus.find('FULL') < 0:
                        print 'Tape ' + tape + ' is not marked FULL, ignoring it'
                        continue                        
                    stcur.execute(stCheckForOngoingRepack, vid=tape)
                    rows = stcur.fetchall() 
                    if len(rows) > 0:
                        print 'Tape ' + tape + ' is already being repacked by user ' + rows[0][0] + ', ignoring it'
                    else:
                        # submit repack
                        stcur.execute(stRepack, pmachine=machine, peuid=euid, pegid=egid, ppid=pid,
                                      pusername=username, psvcClass=svcClass, pip=ip, pvid=tape)
                        print 'Repack submitted for tape ' + tape
                except cx_Oracle.Error, e:
                    error, = e.args
                    print 'Caught exception when submitting repack of ' + tape + ' (' + error.message.strip('\n') + '), skipping'
                except IndexError:
                    # the output from vmgrlisttape was not the expected one
                    print 'Caught exception when executing vmgrlisttape for tape ' + tape + ', skipping'
        finally:
            # close DB connection
            castor_tools.disconnectDB(stconn)
    except Exception, e:
        print e
        sys.exit(1)    

def cancelRepack():
    '''aborts the repacking of the given tapes'''
    try:
        # prepare DB connection
        stconn = castor_tools.connectToStager()
        stcur = stconn.cursor()
        stcur.arraysize = 50
        stFindRepackRequest = '''
        SELECT reqId
          FROM StageRepackRequest
         WHERE StageRepackRequest.RepackVID = :vid
           AND status IN (6, 0, 1) -- SUBMITTED, STARTING, ONGOING
        '''
        stAbort = '''
        BEGIN
          abortRepackRequest(:pmachine, :peuid, :pegid, :ppid, :pusername, :pip, :preqid, :results);
        END;
        '''
        # precompute some useful values about us
        machine, euid, egid, pid, username, ip = castor_tools.getIdentity()
        # loop over the tapes we should deal with
        for tape in vids:
            try:
                # find the ongoing repack for that tape
                stcur.execute(stFindRepackRequest, vid=tape)
                rows = stcur.fetchall() 
                if len(rows) == 0:
                    print 'Tape ' + tape + ' is not being repacked. Nothing to cancel.'
                else:
                    # abort the ongoing repack
                    strescur = stconn.cursor()
                    strescur.arraysize = 50
                    stcur.execute(stAbort, pmachine=machine, peuid=euid, pegid=egid, ppid=pid,
                                  pusername=username, pip=ip, preqid=rows[0][0], results=strescur)
                    # display outcome
                    answers = strescur.fetchall()
                    if len(answers) == 1 and answers[0][0] == 0:
                        print 'Failed to abort repack for tape ' + tape + ' :'
                        print answers[0][3]
                    else:
                        print 'Repack aborted for tape ' + tape
                        gotErrors = False
                        for fid, nshost, errorCode, errorMessage in answers:
                            if errorCode != 0:
                                if not gotErrors:
                                    print 'The following files had errors :'
                                    gotErrors = True
                                print "%d@%s : (%d)%s" % (fid, nshost, errorCode, errorMessage)
                    # close cursor
                    strescur.close()
                # commit this tape's repack
                stconn.commit()
            except cx_Oracle.Error, e:
                print 'Caught exception when aborting repack of ' + tape + ' :'
                error, = e.args
                print error.message
                print 'Giving up with abort of tape ' + tape
                # rollback this tape's repack
                stconn.rollback()
        # close DB connection
        castor_tools.disconnectDB(stconn)
    except Exception, e:
        print e
        sys.exit(1)    

def displayErrors():
    '''display the errors (if any) that happenned during the repacking of the given tapes'''
    try:
        # prepare DB connection
        stconn = castor_tools.connectToStager()
        stcur = stconn.cursor()
        stcur.arraysize = 50
        stGetErrors = '''
        SELECT * FROM (
          SELECT CastorFile.fileId, Job.copynb, SubRequest.errorCode, Subrequest.errorMessage
            FROM SubRequest, CastorFile,
                 (SELECT castorfile, originalcopynb AS copynb FROM MigrationJob UNION ALL
                  SELECT castorfile, copynb FROM RecallJob) Job
           WHERE SubRequest.request = (SELECT MAX(id) FROM StageRepackRequest
                                        WHERE RepackVID = :vid)
             AND CastorFile.id = SubRequest.castorFile
             AND Job.castorFile(+) = CastorFile.id
             AND SubRequest.status = 9)
           WHERE ROWNUM <= %d''' % (maxNbErrors+1)
        # loop over the tapes we should deal with
        for tape in vids:
            # go to DB and get back the data
            stcur.execute(stGetErrors, vid=tape)
            rows = stcur.fetchall()
            # print out results
            print '\n     *** Tape  ' + tape + '  ***\n'
            if len(rows) == 0:
                print 'no errors found\n'
                continue
            print '-'*92
            print 'Fileid         CopyNo         ErrorCode      ErrorMessage'
            print '-'*92
            for fileId, copyNo, errorCode, errorMessage in rows[:maxNbErrors]:
                if not copyNo:
                    copyNo = 'n/a'
                else:
                    copyNo = str(copyNo)
                print '%-15d%-15s%-15d%s' % (fileId, copyNo, errorCode, errorMessage)
            if len(rows) == maxNbErrors+1:
                print '\nOutput restricted to %d errors. There are more errors for this tape' % (maxNbErrors)
        # close DB connection
        castor_tools.disconnectDB(stconn)
    except Exception, e:
        print e
        sys.exit(1)

# process the request
try:
    if vflag:
        submitRepack()
    elif sflag:
        displayStatus(detailFlag)
    elif rflag:
        cancelRepack()
    elif eflag:
        displayErrors()
    else:
        print "No option specified\n"
        usage(1)
except Exception, e:
    print e
    if verbose:
        import traceback
        traceback.print_exc()
    sys.exit(-1)
