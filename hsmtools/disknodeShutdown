#!/usr/bin/perl -w
# 
# This program is for removing castor disk nodes from production for 
# intervention. It should be run from one of the castoradm nodes under a 
# *USER* account 
#
# NB it will NOT run under root as lsf objects to root submitted jobs

# author         : alasdair.earl@cern.ch 
# first released : 15/12/2005 
# last change    : 9/10/06

use strict;
use POSIX qw(setsid);
use vars qw/ %opt /;

#################################################################################

=pod 

=head1 NAME

disknodeShutdown - migrates files off a disk server node in Castor for
shutdown. This version deals with multiple nodes. Files are checked at
conclusion for sucessful migration and summary presented.

=head1 SYNOPSIS

This program is used to move a node from its current to the Recovery
pool, generate a list  of files it contains and migrate these as
necessary. The node is then available to be  physically powered down
for intervention.

=head1 DESCRIPTION

disknodeShutdown can (must) be run from a user account on the
castoradm nodes with  various command line arguments. This moves the
specified node from the production svcclass  to recovery and then
migrates valid files from the node to others. It is then possible to
shutdown the node without effecting the rest of the Castor system.

=head2 Command Line Options

=item -n <node name>	name of node to be shutdown *REQUIRED*


=item -s <svcclass>	name of service class files are migrated to *REQUIRED*


=item -a <email> 	alternative email address to castor_delopy for messages


=item -m <email>	additional email address to send messages to


=item -h		provides help on usage


=item -v		value for type of files are to be migrated from node. 
			Default is DISKCOPY_STAGED|DISKCOPY_CANBEMIGR
			Alternatives should be in the form value|value|value ...


=head1 BUGS

Files are generated in /tmp in the form /tmp/recov.<date/time>. These are not automatically 
deleted. 

=head1 TO DO LIST

Support for partially completed lists.

=cut

#################################################################################

########################### Variables ########################################

 my $DELAY      = 60;                              #delay between checks of the node for monitoring progress
 my $DEF_EMAIL  = 'castor-operations\@cern.ch';    #default email address for status


 my $USER_EMAIL;
 my @NODES;
 my $NODE;
 my $SVCCLASS;
 my $VALUES = 'CANBEMIGR';

 my $count = 0;

#################################################################################
# sub init_vars() - sorts out the command line arguments
#               this is a standard perl piece of code 
# INPUT  : command line args
# OUTPUT : none
#
sub init_vars()
#################################################################################
{
    use Getopt::Std;
    my $opt_string = 'hn:s:a:m:v:';
    getopts( "$opt_string", \%opt ) or usage();
    usage() if $opt{h};
    @NODES       = split / /,$opt{n} if $opt{n};
    $SVCCLASS   = $opt{s} if $opt{s};
    $DEF_EMAIL  = $opt{a} if $opt{a};
    $USER_EMAIL = $opt{m} if $opt{m};
    $VALUES     = $opt{v} if $opt{v} 
}#end init_vars

#################################################################################
#sub usage() 
# Message / help message about this program and how to use it 
# INPUT  : none 
# OUTPUT : none
#
sub usage() 
#################################################################################
{
    print STDERR  "This program automates the shutdown of Castor disk servers.\n\n"; 
    
    print STDERR  "usage: $0 [-h] [-n node] [-s svcclass] [[-a email address] | [-m email address] ]\n";
    print STDERR  "-h                 : this help message.\n";
    print STDERR  "-n <node>          : name of node to be taken out of production.\n";
    print STDERR  "-n <node> <node> : names of the nodes to be taken out of production - in quotes with spaces.\n";
    print STDERR  "-s <svcclass>      : the service class files will be migrated to. See Twiki for more information.\n";
    print STDERR  "-a <email address> : alternative email address to $DEF_EMAIL e.g. messages to this address only.\n";
    print STDERR  "-m <email address> : additional email address to $DEF_EMAIL\n";
    print STDERR  "                     e.g. messages to $DEF_EMAIL and CC'd to the additional email address.\n";
    print STDERR  "-v <values>        : provide values for which type of files are to be migrated from node.\n";
    print STDERR  "                     Default is DISKCOPY_STAGED|DISKCOPY_CANBEMIGR\n\n\n";
    print STDERR  "example: $0 -n node001 -m name.surname\@cern.ch\n\n";

    exit;    
}#end usage


#################################################################################
# sub send_email()
# simple subroutine to send email to castor ops / user as needed
# INPUT  : none / globals
# OUTPUT : none
#
sub send_email ()
#################################################################################
{
    foreach $NODE (@NODES){
	
	my $message ="### This is an automatic mail. Please do not reply. ###\n\n";
	$message .="disknodeShutdown has set the node $NODE to DOWN and is draining it\n\n";
	$message .="\n\nRegards,\n\ndisknodeShutdown\n";

    open (SENDMAIL, "| /usr/sbin/sendmail -t -oi -f disknodeShutdown\@spam.cern.ch");
print SENDMAIL <<End_of_Mail;
To: $DEF_EMAIL
Cc: $USER_EMAIL
Reply-to:disknodeShutdown\@cern.ch
Subject: Server being taken out of production
$message
End_of_Mail
close(SENDMAIL);
  

     }#end foreach node

}#end send_email

#################################################################################
# sub wait_for_input()
# simple subroutine to pause program while waiting for user to agree to continuing
# INPUT  : none (direct) | command line interaction
# OUTPUT : none
#
#
sub wait_for_input()
#################################################################################
{
    my $data = "";
    do {
	print "Please enter y(es) to continue or q(uit) to quit program and then enter.\n";
	chomp ($data = <STDIN>);
    }while ($data !~ m/^(y|yes|q|quit)$/i);
    if ($data =~ m/^(y|yes)$/i) { return 1; }
    if ($data =~ m/^(quit|q)$/i) { exit; }
}

#################################################################################
# sub check_progress () 
# INPUT  :
# OUTPUT :
#
# todo nsls

sub check_progress () {
#################################################################################
    my @ary = @_;    
    my $i;
    my $total = 0;
    my $filepath;
    
    for ($i =0; $i <= $#ary; $i++) {
	
	$filepath = `nsGetPath castorns $ary[$i]`;
	if (length($filepath) != 0 ) {
	    open (CHECK, "/usr/bin/stager_qry -S $SVCCLASS  -M $filepath |");
	    
	    while (<CHECK>) {
		print $_;
		if ($_ =~ m/($VALUES|CANBEMIGR|STAGED)/i ){ print $_; $total++;}
	    }
	    close(CHECK);
	} else {
	    print $_; $total++;
	}
    }
    
    if ($total != 10) { 
	print $total . "\n"; 
	sleep ($DELAY);
    } else { sleep(2); }
    
    return $total;
}


#################################################################################
# INPUT  : node name
# OUTPUT : filename as string
#
# This produced a file in the format  - FileID State localpath castorpath
#
sub create_file () {
#################################################################################

    my ($NODE) = shift;
    my ($line);	
    my $file = "/tmp/recov.$NODE" . time();
    my $count = 0;
    my $filepath;

    print "Creating file to contain list of files to move.\n"; 

    system("/bin/touch $file");

    print "Creating a list of files to move - this should not take long\n";

    open(FILE, ">$file") or die "Problem opening file $file for writing\n";

    open(CMD, "diskServer_qry -i $NODE |"); # egrep '$VALUES' | awk \'{print \$1}\' |");
    <CMD>;

        foreach (<CMD>) { #was while ($line = <CMD>) {
		chomp;
		next if /^FileId/;
		next if ! /($VALUES)/;
                my @line = split (/\s+/);
                $filepath = `nsGetPath castorns $line[0]`;
                if (length($filepath) != 0 ) {
			print FILE $_ . " ". $filepath;
		}
		$count++;
		if ($count % 100 == 0) {print ".";}
		if ($count % 1000 == 0) {print " $count files processed.\n";}
        }
    close(CMD);
    close(FILE);
    print "List of files to move has been created with $count entries.\n";

    return $file;
}

#################################################################################
# sub final_check
#
#
#
#################################################################################

sub final_check() {
    my $node = shift;
    my $file = shift;
    my $outfile = "/tmp/error_${node}_" . time();
   
    open (F, $file) or die "Unable to open $file for final check";

    open (O, ">$outfile");

    foreach (<F>) {
	my @tmp = split(/\s+/);
        my $filepath = `nsGetPath castorns $tmp[0]`;

        if (length($filepath) != 0 ) {
		open (X, "/usr/bin/stager_qry -S $SVCCLASS -M $filepath |");
		foreach (<X>) {
 	 		chomp;
	    		next if /^Received/;
	    		last if /(CANBEMIGR|STAGED)/;
	    		print "Problem with $tmp[2]\n";
	    		print O "$tmp[2]\n";
		}
		close (X);
	}
    }
    close (F);
    print "File name for errors is $outfile\n";
    close (O);
}
#################################################################################
# sub TransferManager()
# process to transfer files off the node
# This subroutine generates a file of the id and path to the files which need to 
# potentially be moved from the current node to others.
#
#      notes: log into castorscheduler and run bhoststo get current status
#
#
sub TransferManager()
#################################################################################
{
    my ($NODE) = shift;
    my @working_files; 		#an array of the files currently being worked on
    my $file;			#file name for list of files on node
    my $active_transfers = 0;
    my $active = 0;
    my $total_done = 0;

    $file = &create_file($NODE);

    open(FILE, $file) or die "Problem opening file $file for reading\n";
    print "Do you want to start the transfer?.\n"; 
    &wait_for_input();
   
    $active = 0;
    foreach (<FILE>){
      my ($ID, $STATUS, $LOCAL, $Notsure, $URL) = split /\s+/, $_;

      if ($active < 10) {
        open(EXECUTE, "/usr/bin/stager_get -S $SVCCLASS -M $URL 2>&1|"); 
        $working_files[$active++] = $ID;

	my $output = <EXECUTE>;
	until (length($output) > 0) {
	    sleep (1);
	    $output = <EXECUTE>;		      
	}
	print $output; 
	#if ($output =~ /\\n$/){print $output;}	
        close (EXECUTE);
    } else {
	print "End of 10 file ops. Checking progress before continuing.\n";
	do { 
	  $active_transfers = &check_progress(@working_files); 
	} while ($active_transfers != 10); 
	
	$active = 0;	
	$total_done += 10;
	print "$total_done files of $count processed. \n"; 
	   
      } #end else COUNT !=10

    }#END FOREACH
    close(FILE);

    &final_check($NODE, $file);

    print "Finished!\n";
    return; #RETURN TO MAIN

}#end transfermanager


#################################################################################
# start of main code
#
# Note: we have used open (X ...  and then piped stuff because using `` format to 
#       execute on the command line wasn't translating the variables to their value
#       This was the best work around we could find. 


     &init_vars();                 #sort out the getopts arguments for node name and email addresses


  for (0 .. $#NODES){ $NODES[$_] =~ tr/A-Z/a-z/; }
#  $USER_EMAIL =~ s/@/\\@/;

  if (!@NODES){ print "You need to supply the name of a node to be taken out of service.\n"; exit;} 
  if ($USER_EMAIL && $USER_EMAIL !~ /@/) { print "Your email address - $USER_EMAIL - needs an \@ somewhere.\n"; exit;} 	
  if ($DEF_EMAIL !~ /@/) { print "Your email address - $DEF_EMAIL - needs an \@ somewhere!\n"; exit;}

  foreach $NODE (@NODES){

    open(JUNKVAL, "diskServer_qry $NODE | egrep 'DISKCOPY_WAIT|DISKCOPY_STAGEOUT' |"); close (JUNKVAL); 

    print "If there are active transfers for $NODE please decide if you wish to continue.\n";	
    &wait_for_input();		

    print "Moving $NODE to recovery pool.\n";
  
    if (system("/usr/bin/moveDiskServer recovery $NODE") == 0) {
#          if !~ /has been moved to recovery/ exit
	print "$NODE has been moved to recovery.\n";
    } else {
	print "Failed to move $NODE to recovery. Now exiting.\n";
	exit;
    }

  }#end foreach

  &send_email();	

  foreach (@NODES) {	
    &TransferManager($_); #now start transfering file
  }

  1;
