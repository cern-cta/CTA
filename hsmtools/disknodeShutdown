#!/usr/bin/perl -w
# 
# This program is for removing castor disk nodes from production for 
# intervention. It should be run from one of the castoradm nodes under a 
# *USER* account 
#
# NB it will NOT run under root as lsf objects to root submitted jobs

# author         : alasdair.earl@cern.ch 
# first released : 15/12/2005 
# last change    : 9/10/06

use strict;
use POSIX qw(setsid);
use vars qw/ %opt /;

#################################################################################

=pod 

=head1 NAME

disknodeShutdown - migrates files off a disk server node in Castor for
shutdown. This version deals with multiple nodes. Files are checked at
conclusion for sucessful migration and summary presented.

=head1 SYNOPSIS

This program is used to move a node from its current to the Recovery
pool, generate a list  of files it contains and migrate these as
necessary. The node is then available to be  physically powered down
for intervention.

=head1 DESCRIPTION

disknodeShutdown can (must) be run from a user account on the
castoradm nodes with  various command line arguments. This moves the
specified node from the production svcclass  to recovery and then
migrates valid files from the node to others. It is then possible to
shutdown the node without effecting the rest of the Castor system.

=head2 Command Line Options

=item -n <node name>	name of node to be shutdown *REQUIRED*


=item -s <svcclass>	name of service class files are migrated to *REQUIRED*


=item -a <email> 	alternative email address to castor_delopy for messages


=item -m <email>	additional email address to send messages to


=item -h		provides help on usage


=item -v		value for type of files are to be migrated from node. 
			Default is DISKCOPY_STAGED|DISKCOPY_CANBEMIGR
			Alternatives should be in the form value|value|value ...


=head1 BUGS

Files are generated in /tmp in the form /tmp/recov.<date/time>. These are not automatically 
deleted. 

=head1 TO DO LIST

Support for partially completed lists.

=cut

#################################################################################

########################### Variables ########################################

 my $DELAY      = 60;                              #delay between checks of the node for monitoring progress
 my $DEF_EMAIL  = 'castor-operations\@cern.ch';    #default email address for status


 my $USER_EMAIL;
 my @NODES;
 my $NODE;
 my $SVCCLASS;
 my $VALUES = 'CANBEMIGR';

 my $count = 0;

#################################################################################
# sub init_vars() - sorts out the command line arguments
#               this is a standard perl piece of code 
# INPUT  : command line args
# OUTPUT : none
#
sub init_vars()
#################################################################################
{
    use Getopt::Std;
    my $opt_string = 'hn:s:a:m:v:';
    getopts( "$opt_string", \%opt ) or usage();
    usage() if $opt{h};
    @NODES       = split / /,$opt{n} if $opt{n};
    $SVCCLASS   = $opt{s} if $opt{s};
    $DEF_EMAIL  = $opt{a} if $opt{a};
    $USER_EMAIL = $opt{m} if $opt{m};
    $VALUES     = $opt{v} if $opt{v} 
}

#################################################################################
#sub usage() 
# Message / help message about this program and how to use it 
# INPUT  : none 
# OUTPUT : none
#
sub usage() 
#################################################################################
{
    print STDERR  "This program automates the shutdown of Castor disk servers.\n\n"; 
    
    print STDERR  "usage: $0 [-h] [-n node] [-s svcclass] [[-a email address] | [-m email address] ]\n";
    print STDERR  "-h                 : this help message.\n";
    print STDERR  "-n <node>          : name of node to be taken out of production.\n";
    print STDERR  "-n <node> <node> : names of the nodes to be taken out of production - in quotes with spaces.\n";
    print STDERR  "-s <svcclass>      : the service class files will be migrated to. See Twiki for more information.\n";
    print STDERR  "-a <email address> : alternative email address to $DEF_EMAIL e.g. messages to this address only.\n";
    print STDERR  "-m <email address> : additional email address to $DEF_EMAIL\n";
    print STDERR  "                     e.g. messages to $DEF_EMAIL and CC'd to the additional email address.\n";
    print STDERR  "-v <values>        : provide values for which type of files are to be migrated from node.\n";
    print STDERR  "                     Default is DISKCOPY_STAGED|DISKCOPY_CANBEMIGR\n\n\n";
    print STDERR  "example: $0 -n node001 -m name.surname\@cern.ch\n\n";

    exit 0;    
}


#################################################################################
# sub send_email()
# simple subroutine to send email to castor ops / user as needed
# INPUT  : @ of nodes
# OUTPUT : 0 (ok) | -1 (BAD)
#
sub send_email (@)
#################################################################################
{
    my @NODES = @_;

    return -1 if $#NODES < 0;

    foreach $NODE (@NODES){
	
	my $message ="### This is an automatic mail. Please do not reply. ###\n\n";
	$message .="disknodeShutdown has set the node $NODE to DOWN and is draining it\n\n";
	$message .="\n\nRegards,\n\ndisknodeShutdown\n";

    open (SENDMAIL, "| /usr/sbin/sendmail -t -oi -f disknodeShutdown\@spam.cern.ch");

print SENDMAIL <<End_of_Mail;
To: $DEF_EMAIL
Reply-to:disknodeShutdown\@spam.cern.ch
Subject: Server being taken out of production
$message
End_of_Mail
close(SENDMAIL);

     }

    return 0;
}

#################################################################################
# sub wait_for_input()
# simple subroutine to pause program while waiting for user to agree to continuing
# INPUT  : none (direct) but command line interaction
# OUTPUT : 0 as exit or return
#
#
sub wait_for_input()
#################################################################################
{
    my $data;

    do {
	print "\n\nPlease enter y(es) to continue or q(uit) to quit program and then enter.\n";
	chomp ($data = <STDIN>);
    }while ($data !~ m/^(y|yes|q|quit)$/i);

    if ($data =~ m/^(y|yes)$/i)  { return 0; }
    if ($data =~ m/^(quit|q)$/i) { exit 0;   }

}

#################################################################################
# sub check_progress () 
# INPUT  : array
# OUTPUT : -1 PROBLEM | 0 ok | >0 count
#

sub check_progress (@) {
#################################################################################

    my @ary  = @_;    

    return -1 if $#ary < 0;

    my ($i, $total) = 0;
    
    print "Checking " . ($#ary + 1) . " files\n";

    for ($i = 0; $i <= $#ary; $i++) {

        if (not $ary[$i] ){
	    print "Blank value in file migration array. Skipping to next value.\n";
	    next;
	}
	
	my $filepath = `nsGetPath castorns $ary[$i]`;

	if (length($filepath) != 0 ) {
	    open (CHECK, "/usr/bin/stager_qry -S $SVCCLASS  -M $filepath |");
	    while (<CHECK>) {
		#print $_;
		if ($_ =~ m/($VALUES|CANBEMIGR|STAGED)/i ){ 
		    print "[MATCH] $_\n"; 
		    $total++;
		}
	    }
	    close(CHECK);
	} else {
	    print "[FILEPATH=0] $_"; 
	    $total++;
	}
    }
    
    if ($total != 10) { 
	print "Currently transfering $total files. Sleeping for $DELAY seconds.\n"; 
	sleep ($DELAY);
    } else { 
	sleep(2); 
    }
    
    return $total;
}


#################################################################################
# INPUT  : node name
# OUTPUT : filename as string / -1 for error
#
# This produced a file in the format  - FileID State localpath castorpath
#
sub create_file () {
#################################################################################

    my ($NODE) = shift;

    if (not $NODE) {
	print "[ERR] Node name not supplied to sub create_file.\n";
	return -1;
    }

    my $file = "/tmp/recov.$NODE" . time();
    my $count = 0;

    print "Creating file - $file - to contain list of files to move.\n"; 

    if (system("/bin/touch $file") != 0) {
	print "[ERR] Unable to touch file - $file\n";
	return -1;
    }

    print "Creating a list of files to move - this should not take long\n";

    eval {open(FILE, ">$file"); }; 

    if ($@) {
	print "Problem opening file $file for writing : $@\n";
	return -1;
    }

    open(CMD, "diskServer_qry -i $NODE |"); 

    <CMD>;

    foreach (<CMD>) { 
	chomp;
	next if /^FileId/;
	next if ! /($VALUES)/;
	my @line = split (/\s+/);
	my $filepath = `nsGetPath castorns $line[0] 2> /dev/null `; #suppress castorns error output
	if (length($filepath) != 0 ) {
	    print FILE $_ . " ". $filepath;
	    $count++;
	}
	if ($count % 100 == 0 && $count != 0) {print ".";}
	if ($count % 1000 == 0 && $count != 0) {print "$count files to be processed.\n";}
    }
    close(CMD);
    close(FILE);

    print "List of files to move has been created with $count entries.\n";
    
    return $file,$count;
}

#################################################################################
# sub final_check
# input : nodename, filepath
# output: none
#
#################################################################################

sub final_check() {
    my $node = shift;
    my $file = shift;

    my $outfile = "/tmp/error_${node}_" . time();
   
    eval { open (F, "<$file"); }; 

    if ($@){
	print "[ERR] Unable to open $file for final check : $@\n";
	exit -1;
    }
    
    eval {open (O, ">$outfile"); };

    if ($@){
	print "[ERR] Unable to open $outfile for final check : $@\n";
	exit -1;
    }

    foreach (<F>) {
	my @tmp = split(/\s+/);
        my $filepath = `nsGetPath castorns $tmp[0]`;

        if (length($filepath) != 0 ) {
	    open (X, "/usr/bin/stager_qry -S $SVCCLASS -M $filepath |");
		foreach (<X>) {
		    chomp;
		    next if /^Received/;
		    last if /(CANBEMIGR|STAGED)/;
		    print "Problem with $tmp[2]\n";
		    print O "$tmp[2]\n";
		}
	    close (X);
	}
    }
    close (F);
    print "File name for errors is $outfile\n";
    close (O);

    return 0;
}
#################################################################################
# sub TransferManager()
# process to transfer files off the node
# This subroutine generates a file of the id and path to the files which need to 
# potentially be moved from the current node to others.
#
#      notes: log into castorscheduler and run bhoststo get current status
# input: nodename 
# output : -1 error, 0 ok
#
sub TransferManager()
#################################################################################
{
    my ($NODE) = shift;

    my @working_files; 		#an array of the files currently being worked on
    
    my $active_transfers = 0;
    my $active = 0;
    my $total_done = 0;
    
    my ($file,$count) = &create_file($NODE);
    
    unless (-e $file) {
	print "[ERR] File - $file - does not exist\n";
	return -1;
    }

    eval { open(FILE, "<$file");};
    if ($@) {
	print "[ERR] Problem opening file $file for reading : $@\n";
	print "[WARN] Going to try next node ...\n";
	return -1;
    }

    print "Do you want to start the transfer?.\n"; 
    &wait_for_input();
    
    foreach (<FILE>){

	my ($ID, $STATUS, $LOCAL, $Notsure, $URL) = split /\s+/, $_;
		
	if ($active == 10) {

	    print "End of 10 file ops. Checking progress before continuing.\n";
	    do { 
		$active_transfers = &check_progress(@working_files); 

	    } while ($active_transfers != $active); 
	    
	    @working_files = ();
	    $active = 0;	
	    $total_done += 10;
	    print "$total_done files of $count processed. \n"; 
	    
	} 
	
	
        open(EXECUTE, "/usr/bin/stager_get -S $SVCCLASS -M $URL 2>&1|"); 
        $working_files[$active++] = $ID;
	
	my $output = <EXECUTE>;
	until (length($output) > 0) {
	    sleep (1);
	    $output = <EXECUTE>;		      
	}
	print $output; 
	if ($output =~ /Error/){
	    print <EXECUTE>;
	    print "\nerror on $URL retrying once...\n\n";
	    open(EXECUTE, "/usr/bin/stager_get -S $SVCCLASS -M $URL 2>&1|");
	    my $output = <EXECUTE>;
	    until (length($output) > 0) {
		sleep (1);
		$output = <EXECUTE>;
	    }
	}	
	print <EXECUTE>;
        close (EXECUTE);
	
	if ( ($total_done+$active) == $count ) {
	    
	    print "End of file list.\n";
	    do { 
		$active_transfers = &check_progress(@working_files); 
	    } while ($active_transfers != $active); 
	}
	
    }#END FOREACH
	close(FILE);
    
    &final_check($NODE, $file);
    
    print "Finished!\n";
    return 0; 
    
}
    
    
#################################################################################
# start of main code
#
# Note: we have used open (X ...  and then piped stuff because using `` format to 
#       execute on the command line wasn't translating the variables to their value
#       This was the best work around we could find. 


    init_vars();          

if ($#NODES < 0){ 
    print "[ERR] You need to supply the name of at least one node to be taken out of service.\n"; 
    usage();
} 
if ($USER_EMAIL && $USER_EMAIL !~ /@/) { 
    print "[ERR] Your email address - $USER_EMAIL - needs a \@ somewhere in it.\n"; 
    usage();
} 	
if ($DEF_EMAIL !~ /@/) { 
    print "[ERR] Your default email address - $DEF_EMAIL - needs a \@ somewhere in it!\n"; 
    usage();
}
if (not $SVCCLASS){
    print "[ERR] You need to supply a service class to move the node(s) into";
    usage();
}
if (not -x "/usr/bin/nsGetPath") {
    print "[ERR] Unable to execute - /usr/bin/nsGetPath - as user - $ENV{'USERNAME'} -. Exiting. "; 
    exit 1;
}
if (not -x "/usr/sbin/sendmail"){
    print "[ERR] Unable to execute - /usr/sbin/sendmail - as user - $ENV{'USERNAME'} -. Exiting. "; 
    exit 1;
} 
if (not -x "/usr/bin/stager_qry"){
    print "[ERR] Unable to execute - /usr/bin/stager_qry - as user - $ENV{'USERNAME'} -. Exiting. "; 
    exit 1;
}
if (not -x "/usr/bin/stager_get"){
    print "[ERR] Unable to execute - /usr/bin/stager_get - as user - $ENV{'USERNAME'} -. Exiting. "; 
    exit 1;
}
if (not -x "/bin/touch"){
    print "[ERR] Unable to execute - /bin/touch - as user - $ENV{'USERNAME'} -. Exiting. "; 
    exit 1;
}
#here we check each node for files, prompt the user to continue, and then move the node to recovery

foreach my $NODE (@NODES){

    $NODE =~ tr/A-Z/a-z/;

    open(JUNKVAL, "diskServer_qry $NODE | egrep 'DISKCOPY_WAIT|DISKCOPY_STAGEOUT' |"); 
    close (JUNKVAL); 
    
    print "If there are active transfers for $NODE please decide if you wish to continue.\n";	
    &wait_for_input();		
    
    print "Moving $NODE to recovery pool.\n";
    
    if (system("/usr/bin/moveDiskServer recovery $NODE") == 0) {
	print "$NODE has been moved to recovery.\n";
    } else {
	print "Failed to move $NODE to recovery. Now exiting.\n";
	exit 1;
    }
    
}

#send an email to say which machines are being taken out of production    
    &send_email(@NODES);	

#clean each machine sequentially
foreach (@NODES) {
    my $ret = &TransferManager($_);
    if ($ret != 0) {
	print "[WARN] Problem transfering files from node $_\n";
	next;
    }
}

print "Finished running $0\n";

exit 0;
