#!/usr/local/bin/perl -w
#
#

use strict;
use diagnostics;
use lib "/usr/lib/perl/CASTOR";
use castor_tools;
use DBD::Oracle qw(:ora_types);

$ENV{"ORACLE_HOME"}  = "/afs/cern.ch/project/oracle/\@sys/prod"
    unless exists($ENV{"ORACLE_HOME"});
$ENV{"TNS_ADMIN"}    = "/afs/cern.ch/project/oracle/admin"
    unless exists($ENV{"TNS_ADMIN"});
$ENV{"PATH"} = "/bin:/usr/bin:/sbin:/usr/sbin";

# usage function
sub usage {
  printf("Usage : %s [-h] fileId [...]\n", $0);
}

# first parse the options
my $help;
if (0 == Getopt::Long::GetOptions ('h|help' => \$help)) {
  usage();
  exit(1);
}

if ($help) {
  usage();
  exit(0);
}

my $dbquery;

# Parse command line
my $arg;
my $first = 1;
my $nbargs = 0;
for $arg (@ARGV) {
  # take care of empty args
  if ($arg ne "") {
    $nbargs++;
  #  # avoid SQL injection by keeping only numbers
  #  if ($arg =~ /[^0-9]/) {
  #    print "Error : \"$arg\" is not a number\n";
  #    usage();
  #    exit;
  #  }
    # avoid SQL injection by keeping only servers
    my @servers = ( 'lxfsrc4402', 'lxfsrk6104', 'lxfsra0801', 'lxfsra1006', 'lxfsra3007', 'lxfsra3008', 'lxfsrk3907', 'lxfsra1008' );
    ##my $argok = 0;
    my $argok = 1;
    foreach my $servername (@servers) {
      if ($arg eq $servername) {
        $argok = 1;
      }
    }
    if ($argok == 0) {
      print "Error : \"$arg\" is not a server\n";
      usage();
      exit;
    }
    if ($first == 1) {
      $first = 0;
    } else {
      $dbquery .= ", ";
    }
    $dbquery .= $arg;
  }
}

# If no arg, display usage
if ($nbargs == 0) {
  usage();
  exit;
}

#
# Oracle connection
#
my @castor_conf = castor_conf_getOraStagerSvc();
my $Dbh = DBI->connect("dbi:Oracle:", $castor_conf[0] ,$castor_conf[1],
                    { RaiseError => 1,
		      AutoCommit => 0})
  or die "cannot connect to c2cmsstgdb: $DBI::errstr";

#
# register Oracle disconnection
#
END {
    $Dbh->disconnect if $Dbh;
}

#$Dbh->trace(1);

# MAIN
for $arg (@ARGV) {
  my %mountpoint;
  my %diskpool;
  my %fsstat;
  my $readablefsstat;
  my %poolname;
  my $hostname;
  my $serverstat;
  my $readableserver;
  my @ServerStatus = ("DISKSERVER_PRODUCTION",
                      "DISKSERVER_DRAINING",
                      "DISKSERVER_DISABLED",
                      "DISKSERVER_NONE");
  my @FileSystemStatus = ("FILESYSTEM_PRODUCTION",
                          "FILESYSTEM_DRAINING",
                          "FILESYSTEM_DISABLED");
  my $hostoutput = `/usr/bin/host $arg`;
  if ($hostoutput =~ m/^(\S+)( has address )/i ){
    $hostname = $1;  # fully qualified hostname
  } else {
    die "wrong output of /usr/bin/host $arg\n";
  }
  my $Sth = $Dbh->prepare(qq{
                      select status
                      from castor_stager.diskserver
                      where name = '$hostname'
                       });
  $Sth->execute;
  while (my @list = $Sth->fetchrow_array) {
    my $invalid=0;
    die("columns mismatch: @list") unless @list == 1;
    ($serverstat) = @list;
  }
  $Sth->finish;

  $Sth = $Dbh->prepare(qq{
	SELECT name,id from diskpool where id in (
  		(select diskpool from filesystem where diskserver in (
      			(SELECT Id FROM DiskServer WHERE name = '$hostname'))))
			 });
  $Sth->execute;
nextmac:
  #printf ("\n$arg:\n");
  while (my @list = $Sth->fetchrow_array) {
    my $invalid=0;
    die("columns mismatch: @list") unless @list == 2;
    my ($svcclassname, $svcclassid) = @list;
    $poolname{$svcclassid} = $svcclassname;
  }
  $Sth->finish;
  if ($serverstat <= $#ServerStatus) {
    $readableserver = $ServerStatus[$serverstat];
  } else {
    $readableserver = "Unknown diskserver status : " . $serverstat;
  }
  printf ("%-16s ",$hostname);
  #foreach my $svcclassname (values %poolname) {
  #  printf ("%-11s ",$svcclassname);
  #}
  printf ("%-10s ",$readableserver);

  $Sth = $Dbh->prepare(qq{
     select MOUNTPOINT,DISKPOOL,STATUS,ID from filesystem where diskserver in (
                        (SELECT Id FROM DiskServer WHERE name = '$hostname'))
                         });
  $Sth->execute;
nextmac:
  #printf ("\n$arg:\n");
  while (my @list = $Sth->fetchrow_array) {
    my $invalid=0;
    die("columns mismatch: @list") unless @list == 4;
    my ($mountpointval, $diskpoolval, $fsstatval, $filesystemid) = @list;
    $mountpoint{$filesystemid} = $mountpointval;
    $diskpool{$filesystemid} = $diskpoolval;
    $fsstat{$filesystemid} = $fsstatval;
    if ( not exists $poolname{$diskpool{$filesystemid}} ){
        printf ("\nError: no name for diskpool ID = %ld\n",$diskpool{$filesystemid});
        $poolname{$diskpool{$filesystemid}} = "Unknown diskpool : " . $diskpool{$filesystemid};
    }
  }
  $Sth->finish;
  printf ("\n");
  printf ("%-16s ","FileSystemId");
  printf ("%-16s ","MountPoint");
  printf ("%-11s ","DiskPool");
  printf ("%-10s ","Status");
  printf ("\n");
  foreach my $filesystemid (sort keys %mountpoint) {
    if ($fsstat{$filesystemid} <= $#FileSystemStatus) {
        $readablefsstat = $FileSystemStatus[$fsstat{$filesystemid}];
    } else {
        $readablefsstat = "Unknown filesystem status : " . $fsstat{$filesystemid};
    }
    printf ("%-16d ",$filesystemid);
    printf ("%-16s ",$mountpoint{$filesystemid});
    printf ("%-11s ",$poolname{$diskpool{$filesystemid}});
    printf ("%-10s ",$readablefsstat);
    printf ("\n");

  }

  my $stagedcount = 0;
  my $canbemigrcount = 0;
  my $stageoutcount = 0;
  my $restcount = 0;
  my $waittaperecallcount = 0;
  my $failedcount = 0;
  my $invalidcount = 0;
  my $waitd2dcpcount = 0;
  my $gccandidatecount = 0;
  my $beingdeletedcount = 0;
  printf ("File Status Summary: ");
  open (DSQ, "diskServer_qry $hostname |") or die "cannot open diskServer_qry $hostname - $!\n";
    while (<DSQ>) {
      my ($filestat, $filepath) = split (/\s+/, $_);
      if    ($filestat eq "DISKCOPY_STAGED" )    { $stagedcount++; }
      elsif ($filestat eq "DISKCOPY_CANBEMIGR" ) { $canbemigrcount++; }
      elsif ($filestat eq "DISKCOPY_STAGEOUT" )  { $stageoutcount++; }
      elsif ($filestat eq "DISKCOPY_WAITTAPERECALL" ) {$waittaperecallcount++; }
      elsif ($filestat eq "DISKCOPY_FAILED" ) {$failedcount++; }
      elsif ($filestat eq "DISKCOPY_INVALID" ) {$invalidcount++; }
      elsif ($filestat eq "DISKCOPY_WAITDISK2DISKCOPY" ) {$waitd2dcpcount++; }
      elsif ($filestat eq "DISKCOPY_GCCANDIDATE" ) {$gccandidatecount++; }
      elsif ($filestat eq "DISKCOPY_BEINGDELETED" ) {$beingdeletedcount++; }
      elsif ($filestat eq "Status" )  { next; }
      else  { print "\n$_"; $restcount++; }
    }
    close(DSQ);
    printf ("STAGED=$stagedcount ");
    if ($canbemigrcount) {
      printf ("CANBEMIGR=$canbemigrcount ");
    }
    if ($stageoutcount) {
      printf ("STAGEOUT=$stageoutcount ");
    }
    if ($waittaperecallcount) {
      printf ("WAITRECALL=$waittaperecallcount ");
    }
    if ($failedcount) {
      printf ("FAILED=$failedcount ");
    }
    if ($invalidcount) {
      printf ("INVALID=$invalidcount ");
    }
    if ($waitd2dcpcount) {
      printf ("WAITDISK2DISKCOPY=$waitd2dcpcount ");
    }
    if ($gccandidatecount) {
      printf ("GCCANDIDATE=$gccandidatecount ");
    }
    if ($beingdeletedcount) {
      printf ("BEINGDELETED=$beingdeletedcount ");
    }
    if ($restcount) {
      printf ("REST=$restcount");
    }
    printf ("\n");

}
