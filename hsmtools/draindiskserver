#!/usr/bin/python
#******************************************************************************
#                      draindiskserver
#
# This file is part of the Castor project.
# See http://castor.web.cern.ch/castor
#
# Copyright (C) 2003  CERN
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
#
#
# Tool to manage the draining of filesystems and diskservers.
#
# @author Castor Dev team, castor-dev@cern.ch
#******************************************************************************

'''Tool to manage the draining of filesystems and diskservers'''

import sys
import getopt
import castor_tools
import cx_Oracle

# Usage function
def usage(exitCode):
    '''prints usage'''
    print 'Usage :'
    print '  draindiskserver -h/--help'
    print '  draindiskserver -a/--add -n diskServer [-m mountpoint] [-S serviceclass] [--auto-delete] [--file-mask=(NOTONTAPE|ALL)] [--comment=comment]'
    print '  draindiskserver -q/--query [-n diskServer [-m mountpoint]] [-c/--config] [-r/--running] [--script]'
    print '  draindiskserver -q/--query [-n diskServer [-m mountpoint]] -f/--failures'
    print '  draindiskserver -d/--delete -n diskServer [-m mountpoint]'
    sys.exit(exitCode)

# first parse the options
try:
    options, arguments = getopt.getopt(sys.argv[1:], 'han:m:S:qcfrdv',
                                  ['help', 'add', 'nodename=', 'mountpoint=',
                                   'svcclass=', 'auto-delete', 'file-mask=',
                                   'comment=', 'query', 'config', 'failures',
                                   'running', 'script', 'delete', 'verbose'])
    # Any positional arguments left over after parsing?
    if len(arguments):
        usage(1)
except Exception, parsingException:
    print parsingException
    usage(1)

class FileMask(object):
  '''Constants defining the existing types of transfer'''
  NOTONTAPE = 0
  ALL = 1
  def __init__(self):
    '''empty constructor, raises an exception'''
    raise NotImplementedError
  @staticmethod
  def toStr(tType):
    '''prints a readable version of the transfer types'''
    if tType == FileMask.NOTONTAPE:
      return 'NotOnTape'
    elif tType == FileMask.ALL:
      return 'All'
    else:
      return 'UNKNOWN'
  
class DiskServerStatus(object):
  '''Constants defining the status for DiskServers'''
  PRODUCTION = 0
  DRAINING = 1
  DISABLED = 2
  READONLY = 3
  def __init__(self):
    '''empty constructor, raises an exception'''
    raise NotImplementedError
  @staticmethod
  def toStr(dsStatus):
    '''prints a readable version of the diskServer status'''
    if dsStatus == DiskServerStatus.PRODUCTION:
      return 'PRODUCTION'
    elif dsStatus == DiskServerStatus.DRAINING:
      return 'DRAINING'
    elif dsStatus == DiskServerStatus.DISABLED:
      return 'DISABLED'
    elif dsStatus == DiskServerStatus.READONLY:
      return 'READONLY'
    else:
      return 'UNKNOWN'
  
class FileSystemStatus(object):
  '''Constants defining the status for FileSystems'''
  PRODUCTION = 0
  DRAINING = 1
  DISABLED = 2
  READONLY = 3
  def __init__(self):
    '''empty constructor, raises an exception'''
    raise NotImplementedError
  @staticmethod
  def toStr(dsStatus):
    '''prints a readable version of the diskServer status'''
    if dsStatus == FileSystemStatus.PRODUCTION:
      return 'PRODUCTION'
    elif dsStatus == FileSystemStatus.DRAINING:
      return 'DRAINING'
    elif dsStatus == FileSystemStatus.DISABLED:
      return 'DISABLED'
    elif dsStatus == FileSystemStatus.READONLY:
      return 'READONLY'
    else:
      return 'UNKNOWN'

def drainingJobStatusToStr(status):
  '''prints a readable version of the drainingJobStatus'''
  if status == 0:
    return 'SUBMITTED'
  elif status == 1:
    return 'STARTING'
  elif status == 2:
    return 'RUNNING'
  elif status == 4:
    return 'FAILED'
  elif status == 5:
    return 'FINISHED'
  else:
    return 'UNKNOWN'
    
addFlag = False
queryFlag = False
deleteFlag = False
nodeName = None
mountPoint = None
svcClass = None
fileMask = 1 # default is ALL
fileMaskFlag = False
autoDelete = 0
autoDeleteFlag = False
configFlag = False
failuresFlag = False
runningFlag = False
scriptFlag = False
comment = None
verbose = False
for opt, arg in options:
    if opt in ('-h', '--help'):
        usage(0)
    elif opt in ('-a', '--add'):
        addFlag = True
    elif opt in ('-q', '--query'):
        queryFlag = True
    elif opt in ('-d', '--delete'):
        deleteFlag = True
    elif opt in ('-n', '--nodename'):
        nodeName = arg
    elif opt in ('-m', '--mountpoint'):
        mountPoint = arg
    elif opt in ('-S', '--svcclass'):
        svcClass = arg
    elif opt == '--file-mask':
        fileMaskFlag = True
        # Check that the user supplied filemask argument is valid
        values = { 'NOTONTAPE': 0,
                   'ALL':       1 }
        if not values.has_key(arg.upper()):
            print 'invalid option for --file-mask, must be one of NOTONTAPE or ALL'
            usage(1)
        fileMask = values[arg.upper()]
    elif opt == '--auto-delete':
        autoDelete = 1
        autoDeleteFlag = True
    elif opt in ('-c', '--config'):
        configFlag = True
    elif opt in ('-f', '--failures'):
        failuresFlag = True
    elif opt in ('-r', '--running'):
        runningFalg = True
    elif opt == '--script':
        scriptFlag = True
    elif opt == '--comment':
        comment = arg
    elif opt == '-v' or opt == '--verbose':
        verbose = True
    else:
        print "unknown option : " + opt
        usage(1)

# If any arg, complain and stop
if len(arguments) != 0:
    print "Unknown arguments : " + ' '.join(arguments) + "\n"
    usage(1)

# Check consistency of arguments
if not (addFlag or queryFlag or deleteFlag):
    print 'missing operation, must specify one of --add, --delete or --query'
    usage(1)
if [addFlag, queryFlag, deleteFlag].count(True) > 1:
    print 'options --add, --delete and --query are mutually exclusive'
    usage(1)
if nodeName == None and (addFlag or deleteFlag):
    print 'missing -n, --nodename option'
    usage(1)
if mountPoint != None and nodeName == None:
    print '--nodename option is needed when --mountPoint is used'
    usage(1)
if (addFlag or deleteFlag) and (configFlag or failuresFlag or runningFlag or scriptFlag):
    print 'incompatible set of options : --config, --failures, --running and --script are only valid with --query'
    usage(1)
if (queryFlag or deleteFlag) and (svcClass != None or autoDeleteFlag or fileMaskFlag or comment != None):
    print 'incompatible set of options : --query. svcclass, auto-delete, file-mask and comment are only valid with --add'
    usage(1)
if failuresFlag and (configFlag or runningFlag or scriptFlag):
    print 'option --running, --config and --scripts can not be used with --failures'
    usage(1)

def getFileSystems(stcur):
    '''check the nodeName and mountPoint, and returns the list of filesytem concerned
       in the form of triplets (diskServerId, FileSystemId, mountPoint)'''
    stGetFileSystemIds = '''
    SELECT DiskServer.id, FileSystem.id, FileSystem.mountPoint
      FROM FileSystem, DiskServer
     WHERE DiskServer.name = :nodeName
       AND FileSystem.diskServer = DiskServer.id
       AND (FileSystem.mountPoint = :mountPoint OR :mountPoint IS NULL)'''
    stcur.execute(stGetFileSystemIds, nodeName=nodeName, mountPoint=mountPoint)
    fileSystems = stcur.fetchall()
    if len(fileSystems) == 0:
        print 'Unable to find concerned filesystems. Please check node name and/or mount point'
        print 'in particular make sur that diskserver name is fully qualified and that mountPoint ends with /'
        sys.exit(1)
    return fileSystems


def getSvcClassId(stcur):
    '''checks the given svcClass if any and gets its id. Else find out
       the service class to be used, that is the one of the involved filesytems'''
    # if any service class is given, get its id
    if svcClass != None:
        stCheckSvcClass = '''
        BEGIN
          :svcClassId := checkForValidSvcClass(:svcClassName, 0, 1);
        END;'''
        try:
            varClassId = stcur.var(cx_Oracle.NUMBER)
            stcur.execute(stCheckSvcClass, svcClassId=varClassId, svcClassName=svcClass)
            return varClassId.getvalue()
        except cx_Oracle.Error:
            # not found, print an error and exit
            print 'Unknown service class "%s". Giving up' % svcClass
            sys.exit(1)
    else:
        # no service class given, get the one of the involved filesystems
        stGetSvcClass = '''
        SELECT DiskPool2SvcClass.child
          FROM FileSystem, DiskServer, DiskPool2SvcClass
         WHERE DiskServer.name = :nodeName
           AND FileSystem.diskServer = DiskServer.id
           AND (FileSystem.mountPoint = :mountPoint OR :mountPoint IS NULL)
           AND FileSystem.diskpool = DiskPool2SvcClass.parent'''
        stcur.execute(stGetSvcClass, nodeName=nodeName, mountPoint=mountPoint)
        svcClassIds = stcur.fetchall()
        if len(svcClassIds) == 0:
            print 'Unable to find service class of the given node. Giving up'
            sys.exit(1)
        elif len(svcClassIds) > 1:
            print 'Found several possible service classes for this drain. Please specify --svcclass option'
            sys.exit(1)
        return svcClassIds[0][0]


def submitDrain():
    '''submits new draining jobs'''
    # prepare DB connection
    stconn = castor_tools.connectToStager()
    try:
        stcur = stconn.cursor()
        stcur.arraysize = 50
        # precompute some useful values about us
        machine, euid, egid, pid, userName = castor_tools.getIdentity()[0:5]
        # check the nodeName and mountPoint, and get the list of filesytem ids concerned
        fileSystems = getFileSystems(stcur)
        # check the service class and gets its id
        svcClassId = getSvcClassId(stcur)
        # create DrainingJob statement
        stCreateDrainingJob = '''
        INSERT INTO DrainingJob (id, userName, euid, egid, pid, machine,
                                 creationTime, lastModificationTime, status, fileSystem,
                                 svcClass, autoDelete, fileMask, totalFiles, totalBytes,
                                 nbFailedBytes, nbFailedFiles, nbSuccessBytes,
                                 nbSuccessFiles, userComment)
        VALUES (ids_seq.nextval, :userName, :euid, :egid, :pid, :machine,
                getTime(), getTime(), 0, :fsId, :svcClassId, :autoDelete, :fileMask,
                0, 0, 0, 0, 0, 0, :userComment)'''
        # SQL statements
        stCheckDrainingJob = '''
        SELECT username, machine, creationTime
          FROM DrainingJob
         WHERE fileSystem = :fsId'''
        stCheckFSState = 'SELECT status FROM FileSystem WHERE id = :fsId'
        stCheckDSState = 'SELECT status FROM DiskServer WHERE id = :dsId'
        stUpdateFSState = 'UPDATE FileSystem SET status = 1 WHERE id = :fsId' # DRAINING
        stUpdateDSState = 'UPDATE DiskServer SET status = 1 WHERE id = :dsId' # DRAINING
        # First check DiskServer status
        stcur.execute(stCheckDSState, dsId=fileSystems[0][0])
        dsStatus = stcur.fetchall()[0][0]
        if dsStatus == DiskServerStatus.DISABLED:
            print 'DiskServer %s is in DISABLED state. Giving up' % machine
            return
        # In case no filesystem is given by the user, switch the status of the
        # diskserver to DRAINING. In case filesystems are mentionned, the DiskServer
        # status is not touched
        if mountPoint == None:
            stcur.execute(stUpdateDSState, dsId=fileSystems[0][0])
        # go through all the concerned filesystem
        for dsId, fsId, fsMountPoint in fileSystems: # pylint: disable=W0612
            # first check the filesystem status
            stcur.execute(stCheckFSState, fsId=fsId)
            dsStatus = stcur.fetchall()[0][0]
            if dsStatus == FileSystemStatus.DISABLED:
                print 'Filesystem %s:%s is in DISABLED state. Skipping it' % (machine, fsMountPoint)
                continue
            # then check that the filesystem is not already draining
            stcur.execute(stCheckDrainingJob, fsId=fsId)
            drains = stcur.fetchall()
            if (len(drains)) > 0:
                print 'Filesystem %s:%s already has a draining session. Use --delete to cancel it' % \
                  (machine, fsMountPoint)
                print '    for info, drain was issued by %s on %s at %s' % \
                  (drains[0][0], drains[0][1], castor_tools.secsToDate(drains[0][2]))
                continue
            # change the state of the filesystem to DRAINING, i.e. trigger passive draining
            stcur.execute(stUpdateFSState, fsId=fsId)
            # finally start active draining
            stcur.execute(stCreateDrainingJob, userName=userName, euid=euid, egid=egid,
                          pid=pid, machine=machine, fsId=fsId, svcClassId=svcClassId,
                          autoDelete=autoDelete, fileMask=fileMask, userComment=comment)
            print 'Started draining for %s:%s' % (machine, fsMountPoint)
        stconn.commit()
    finally:
        # close DB connection
        castor_tools.disconnectDB(stconn)

def queryFailures():
    '''queries draining failures'''
    # prepare DB connection
    stconn = castor_tools.connectToStager()
    try:
        stcur = stconn.cursor()
        stcur.arraysize = 50
        stGetFailures = '''
        SELECT DiskServer.name, fileSystem.mountPoint,
               DrainingErrors.fileId, DrainingErrors.errorMsg
          FROM DiskServer, FileSystem, DrainingJob, DrainingErrors
         WHERE (DiskServer.name = :nodeName OR :nodeName IS NULL)
           AND FileSystem.diskServer = DiskServer.id
           AND (FileSystem.mountPoint = :mountPoint OR :mountPoint IS NULL)
           AND DrainingJob.fileSystem = FileSystem.id
           AND DrainingErrors.drainingJob = DrainingJob.id'''
        stcur.execute(stGetFailures, nodeName=nodeName, mountPoint=mountPoint)
        data = stcur.fetchall()
        titles = ('DiskServer', 'MountPoint', 'fileId', 'Error')
        castor_tools.prettyPrintTable(titles, data)
    finally:
        # close DB connection
        castor_tools.disconnectDB(stconn)            
        
def queryDrain():
    '''queries ongoing drainings'''
    # prepare DB connection
    stconn = castor_tools.connectToStager()
    try:
        stcur = stconn.cursor()
        stcur.arraysize = 50
        stGetDrains = '''
        SELECT DiskServer.name, FileSystem.mountPoint,
               DrainingJob.username, DrainingJob.machine, DrainingJob.userComment,
               DrainingJob.creationTime, DrainingJob.totalFiles, DrainingJob.totalBytes,
               DrainingJob.fileMask, DrainingJob.autoDelete, getSvcClassName(DrainingJob.svcClass),
               DrainingJob.status, DrainingJob.nbFailedBytes, DrainingJob.nbSuccessBytes,
               DrainingJob.nbFailedFiles, DrainingJob.nbSuccessFiles, getTime()
          FROM DrainingJob, FileSystem, DiskServer
         WHERE DrainingJob.fileSystem = FileSystem.id
           AND FileSystem.diskServer = DiskServer.id
           AND (DiskServer.name = :nodeName OR :nodeName IS NULL)
           AND (FileSystem.mountPoint = :mountPoint OR :mountPoint IS NULL)'''
        if runningFlag:
            stGetDrains += ' AND DrainingJob.status = 2'  # RUNNING
        stGetDrains += ' ORDER BY DiskServer.name, FileSystem.mountPoint'
        stcur.execute(stGetDrains, nodeName=nodeName, mountPoint=mountPoint)
        results = stcur.fetchall()
        # Check if we've found something
        if len(results) == 0:
            print 'Nothing found'
            return
        # depending on the presence of the config flag, we do not
        # display the same set of columns
        if configFlag:
            titles = ['DiskServer', 'MountPoint', 'UserName', 'Machine', 'SvcClass',
                      'FileMask', 'AutoDelete', 'Comment']
            data = [(diskServerName, fsMountPoint, userName, machine, svcClassName,
                     FileMask.toStr(DJFileMask), castor_tools.intToBool(DJAutoDelete), DJComment)
                    for diskServerName, fsMountPoint, userName, machine,
                    DJComment, creationTime, totalFiles, totalBytes, DJFileMask, DJAutoDelete,
                    svcClassName, DJStatus, nbFailedBytes, nbSuccessBytes, nbFailedFiles,
                    nbSuccessFiles, currentTime in results]
        else:
            titles = ['DiskServer', 'MountPoint', 'Created', 'TFiles', 'TSize',
                      'RFiles', 'RSize', 'Failed', 'RunTime', 'Progress', 'ETC', 'Status']
            data = [(diskServerName, fsMountPoint, castor_tools.secsToDate(creationTime), totalFiles,
                     castor_tools.nbToDataAmount(totalBytes), totalFiles-nbFailedFiles-nbSuccessFiles,
                     castor_tools.nbToDataAmount(totalBytes-nbFailedBytes-nbSuccessBytes), nbFailedFiles,
                     castor_tools.nbToAge(int(currentTime-creationTime)),
                     castor_tools.printPercentage((nbSuccessBytes+nbFailedBytes), totalBytes),
                     castor_tools.printETC(nbSuccessBytes+nbFailedBytes, totalBytes, currentTime-creationTime),
                     drainingJobStatusToStr(DJStatus))
                    for diskServerName, fsMountPoint, userName, machine,
                    DJComment, creationTime, totalFiles, totalBytes, DJFileMask, DJAutoDelete,
                    svcClassName, DJStatus, nbFailedBytes, nbSuccessBytes, nbFailedFiles,
                    nbSuccessFiles, currentTime in results]
        # depending on the presence of the script flags, we use pretty
        # printing or script printing
        if scriptFlag:
            castor_tools.scriptPrintTable(data)
        else:
            castor_tools.prettyPrintTable(titles, data)
    finally:
        # close DB connection
        castor_tools.disconnectDB(stconn)
        
def deleteDrain():
    '''interrupts and ongoing draining job'''
    # prepare DB connection
    stconn = castor_tools.connectToStager()
    try:
        stcur = stconn.cursor()
        stcur.arraysize = 50
        # check the nodeName and mountPoint, and get the list of filesytem ids concerned
        fileSystems = getFileSystems(stcur)
        # check draining job statement
        stCheckDrainingJob = '''
        SELECT id
          FROM DrainingJob
         WHERE fileSystem = :fsId'''
        drainingJobs = []
        for dsId, fsId, fsMountPoint in fileSystems:  # pylint: disable=W0612
            # first check that the filesystem is not already draining
            stcur.execute(stCheckDrainingJob, fsId=fsId)
            drains = stcur.fetchall()
            if len(drains) == 0:
                print 'No draining activity found for %s:%s. Ignoring it' % (nodeName, fsMountPoint)
                continue
            print 'Draining activity for %s:%s will be stopped' % (nodeName, fsMountPoint)
            drainingJobs.append((fsMountPoint, drains[0][0]))
        if drainingJobs:
            # get user confirmation
            try:
                confirmation = castor_tools.parseBool('entry', raw_input("Is this ok ? [N/y] "), False)
            except castor_tools.ParsingError, e:
                print e
                exit(1)
            if not confirmation:
                print 'Ok, giving up'
                return
            # create DrainingJob statement
            stDeleteDrainingJob = 'BEGIN deleteDrainingJob(:djId); END;'
            # call it for each filesystem
            for fsMountPoint, djId in drainingJobs:
                print 'Stopping drain for %s:%s' % (nodeName, fsMountPoint)
                stcur.execute(stDeleteDrainingJob, djId=djId)
            stconn.commit()
    finally:
        # close DB connection
        castor_tools.disconnectDB(stconn)

# process the request
try:
    if addFlag:
        submitDrain()
    elif queryFlag:
        if failuresFlag:
            queryFailures()
        else:
            queryDrain()
    elif deleteDrain:
        deleteDrain()
    else:
        print "No option specified\n"
        usage(1)
except Exception, e:
    print e
    if verbose:
        import traceback
        traceback.print_exc()
    sys.exit(-1)
