/*
 * @project      The CERN Tape Archive (CTA)
 * @copyright    Copyright Â© 2021-2022 CERN
 * @license      This program is free software, distributed under the terms of the GNU General Public
 *               Licence version 3 (GPL Version 3), copied verbatim in the file "COPYING". You can
 *               redistribute it and/or modify it under the terms of the GPL Version 3, or (at your
 *               option) any later version.
 *
 *               This program is distributed in the hope that it will be useful, but WITHOUT ANY
 *               WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 *               PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 *               In applying this licence, CERN does not waive the privileges and immunities
 *               granted to it by virtue of its status as an Intergovernmental Organization or
 *               submit itself to any jurisdiction.
 */

#include <errno.h>
#include <stddef.h>
#include <stdexcept> 
#include <sys/mtio.h>

#include "FileWrappers.hpp"
#include "../SCSI/Structures.hpp"

using namespace castor::tape;

ssize_t System::vfsFile::read(void* buf, size_t nbytes)
{
  /* The vfsFile's operations always fail */
  errno = EINVAL;
  return -1;
}

ssize_t System::vfsFile::write(const void* buf, size_t nbytes)
{
  /* The vfsFile's operations always fail */
  errno = EINVAL;
  return -1;
}

int System::vfsFile::ioctl(unsigned long int request, mtop * mt_cmd)
{
  /* The vfsFile's operations always fail */
  errno = EINVAL;
  return -1;
}

int System::vfsFile::ioctl(unsigned long int request, mtget* mt_status)
{
  /* The vfsFile's operations always fail */
  errno = EINVAL;
  return -1;
}

int System::vfsFile::ioctl(unsigned long int request, sg_io_hdr_t * sgio_h)
{
  /* The vfsFile's operations always fail */
  errno = EINVAL;
  return -1;
}

ssize_t System::regularFile::read(void* buf, size_t nbytes)
{
  try {
    ssize_t ret;
    ret = m_content.copy((char *) buf, nbytes, m_read_pointer);
    m_read_pointer += ret;
    return ret;
  } catch (std::out_of_range & e) {
    return 0;
  }
}

ssize_t System::regularFile::write(const void *buf, size_t nbytes)
{
  try {
    m_content.assign((const char *) buf, nbytes);
    return nbytes;
  } catch (std::length_error & e) {
    return -1;
  } catch (std::bad_alloc & e) {
    return -1;
  }
}

/**
 * Constructor for fake tape server: fill up status registers
 * and internal structures.
 */
System::stDeviceFile::stDeviceFile()
{
  m_mtStat.mt_type = 1;
  m_mtStat.mt_resid = 0;
  m_mtStat.mt_dsreg = (((256 * 0x400) & MT_ST_BLKSIZE_MASK) << MT_ST_BLKSIZE_SHIFT)
      | ((1 & MT_ST_DENSITY_MASK) << MT_ST_DENSITY_SHIFT);
  m_mtStat.mt_gstat = GMT_EOT(~0) | GMT_BOT(~0);
  
  blockID = 0xFFFFFFFF; // Logical Object ID - position on tape 
  
  clearCompressionStats = false;
  m_LBPInfoMethod = 0xFA;
  m_LBPInfoLength = 0xBC;
  m_LBPInfo_R = 0xCD;
  m_LBPInfo_W = 0xAC;
}

int System::stDeviceFile::ioctl(unsigned long int request, struct mtop * mt_cmd)
{
  switch (request) {
    case MTIOCTOP:
      *mt_cmd = m_mtCmd;
      return 0;
  }
  errno = EINVAL;
  return -1;
}

int System::stDeviceFile::ioctl(unsigned long int request, mtget* mt_status)
{
  switch (request) {
    case MTIOCGET:
      *mt_status = m_mtStat;
      return 0;
  }
  errno = EINVAL;
  return -1;
}

int System::stDeviceFile::ioctl(unsigned long int request, sg_io_hdr_t * sgio_h)
{
  /* for the moment, just implement the SG_IO ioctl */
  switch (request) {
    case SG_IO:
      if (sgio_h->interface_id != 'S') {
        errno = ENOSYS;
        return -1;
      }
      switch (sgio_h->cmdp[0]) { // Operation Code for CDB
        case SCSI::Commands::READ_POSITION:
          return ioctlReadPosition(sgio_h);
        case SCSI::Commands::REQUEST_SENSE:
          return ioctlRequestSense(sgio_h);
        case SCSI::Commands::LOG_SELECT:
          return ioctlLogSelect(sgio_h);
        case SCSI::Commands::LOCATE_10:
          return ioctlLocate10(sgio_h);
        case SCSI::Commands::LOG_SENSE:
          return ioctlLogSense(sgio_h);       
        case SCSI::Commands::MODE_SENSE_6:
          return ioctlModSense6(sgio_h);
        case SCSI::Commands::MODE_SELECT_6:
          return ioctlModSelect6(sgio_h);
        case SCSI::Commands::INQUIRY:
          return ioctlInquiry(sgio_h);
      }
      return 0;
  }
  errno = EINVAL;
  return -1;
}

int System::stDeviceFile::ioctlReadPosition(sg_io_hdr_t* sgio_h) {
  if (SG_DXFER_FROM_DEV != sgio_h->dxfer_direction) {
    errno = EINVAL;
    return -1;
  }
  SCSI::Structures::readPositionDataShortForm_t & positionData =
          *(SCSI::Structures::readPositionDataShortForm_t *) sgio_h->dxferp;
  if (sizeof (positionData) > sgio_h->dxfer_len) {
    errno = EINVAL;
    return -1;
  }
  if (0xFFFFFFFF == blockID) { // there was no seek on tape
    /* fill the replay with random data */
    srandom(SCSI::Commands::READ_POSITION);
    memset(sgio_h->dxferp, random(), sizeof (positionData));

    /* we need this field to make the replay valid*/
    positionData.PERR = 0;
    /* fill with expected values */
    positionData.firstBlockLocation[0] = 0xAB;
    positionData.firstBlockLocation[1] = 0xCD;
    positionData.firstBlockLocation[2] = 0xEF;
    positionData.firstBlockLocation[3] = 0x12;
    positionData.lastBlockLocation[3] = 0xAB;
    positionData.lastBlockLocation[2] = 0xCD;
    positionData.lastBlockLocation[1] = 0xEF;
    positionData.lastBlockLocation[0] = 0x12;
    positionData.blocksInBuffer[0] = 0xAB;
    positionData.blocksInBuffer[1] = 0xCD;
    positionData.blocksInBuffer[2] = 0xEF;
    positionData.bytesInBuffer[3] = 0xAB;
    positionData.bytesInBuffer[2] = 0xCD;
    positionData.bytesInBuffer[1] = 0xEF;
    positionData.bytesInBuffer[0] = 0x12;
  } else { // we did seek on tape so we have real values
    /* we need this field to make the replay valid*/
    positionData.PERR = 0;
    /* fill with internal values 
     * lastBlockLocation=firstBlockLocation as soon as Buffer is empty.
     */
    SCSI::Structures::setU32(positionData.firstBlockLocation, blockID);
    SCSI::Structures::setU32(positionData.lastBlockLocation, blockID);
    SCSI::Structures::zeroStruct(positionData.blocksInBuffer);
    SCSI::Structures::zeroStruct(positionData.bytesInBuffer);
  }
  return 0;
}

int System::stDeviceFile::ioctlRequestSense(sg_io_hdr_t* sgio_h) {
  if (SG_DXFER_FROM_DEV != sgio_h->dxfer_direction) {
    errno = EINVAL;
    return -1;
  }
  SCSI::Structures::requestSenseData_t &requestSenseData =
    *reinterpret_cast<SCSI::Structures::requestSenseData_t*>(sgio_h->dxferp);
  if(sizeof(requestSenseData) > sgio_h->dxfer_len) {
    errno = EINVAL;
    return -1;
  }
  return 0;
}

int System::stDeviceFile::ioctlLogSelect(sg_io_hdr_t * sgio_h) {
  if (SG_DXFER_NONE != sgio_h->dxfer_direction) {
    errno = EINVAL;
    return -1;
  }
  /* we check CDB structure only and do not need to replay */
  SCSI::Structures::logSelectCDB_t & cdb =
          *(SCSI::Structures::logSelectCDB_t *) sgio_h->cmdp;
  if (1 != cdb.PCR || 0x3 != cdb.PC) {
    errno = EINVAL;
    return -1;
  }
  clearCompressionStats = true; /* set clear compression stats tag */
  return 0;
}

int System::stDeviceFile::ioctlLocate10(sg_io_hdr_t * sgio_h) {
  if (SG_DXFER_NONE != sgio_h->dxfer_direction) {
    errno = EINVAL;
    return -1;
  }
  /* perform logical seek on tape */
  SCSI::Structures::locate10CDB_t & cdb =
          *(SCSI::Structures::locate10CDB_t *) sgio_h->cmdp;
  blockID = SCSI::Structures::toU32(cdb.logicalObjectID);
  return 0;
}

int System::stDeviceFile::ioctlLogSense(sg_io_hdr_t * sgio_h) {
  if (SG_DXFER_FROM_DEV != sgio_h->dxfer_direction) {
    errno = EINVAL;
    return -1;
  }
  SCSI::Structures::logSenseCDB_t & cdb =
          *(SCSI::Structures::logSenseCDB_t *) sgio_h->cmdp;
  if (1 != cdb.PC || 0 == SCSI::Structures::toU16(cdb.allocationLength)) {
    errno = EINVAL;
    return -1;
  }
  switch (cdb.pageCode) {
    case SCSI::logSensePages::readErrors:
      return logSenseReadErrorsPage(sgio_h);
    case SCSI::logSensePages::writeErrors:
      return logSenseWriteErrorsPage(sgio_h);
    case SCSI::logSensePages::nonMediumErrors:
      return logSenseNonMediumErrorsPage(sgio_h);
    case SCSI::logSensePages::sequentialAccessDevicePage:
      return logSenseSequentialAccessDevicePage(sgio_h);
    case SCSI::logSensePages::dataCompression32h: // SCSI::logSensePages::driveWriteErrors
      return logSenseDataCompression32h(sgio_h);
    case SCSI::logSensePages::blockBytesTransferred:
      return logSenseBlockBytesTransferred(sgio_h);
    case SCSI::logSensePages::tapeAlert:
      return logSenseTapeAlerts(sgio_h);
  }
  errno = EINVAL;
  return -1;
}

int System::stOracleT10000Device::ioctlLogSense(sg_io_hdr_t * sgio_h) {
  int superRes = System::stDeviceFile::ioctlLogSense(sgio_h);
  /*
   * The following checks have to be redone because we don't know why the super
   * function might have failed. It may be because of the checks, it may be because
   * it did not find any page, it may be because the specific ioctl failed.
   */
  if (superRes == -1) {
    if (SG_DXFER_FROM_DEV != sgio_h->dxfer_direction) {
      errno = EINVAL;
      return -1;
    }
    SCSI::Structures::logSenseCDB_t &cdb =
      *(SCSI::Structures::logSenseCDB_t *) sgio_h->cmdp;
    if (1 != cdb.PC || 0 == SCSI::Structures::toU16(cdb.allocationLength)) {
      errno = EINVAL;
      return -1;
    }
    /*
     * Here we are parsing only Oracle T10000 specific pages.
     */
    switch (cdb.pageCode) {
      case SCSI::logSensePages::vendorUniqueDriveStatistics:
        return logSenseVendorUniqueDriveStatisticsPage(sgio_h);
    }
    errno = EINVAL;
    return -1;
  }
  else
    return superRes;
}

int System::stIBM3592DeviceFile::ioctlLogSense(sg_io_hdr_t * sgio_h) {
  int superRes = System::stDeviceFile::ioctlLogSense(sgio_h);
  /*
   * The following checks have to be redone because we don't know why the super
   * function might have failed. It may be because of the checks, it may be because
   * it did not find any page, it may be because the specific ioctl failed.
   */

  /*
   * In this function, we deliberately don't check the result of the parent function's
   * output because we have a conflict between the LogSense codes (dataCompression32h and
   * driveWriteErrors). So, even if the logSenseDataCompression32h() gets executed, we still want to execute
   * the logSenseDriveWriteErrorsPage() function.
   * Still, we need to **account for the redundant ioctl call** in the assertions.
   */

  if (SG_DXFER_FROM_DEV != sgio_h->dxfer_direction) {
    errno = EINVAL;
    return -1;
  }
  SCSI::Structures::logSenseCDB_t &cdb =
    *(SCSI::Structures::logSenseCDB_t *) sgio_h->cmdp;
  if (1 != cdb.PC || 0 == SCSI::Structures::toU16(cdb.allocationLength)) {
    errno = EINVAL;
    return -1;
  }
  /*
   * Here we are parsing only IBM 3592 specific pages.
   */
  switch (cdb.pageCode) {
    case SCSI::logSensePages::volumeStatistics:
      return logSenseVolumeStatisticsPage(sgio_h);
    case SCSI::logSensePages::driveWriteErrors:
      return logSenseDriveWriteErrorsPage(sgio_h);
    case SCSI::logSensePages::driveReadForwardErrors:
      return logSenseDriveReadForwardErrorsPage(sgio_h);
    case SCSI::logSensePages::driveReadBackwardErrors:
      return logSenseDriveReadBackwardErrorsPage(sgio_h);
    case SCSI::logSensePages::performanceCharacteristics:
      return logSensePerformanceCharacteristicsPage(sgio_h);
  }
  if (superRes == -1) {
    errno = EINVAL;
    return -1;
  }
  else
    return superRes;
}

int System::stOracleT10000Device::logSenseReadErrorsPage(sg_io_hdr_t * sgio_h) {
  unsigned char output[] = {
    0x03, 0x00, 0x00, 0x3c, 0x00, 0x00, 0x74, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x74, 0x04, // 0x00
    0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x74, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x74, 0x04, // 0x10
    0x00, 0x00, 0x00, 0x02, 0x00, 0x04, 0x74, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x74, 0x08, // 0x20
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x06, 0x74, 0x04, 0x00, 0x00, 0x00, 0x01  // 0x30
  };
  if (sizeof (output) > sgio_h->dxfer_len) {
    errno = EINVAL;
    return -1;
  }
  memcpy(sgio_h->dxferp, output, sizeof (output));
  return 0;
}

int System::stIBM3592DeviceFile::logSenseReadErrorsPage(sg_io_hdr_t * sgio_h) {
  unsigned char output[] = {
    0x03, 0x00, 0x00, 0x1c, 0x00, 0x02, 0x60, 0x02, 0x00, 0x00, 0x00, 0x03, 0x60, 0x02, 0x00, 0x02, // 0x00
    0x00, 0x05, 0x60, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x06, 0x60, 0x02, 0x00, 0x01  // 0x10
  };
  if (sizeof (output) > sgio_h->dxfer_len) {
    errno = EINVAL;
    return -1;
  }
  memcpy(sgio_h->dxferp, output, sizeof (output));
  return 0;
}

int System::stOracleT10000Device::logSenseWriteErrorsPage(sg_io_hdr_t * sgio_h) {
  unsigned char output[] = {
    0x02, 0x00, 0x00, 0x3c, 0x00, 0x00, 0x74, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x74, 0x04, // 0x00
    0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x74, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x74, 0x04, // 0x10
    0x00, 0x00, 0x00, 0x02, 0x00, 0x04, 0x74, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x74, 0x08, // 0x20
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x06, 0x74, 0x04, 0x00, 0x00, 0x00, 0x01  // 0x30
  };
  if (sizeof (output) > sgio_h->dxfer_len) {
    errno = EINVAL;
    return -1;
  }
  memcpy(sgio_h->dxferp, output, sizeof (output));
  return 0;
}

int System::stIBM3592DeviceFile::logSenseWriteErrorsPage(sg_io_hdr_t * sgio_h) {
  unsigned char output[] = {
    0x02, 0x00, 0x00, 0x1c, 0x00, 0x02, 0x60, 0x02, 0x00, 0x00, 0x00, 0x03, 0x60, 0x02, 0x00, 0x02, // 0x00
    0x00, 0x05, 0x60, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x06, 0x60, 0x02, 0x00, 0x01  // 0x10
  };
  if (sizeof (output) > sgio_h->dxfer_len) {
    errno = EINVAL;
    return -1;
  }
  memcpy(sgio_h->dxferp, output, sizeof (output));
  return 0;
}

int System::stOracleT10000Device::logSenseNonMediumErrorsPage(sg_io_hdr_t * sgio_h) {
  unsigned char output[] = {
    0x06, 0x00, 0x00, 0x08, 0x00, 0x00, 0x60, 0x04, 0x00, 0x00, 0x00, 0x03 // 0x00
  };
  if (sizeof (output) > sgio_h->dxfer_len) {
    errno = EINVAL;
    return -1;
  }
  memcpy(sgio_h->dxferp, output, sizeof (output));
  return 0;
}

int System::stIBM3592DeviceFile::logSenseNonMediumErrorsPage(sg_io_hdr_t * sgio_h) {
  unsigned char output[] = {
    0x06, 0x00, 0x00, 0x08, 0x00, 0x00, 0x74, 0x04,  0x00, 0x00, 0x00, 0x03 // 0x00
  };
  if (sizeof (output) > sgio_h->dxfer_len) {
    errno = EINVAL;
    return -1;
  }
  memcpy(sgio_h->dxferp, output, sizeof (output));
  return 0;
}

int System::stIBM3592DeviceFile::logSenseVolumeStatisticsPage(sg_io_hdr_t * sgio_h) {
  unsigned char output[] = {
    0x57, 0x01, 0x02, 0x4c, 0x00, 0x00, 0x43, 0x01, 0x01, 0x00, 0x01, 0x43, 0x04, 0x01, 0x20, 0x30, //0x00
    0x62, 0x00, 0x02, 0x43, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0xce, 0xf8, 0x00, 0x03, 0x43, //0x10
    0x04, 0x01, 0x02, 0x03, 0x01, 0x00, 0x04, 0x43, 0x02, 0x00, 0x01, 0x00, 0x05, 0x43, 0x02, 0x00, //0x20
    0x04, 0x00, 0x06, 0x43, 0x02, 0x00, 0x00, 0x00, 0x07, 0x43, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, //0x30
    0x16, 0x98, 0x68, 0x00, 0x08, 0x43, 0x04, 0x01, 0x01, 0x01, 0xd7, 0x00, 0x09, 0x43, 0x02, 0x02, //0x40
    0x02, 0x00, 0x0c, 0x43, 0x02, 0x00, 0x00, 0x00, 0x0d, 0x43, 0x02, 0x00, 0x00, 0x00, 0x0e, 0x43, //0x50
    0x04, 0x00, 0x00, 0x00, 0x05, 0x00, 0x0f, 0x43, 0x04, 0x00, 0x00, 0x00, 0x05, 0x00, 0x10, 0x43, //0x60
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x59, 0x98, 0x2b, 0x00, 0x11, 0x43, 0x08, 0x00, 0x00, 0x00, //0x70
    0x00, 0x00, 0x71, 0xad, 0x59, 0x00, 0x12, 0x43, 0x02, 0x00, 0x00, 0x00, 0x13, 0x43, 0x02, 0x00, //0x80
    0xc3, 0x00, 0x14, 0x43, 0x06, 0x00, 0x00, 0x00, 0x00, 0x7a, 0x82, 0x00, 0x15, 0x43, 0x06, 0x00, //0x90
    0x00, 0x00, 0x00, 0x2c, 0x2f, 0x00, 0x16, 0x43, 0x04, 0x00, 0x98, 0x96, 0x80, 0x00, 0x17, 0x43, //0xa0
    0x04, 0x00, 0x00, 0x00, 0x05, 0x00, 0x40, 0x41, 0x20, 0x31, 0x34, 0x37, 0x45, 0x42, 0x30, 0x32, //0xb0
    0x35, 0x36, 0x35, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, //0xc0
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x41, 0x41, 0x08, 0x32, 0x30, 0x32, //0xd0
    0x30, 0x32, 0x30, 0x32, 0x30, 0x00, 0x42, 0x41, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, //0xe0
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, //0xf0
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x43, 0x41, 0x08, 0x49, 0x42, 0x4d, //0x100
    0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x44, 0x41, 0x04, 0x55, 0x31, 0x30, 0x37, 0x00, 0x45, 0x41, //0x110
    0x08, 0x33, 0x35, 0x39, 0x32, 0x4a, 0x44, 0x47, 0x35, 0x00, 0x46, 0x41, 0x08, 0x32, 0x30, 0x31, //0x120
    0x34, 0x30, 0x38, 0x31, 0x35, 0x00, 0x80, 0x43, 0x01, 0x00, 0x00, 0x81, 0x43, 0x01, 0x00, 0x00, //0x130
    0x82, 0x43, 0x01, 0x00, 0x01, 0x00, 0x43, 0x04, 0x00, 0x00, 0x00, 0x2e, 0x01, 0x01, 0x43, 0x04, //0x140
    0x02, 0x03, 0x07, 0x24, 0x01, 0x02, 0x43, 0x04, 0x01, 0x02, 0x01, 0x16, 0x02, 0x00, 0x43, 0x0a, //0x150
    0x09, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x02, 0x01, 0x43, 0x0a, 0x09, 0x00, //0x160
    0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x02, 0x02, 0x43, 0x08, 0x07, 0x00, 0x00, 0x00, //0x170
    0x00, 0x98, 0x96, 0x80, 0x02, 0x03, 0x43, 0x08, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, //0x180
    0x02, 0x04, 0x43, 0x08, 0x07, 0x00, 0x00, 0x00, 0x00, 0x98, 0x96, 0x79, 0x03, 0x00, 0x43, 0xb0, //0x190
    0x2c, 0x00, 0x00, 0x00, 0x49, 0x42, 0x4d, 0x20, 0x20, 0x20, 0x20, 0x20, 0x30, 0x30, 0x30, 0x37, //0x1a0
    0x38, 0x44, 0x38, 0x34, 0x39, 0x41, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, //0x1b0
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x2c, 0x00, 0x00, 0x01, //0x1c0
    0x49, 0x42, 0x4d, 0x20, 0x20, 0x20, 0x20, 0x20, 0x30, 0x30, 0x30, 0x37, 0x38, 0x44, 0x38, 0x34, //0x1d0
    0x39, 0x41, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, //0x1e0
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x2c, 0x00, 0x00, 0x02, 0x49, 0x42, 0x4d, 0x20, //0x1f0
    0x20, 0x20, 0x20, 0x20, 0x30, 0x30, 0x30, 0x37, 0x38, 0x44, 0x38, 0x34, 0x39, 0x41, 0x20, 0x20, //0x200
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, //0x210
    0x20, 0x20, 0x20, 0x20, 0x2c, 0x00, 0x00, 0x03, 0x49, 0x42, 0x4d, 0x20, 0x20, 0x20, 0x20, 0x20, //0x220
    0x30, 0x30, 0x30, 0x37, 0x38, 0x44, 0x38, 0x34, 0x39, 0x41, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, //0x230
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20  //0x240
  };
  if (sizeof (output) > sgio_h->dxfer_len) {
    errno = EINVAL;
    return -1;
  }
  memcpy(sgio_h->dxferp, output, sizeof (output));
  return 0;
}

int System::stOracleT10000Device::logSenseVendorUniqueDriveStatisticsPage(sg_io_hdr_t * sgio_h) {
  unsigned char output[] = {
    0x3d, 0x00, 0x0c, 0x08, 0x01, 0x00, 0x74, 0x04, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x74, 0x04,  // 0x00 
    0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x74, 0x04, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x74, 0x04,  // 0x10 
    0x00, 0x00, 0x00, 0x00, 0x01, 0x04, 0x74, 0x04, 0x01, 0x02, 0x03, 0x04, 0x01, 0x05, 0x74, 0x04,  // 0x20
    0x00, 0x01, 0x01, 0x02, 0x01, 0x06, 0x74, 0x04, 0x01, 0x01, 0x02, 0x02, 0x01, 0x07, 0x74, 0x04,  // 0x30
    0x00, 0x00, 0x02, 0x13, 0x01, 0x08, 0x74, 0x04, 0x00, 0x02, 0x1a, 0x0f, 0x01, 0x09, 0x74, 0x04,  // 0x40
    0x00, 0x00, 0x00, 0x00, 0x01, 0x0a, 0x74, 0x04, 0x00, 0x00, 0x00, 0x00, 0x01, 0x0b, 0x74, 0x04,  // 0x50 
    0x00, 0x00, 0x00, 0x00, 0x01, 0x0c, 0x74, 0x04, 0x00, 0x00, 0x00, 0x00, 0x01, 0x0d, 0x74, 0x04,  // 0x60 
    0x00, 0x00, 0x00, 0x00, 0x01, 0x0e, 0x74, 0x04, 0x00, 0x00, 0x01, 0x9a, 0x01, 0x10, 0x74, 0x04,  // 0x70 
    0x00, 0x00, 0x00, 0x00, 0x01, 0x11, 0x74, 0x04, 0x00, 0x00, 0x00, 0x00, 0x01, 0x12, 0x74, 0x04,  // 0x80 
    0x00, 0x00, 0xff, 0xff, 0x01, 0x14, 0x74, 0x04, 0x00, 0x00, 0x00, 0x00, 0x01, 0x15, 0x74, 0x04,  // 0x90
    0x00, 0x00, 0x00, 0x00, 0x01, 0x16, 0x74, 0x04, 0x00, 0x00, 0x00, 0x65, 0x01, 0x17, 0x74, 0x04,  // 0xa0 
    0x00, 0x00, 0x00, 0x01, 0x01, 0x18, 0x74, 0x04, 0x00, 0x00, 0x00, 0x00, 0x01, 0x20, 0x74, 0x04,  // 0xb0 
    0x00, 0x00, 0x00, 0x00, 0x01, 0x21, 0x74, 0x04, 0x00, 0x00, 0x00, 0x00, 0x01, 0x22, 0x74, 0x04,  // 0xc0 
    0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x74, 0x04, 0x00, 0x00, 0x00, 0x00, 0x02, 0x01, 0x74, 0x04,  // 0xd0 
    0x00, 0x00, 0x00, 0x00, 0x02, 0x02, 0x74, 0x04, 0x00, 0x00, 0x00, 0x00, 0x02, 0x03, 0x74, 0x04,  // 0xe0 
    0x01, 0x00, 0x00, 0x01, 0x02, 0x04, 0x74, 0x04, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x74, 0x08,  // 0xf0
    0x00, 0x00, 0x00, 0x00, 0x0f, 0xa8, 0x03, 0x70, 0x03, 0x01, 0x74, 0x08, 0x00, 0x00, 0x00, 0x00,  // 0x100
    0x0f, 0xb0, 0x54, 0x58, 0x03, 0x02, 0x74, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 0x110
    0x03, 0x03, 0x74, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x04, 0x74, 0x08,  // 0x120
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xf9, 0x03, 0x05, 0x74, 0x08, 0x00, 0x00, 0x00, 0x00,  // 0x130
    0x00, 0x00, 0x00, 0x00, 0x03, 0x06, 0x74, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xf9,  // 0x140
    0x03, 0x07, 0x74, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x08, 0x74, 0x08,  // 0x150
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x03, 0x09, 0x74, 0x08, 0x00, 0x00, 0x00, 0x00,  // 0x160
    0x00, 0x00, 0x00, 0x00, 0x03, 0x0b, 0x74, 0x04, 0x00, 0x00, 0x00, 0x07, 0x03, 0x0c, 0x74, 0x08,  // 0x170
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x0d, 0x74, 0x08, 0x00, 0x00, 0x00, 0x00,  // 0x180
    0x00, 0x00, 0x0f, 0x8d, 0x03, 0x0e, 0x74, 0x04, 0x00, 0x00, 0x00, 0x00, 0x03, 0x0f, 0x74, 0x08,  // 0x190
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4d, 0x03, 0x10, 0x74, 0x08, 0x00, 0x00, 0x00, 0x00,  // 0x1a0
    0x00, 0x00, 0x52, 0xa0, 0x03, 0x11, 0x74, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x37, 0xf1,  // 0x1b0
    0x03, 0x12, 0x74, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x81, 0x7f, 0x03, 0x13, 0x74, 0x08,  // 0x1c0
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x14, 0x74, 0x08, 0x00, 0x00, 0x00, 0x00,  // 0x1d0
    0x00, 0x00, 0x00, 0x00, 0x03, 0x15, 0x74, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 0x1e0
    0x03, 0x16, 0x74, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x74, 0x04,  // 0x1f0
    0x00, 0x00, 0x03, 0xde, 0x04, 0x01, 0x74, 0x04, 0x00, 0x00, 0x36, 0xaf, 0x04, 0x02, 0x74, 0x04,  // 0x200
    0x00, 0x00, 0x3e, 0x80, 0x04, 0x03, 0x74, 0x04, 0x00, 0x00, 0x00, 0x00, 0x04, 0x04, 0x74, 0x04,  // 0x210
    0x00, 0x00, 0x00, 0x00, 0x04, 0x07, 0x74, 0x04, 0x00, 0x00, 0x03, 0xe8, 0x04, 0x08, 0x74, 0x04,  // 0x220
    0x00, 0x00, 0x00, 0x04, 0x10, 0x00, 0x74, 0x40, 0x00, 0x00, 0x01, 0x63, 0x00, 0x00, 0x00, 0x05,  // 0x230
    0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 0x240
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 0x250
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 0x260
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x00, 0x74, 0x10, 0x00, 0x00, 0x53, 0x65,  // 0x270
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x01, 0x74, 0x10,  // 0x280
    0x00, 0x00, 0x53, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 0x290
    0x12, 0x00, 0x74, 0x20, 0x00, 0x00, 0x53, 0x57, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,  // 0x2a0
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c,  // 0x2b0
    0x00, 0x00, 0x00, 0x00, 0x12, 0x01, 0x74, 0x20, 0x00, 0x00, 0x53, 0x58, 0x00, 0x00, 0x00, 0x00,  // 0x2c0
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,  // 0x2d0
    0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x12, 0x02, 0x74, 0x20, 0x00, 0x00, 0x53, 0x65,  // 0x2e0
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 0x2f0
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12, 0x03, 0x74, 0x20,  // 0x300
    0x00, 0x00, 0x53, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 0x310
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 0x320
    0x13, 0x10, 0x74, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 0x330
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 0x340
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 0x350
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 0x360
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 0x370
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 0x380
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 0x390
    0x00, 0x00, 0x00, 0x0d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x2d, 0x00, 0x00, 0x00, 0x00,  // 0x3a0
    0x00, 0x00, 0x25, 0x99, 0x13, 0x11, 0x74, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x25, 0x0b,  // 0x3b0
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x69, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1c,  // 0x3c0
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 0x3d0
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 0x3e0
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 0x3f0
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 0x400
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 0x410
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 0x420
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0x20, 0x74, 0x80, 0x00, 0x00, 0x00, 0x00,  // 0x430
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 0x440
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 0x450
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 0x460
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 0x470
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 0x480
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 0x490
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00,  // 0x4a0
    0x00, 0x00, 0x03, 0x74, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x26, 0xd5, 0x13, 0x21, 0x74, 0x80,  // 0x4b0
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0xe4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x24,  // 0x4c0
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 0x4d0
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 0x4e0
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 0x4f0
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 0x500
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 0x510
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 0x520
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 0x530
    0x14, 0x00, 0x74, 0x80, 0x00, 0x00, 0x01, 0x6c, 0x00, 0x00, 0x01, 0x6c, 0x00, 0x00, 0x01, 0x6c,  // 0x540
    0x00, 0x00, 0x01, 0x6b, 0x00, 0x00, 0x01, 0x6b, 0x00, 0x00, 0x01, 0x6c, 0x00, 0x00, 0x01, 0x6c,  // 0x550
    0x00, 0x00, 0x01, 0x6b, 0x00, 0x00, 0x01, 0x6c, 0x00, 0x00, 0x01, 0x6c, 0x00, 0x00, 0x01, 0x6c,  // 0x560
    0x00, 0x00, 0x01, 0x6b, 0x00, 0x00, 0x01, 0x6c, 0x00, 0x00, 0x01, 0x6c, 0x00, 0x00, 0x01, 0x6c,  // 0x570
    0x00, 0x00, 0x01, 0x6c, 0x00, 0x00, 0x01, 0x6c, 0x00, 0x00, 0x01, 0x6c, 0x00, 0x00, 0x01, 0x6c,  // 0x580
    0x00, 0x00, 0x01, 0x6c, 0x00, 0x00, 0x01, 0x6c, 0x00, 0x00, 0x01, 0x6c, 0x00, 0x00, 0x01, 0x6a,  // 0x590
    0x00, 0x00, 0x01, 0x6c, 0x00, 0x00, 0x01, 0x6c, 0x00, 0x00, 0x01, 0x6b, 0x00, 0x00, 0x01, 0x6c,  // 0x5a0
    0x00, 0x00, 0x01, 0x6c, 0x00, 0x00, 0x01, 0x6c, 0x00, 0x00, 0x01, 0x6c, 0x00, 0x00, 0x01, 0x6c,  // 0x5b0
    0x00, 0x00, 0x01, 0x6c, 0x14, 0x02, 0x74, 0x80, 0x00, 0x00, 0x22, 0x01, 0x00, 0x00, 0x0c, 0xb6,  // 0x5c0
    0x00, 0x00, 0x1a, 0x70, 0x00, 0x00, 0x1c, 0xf7, 0x00, 0x00, 0x1b, 0x11, 0x00, 0x00, 0x13, 0x98,  // 0x5d0
    0x00, 0x00, 0x22, 0x21, 0x00, 0x00, 0x09, 0xea, 0x00, 0x00, 0x0d, 0xe5, 0x00, 0x00, 0x0c, 0x4e,  // 0x5e0
    0x00, 0x00, 0x0b, 0x07, 0x00, 0x00, 0x14, 0x07, 0x00, 0x00, 0x21, 0xd9, 0x00, 0x00, 0x17, 0x3d,  // 0x5f0
    0x00, 0x00, 0x1a, 0x70, 0x00, 0x00, 0x16, 0x2b, 0x00, 0x00, 0x16, 0xb2, 0x00, 0x00, 0x28, 0xc7,  // 0x600
    0x00, 0x00, 0x12, 0x8a, 0x00, 0x00, 0x18, 0x07, 0x00, 0x00, 0x14, 0x66, 0x00, 0x00, 0x18, 0x8a,  // 0x610
    0x00, 0x00, 0x3d, 0xee, 0x00, 0x00, 0x1e, 0x8d, 0x00, 0x00, 0x0f, 0xf5, 0x00, 0x00, 0x1d, 0xf6,  // 0x620
    0x00, 0x00, 0x11, 0xb1, 0x00, 0x00, 0x11, 0x68, 0x00, 0x00, 0x2d, 0xb4, 0x00, 0x00, 0x18, 0xd3,  // 0x630
    0x00, 0x00, 0x1d, 0x7f, 0x00, 0x00, 0x1d, 0x4e, 0x14, 0x04, 0x74, 0x80, 0x00, 0x00, 0x00, 0x00,  // 0x640
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 0x650
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 0x660
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 0x670
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 0x680
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 0x690
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 0x6a0
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 0x6b0
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x05, 0x74, 0x80,  // 0x6c0
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 0x6d0
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 0x6e0
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 0x6f0
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 0x700
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 0x710
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 0x720
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 0x730
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 0x740
    0x14, 0x06, 0x74, 0x80, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x0e,  // 0x750
    0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x0d,  // 0x760
    0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x01,  // 0x770
    0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x0a,  // 0x780
    0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x02,  // 0x790
    0x00, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x5e,  // 0x7a0
    0x00, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x00, 0x00, 0x04,  // 0x7b0
    0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x0a,  // 0x7c0
    0x00, 0x00, 0x00, 0x08, 0x15, 0x00, 0x74, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 0x7d0
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 0x7e0
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 0x7f0
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 0x800
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 0x810
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 0x820
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 0x830
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 0x840
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x01, 0x74, 0x80, 0x00, 0x00, 0x01, 0x42,  // 0x850
    0x00, 0x00, 0x02, 0x1d, 0x00, 0x00, 0x01, 0x72, 0x00, 0x00, 0x01, 0x64, 0x00, 0x00, 0x01, 0x74,  // 0x860
    0x00, 0x00, 0x01, 0xae, 0x00, 0x00, 0x01, 0x53, 0x00, 0x00, 0x02, 0x3c, 0x00, 0x00, 0x01, 0xff,  // 0x870
    0x00, 0x00, 0x02, 0x26, 0x00, 0x00, 0x02, 0x17, 0x00, 0x00, 0x01, 0xb8, 0x00, 0x00, 0x01, 0x35,  // 0x880
    0x00, 0x00, 0x01, 0x9b, 0x00, 0x00, 0x01, 0x77, 0x00, 0x00, 0x01, 0xaf, 0x00, 0x00, 0x01, 0xa3,  // 0x890
    0x00, 0x00, 0x01, 0x17, 0x00, 0x00, 0x01, 0xc5, 0x00, 0x00, 0x01, 0x8f, 0x00, 0x00, 0x01, 0xb4,  // 0x8a0
    0x00, 0x00, 0x01, 0x7d, 0x00, 0x00, 0x00, 0xb3, 0x00, 0x00, 0x01, 0x6b, 0x00, 0x00, 0x01, 0xe7,  // 0x8b0
    0x00, 0x00, 0x01, 0x65, 0x00, 0x00, 0x01, 0xc6, 0x00, 0x00, 0x01, 0xca, 0x00, 0x00, 0x01, 0x0a,  // 0x8c0
    0x00, 0x00, 0x01, 0x85, 0x00, 0x00, 0x01, 0x54, 0x00, 0x00, 0x01, 0x66, 0x15, 0x02, 0x74, 0x80,  // 0x8d0
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 0x8e0
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 0x8f0
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 0x900
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 0x910
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 0x920
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 0x930
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 0x940
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 0x950
    0x15, 0x03, 0x74, 0x80, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00,  // 0x960
    0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00,  // 0x970
    0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00,  // 0x980
    0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00,  // 0x990
    0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00,  // 0x9a0
    0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00,  // 0x9b0
    0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00,  // 0x9c0
    0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00,  // 0x9d0
    0x00, 0x00, 0x04, 0x00, 0x15, 0x04, 0x74, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 0x9e0
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 0x9f0
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 0xa00
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 0xa10
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 0xa20
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 0xa30
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 0xa40
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 0xa50
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x05, 0x74, 0x80, 0x00, 0x00, 0x00, 0x00,  // 0xa60
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 0xa70
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 0xa80
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 0xa90
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 0xaa0
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 0xab0
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 0xac0
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // 0xad0
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x05, 0x74, 0x04,  // 0xae0
    0x00, 0x00, 0x00, 0x00, 0x24, 0x06, 0x74, 0x04, 0x00, 0x00, 0x00, 0x00, 0x24, 0x07, 0x74, 0x04,  // 0xaf0
    0x00, 0x00, 0x4d, 0x5a, 0x24, 0x08, 0x74, 0x04, 0x00, 0x00, 0x4d, 0x5a, 0x25, 0x00, 0x74, 0x04,  // 0xb00
    0x28, 0x00, 0x28, 0x28, 0x25, 0x01, 0x74, 0x04, 0x28, 0x00, 0x28, 0x28, 0x25, 0x02, 0x74, 0x04,  // 0xb10
    0x00, 0x00, 0x00, 0x00, 0x25, 0x03, 0x74, 0x04, 0x00, 0x00, 0x00, 0x04, 0x25, 0x04, 0x74, 0x04,  // 0xb20
    0x00, 0x00, 0x00, 0x00, 0x25, 0x05, 0x74, 0x04, 0x00, 0x00, 0x00, 0x00, 0x25, 0x06, 0x74, 0x04,  // 0xb30
    0x00, 0x00, 0x00, 0x00, 0x25, 0x07, 0x74, 0x04, 0x00, 0x00, 0x00, 0x00, 0x25, 0x08, 0x74, 0x04,  // 0xb40
    0x00, 0x00, 0x00, 0x00, 0x25, 0x09, 0x74, 0x04, 0x00, 0x00, 0x00, 0x00, 0x25, 0x0a, 0x74, 0x04,  // 0xb50
    0x00, 0x01, 0x1b, 0x15, 0x25, 0x0b, 0x74, 0x04, 0x00, 0x00, 0x00, 0x00, 0x25, 0x0c, 0x74, 0x04,  // 0xb60
    0x00, 0x00, 0x00, 0x00, 0x25, 0x0d, 0x74, 0x04, 0x00, 0x00, 0x00, 0x00, 0x25, 0x0e, 0x74, 0x04,  // 0xb70
    0x00, 0x00, 0x00, 0x00, 0x25, 0x0f, 0x74, 0x04, 0x00, 0x00, 0x00, 0x00, 0x25, 0x10, 0x74, 0x04,  // 0xb80
    0x00, 0x00, 0x00, 0x00, 0x25, 0x11, 0x74, 0x04, 0x00, 0x00, 0x00, 0x00, 0x25, 0x12, 0x74, 0x04,  // 0xb90
    0x00, 0x00, 0x00, 0x00, 0x25, 0x13, 0x74, 0x04, 0x00, 0x00, 0x00, 0x00, 0x25, 0x14, 0x74, 0x04,  // 0xba0
    0x00, 0x00, 0x00, 0x00, 0x25, 0x15, 0x74, 0x04, 0x00, 0x00, 0x00, 0x00, 0x25, 0x16, 0x74, 0x04,  // 0xbb0
    0x00, 0x00, 0x00, 0x00, 0x25, 0x17, 0x74, 0x04, 0x00, 0x00, 0x00, 0x00, 0x25, 0x18, 0x74, 0x04,  // 0xbc0
    0x00, 0x00, 0x00, 0x00, 0x25, 0x19, 0x74, 0x04, 0x00, 0x00, 0x00, 0x00, 0x25, 0x1a, 0x74, 0x04,  // 0xbd0
    0x00, 0x00, 0x00, 0x00, 0x25, 0x1b, 0x74, 0x04, 0x00, 0x00, 0x00, 0x00, 0x25, 0x1c, 0x74, 0x04,  // 0xbe0
    0x00, 0x00, 0x00, 0x00, 0x25, 0x1d, 0x74, 0x04, 0x00, 0x00, 0x00, 0x00, 0x25, 0x1e, 0x74, 0x04,  // 0xbf0
    0x00, 0x00, 0x00, 0x00, 0x25, 0x1f, 0x74, 0x04, 0x00, 0x00, 0x00, 0x00   // 0xc00
  };
  if (sizeof (output) > sgio_h->dxfer_len) {
    errno = EINVAL;
    return -1;
  }
  memcpy(sgio_h->dxferp, output, sizeof (output));
  return 0;
}

int System::stIBM3592DeviceFile::logSenseDriveWriteErrorsPage(sg_io_hdr_t * sgio_h) {
  unsigned char output[] = {
    0x32, 0x00, 0x00, 0x6c, 0x00, 0x00, 0x60, 0x02, 0x00, 0x00, 0x00, 0x01, 0x60, 0x02, 0x01, 0x01, // 0x00
    0x00, 0x02, 0x60, 0x02, 0x01, 0x02, 0x00, 0x03, 0x60, 0x02, 0x00, 0x00, 0x00, 0x04, 0x60, 0x02, // 0x10
    0x00, 0x00, 0x00, 0x05, 0x60, 0x02, 0x00, 0x00, 0x00, 0x06, 0x60, 0x02, 0x00, 0xac, 0x00, 0x07, // 0x20
    0x60, 0x02, 0x01, 0x22, 0x00, 0x08, 0x60, 0x02, 0x01, 0x32, 0x00, 0x09, 0x60, 0x02, 0x00, 0x00, // 0x30
    0x00, 0x0a, 0x60, 0x02, 0x00, 0x00, 0x00, 0x0b, 0x60, 0x02, 0x00, 0x00, 0x00, 0x0c, 0x60, 0x02, // 0x40
    0x00, 0x00, 0x00, 0x0d, 0x60, 0x02, 0x00, 0x00, 0x00, 0x0e, 0x60, 0x02, 0x00, 0x00, 0x00, 0x0f, // 0x50
    0x60, 0x02, 0x00, 0x00, 0x00, 0x10, 0x60, 0x02, 0x00, 0x00, 0x00, 0x11, 0x60, 0x02, 0x00, 0x00  // 0x60
  };

  if (sizeof (output) > sgio_h->dxfer_len) {
    errno = EINVAL;
    return -1;
  }
  memcpy(sgio_h->dxferp, output, sizeof (output));
  return 0;
}

int System::stIBM3592DeviceFile::logSenseDriveReadForwardErrorsPage(sg_io_hdr_t * sgio_h) {
  unsigned char output[] = {
    0x34, 0x00, 0x00, 0xba, 0x00, 0x00, 0x60, 0x02, 0x00, 0x00, 0x00, 0x01, 0x60, 0x02, 0x01, 0x01,  //0x00
    0x00, 0x02, 0x60, 0x02, 0x00, 0xff, 0x00, 0x03, 0x60, 0x02, 0x00, 0x00, 0x00, 0x04, 0x60, 0x02,  //0x10
    0x00, 0x00, 0x00, 0x05, 0x60, 0x02, 0x00, 0x00, 0x00, 0x06, 0x60, 0x02, 0x01, 0x01, 0x00, 0x07,  //0x20
    0x60, 0x02, 0x00, 0xcf, 0x00, 0x08, 0x60, 0x02, 0x00, 0x00, 0x00, 0x09, 0x60, 0x02, 0x00, 0x00,  //0x30
    0x00, 0x0a, 0x60, 0x02, 0x00, 0x00, 0x00, 0x0b, 0x60, 0x02, 0x00, 0x00, 0x00, 0x0c, 0x60, 0x02,  //0x40
    0x00, 0x00, 0x00, 0x0d, 0x60, 0x02, 0x00, 0x00, 0x00, 0x0e, 0x60, 0x02, 0x00, 0x00, 0x00, 0x0f,  //0x50
    0x60, 0x02, 0x00, 0x00, 0x00, 0x10, 0x60, 0x02, 0x00, 0x00, 0x00, 0x11, 0x60, 0x02, 0x00, 0x00,  //0x60
    0x00, 0x12, 0x60, 0x02, 0x00, 0x00, 0x00, 0x13, 0x60, 0x02, 0x00, 0x00, 0x00, 0x14, 0x60, 0x02,  //0x70
    0x00, 0x00, 0x00, 0x15, 0x60, 0x02, 0x01, 0x11, 0x00, 0x16, 0x60, 0x02, 0x00, 0x00, 0x00, 0x17,  //0x80
    0x60, 0x02, 0x00, 0x00, 0x00, 0x18, 0x60, 0x02, 0x00, 0x00, 0x00, 0x19, 0x60, 0x02, 0x00, 0x00,  //0x90
    0x00, 0x1a, 0x60, 0x02, 0x00, 0x00, 0x00, 0x1b, 0x60, 0x02, 0x00, 0x00, 0x00, 0x1c, 0x60, 0x02,  //0xa0
    0x00, 0x00, 0x00, 0x1d, 0x60, 0x02, 0x00, 0x00, 0x00, 0x1e, 0x60, 0x02, 0x00, 0x00  //0xb0
  };
  if (sizeof (output) > sgio_h->dxfer_len) {
    errno = EINVAL;
    return -1;
  }
  memcpy(sgio_h->dxferp, output, sizeof (output));
  return 0;
}

int System::stIBM3592DeviceFile::logSenseDriveReadBackwardErrorsPage(sg_io_hdr_t * sgio_h) {
  unsigned char output[] = {
    0x36, 0x00, 0x00, 0xba, 0x00, 0x00, 0x60, 0x02, 0x00, 0x00, 0x00, 0x01, 0x60, 0x02, 0x01, 0x01,  //0x00
    0x00, 0x02, 0x60, 0x02, 0x00, 0xf2, 0x00, 0x03, 0x60, 0x02, 0x00, 0x00, 0x00, 0x04, 0x60, 0x02,  //0x10
    0x00, 0x00, 0x00, 0x05, 0x60, 0x02, 0x00, 0x00, 0x00, 0x06, 0x60, 0x02, 0x01, 0x02, 0x00, 0x07,  //0x20
    0x60, 0x02, 0x01, 0x00, 0x00, 0x08, 0x60, 0x02, 0x00, 0x00, 0x00, 0x09, 0x60, 0x02, 0x00, 0x00,  //0x30
    0x00, 0x0a, 0x60, 0x02, 0x00, 0x00, 0x00, 0x0b, 0x60, 0x02, 0x00, 0x00, 0x00, 0x0c, 0x60, 0x02,  //0x40
    0x00, 0x00, 0x00, 0x0d, 0x60, 0x02, 0x00, 0x00, 0x00, 0x0e, 0x60, 0x02, 0x00, 0x00, 0x00, 0x0f,  //0x50
    0x60, 0x02, 0x00, 0x00, 0x00, 0x10, 0x60, 0x02, 0x00, 0x00, 0x00, 0x11, 0x60, 0x02, 0x00, 0x00,  //0x60
    0x00, 0x12, 0x60, 0x02, 0x00, 0x00, 0x00, 0x13, 0x60, 0x02, 0x00, 0x00, 0x00, 0x14, 0x60, 0x02,  //0x70
    0x00, 0x00, 0x00, 0x15, 0x60, 0x02, 0x00, 0x00, 0x00, 0x16, 0x60, 0x02, 0x00, 0x00, 0x00, 0x17,  //0x80
    0x60, 0x02, 0x00, 0x00, 0x00, 0x18, 0x60, 0x02, 0x00, 0x00, 0x00, 0x19, 0x60, 0x02, 0x00, 0x00,  //0x90
    0x00, 0x1a, 0x60, 0x02, 0x00, 0x00, 0x00, 0x1b, 0x60, 0x02, 0x00, 0x00, 0x00, 0x1c, 0x60, 0x02,  //0xa0
    0x00, 0x00, 0x00, 0x1d, 0x60, 0x02, 0x00, 0x00, 0x00, 0x1e, 0x60, 0x02, 0x00, 0x00  //0xb0
  };
  if (sizeof (output) > sgio_h->dxfer_len) {
    errno = EINVAL;
    return -1;
  }
  memcpy(sgio_h->dxferp, output, sizeof (output));
  return 0;
}

int System::stIBM3592DeviceFile::logSensePerformanceCharacteristicsPage(sg_io_hdr_t * sgio_h) {
  SCSI::Structures::logSenseCDB_t* cdb = (SCSI::Structures::logSenseCDB_t*) (sgio_h->cmdp);
  unsigned char output_80[] = {
    0x77, 0x80, 0x00, 0x1e, 0x00, 0x00, 0x60, 0x01, 0x50, 0x00, 0x01, 0x60, 0x01, 0x50, 0x00, 0x10, // 0x00
    0x60, 0x01, 0x01, 0x00, 0x11, 0x60, 0x01, 0x50, 0x00, 0x12, 0x60, 0x01, 0x50, 0x00, 0x1a, 0x60, // 0x10
    0x01, 0x50  // 0x20
  };
  unsigned char output_91[] = {
    0x77, 0x91, 0x00, 0xd0, 0x01, 0x02, 0x60, 0x04, 0x00, 0x00, 0x05, 0x59, 0x02, 0x02, 0x60, 0x04, //0x00
    0x00, 0x00, 0x10, 0x4b, 0x03, 0x02, 0x60, 0x04, 0x00, 0x11, 0x34, 0x7d, 0x03, 0xd0, 0x60, 0x04, //0x10
    0x00, 0x60, 0x1a, 0xd3, 0x04, 0x02, 0x60, 0x04, 0x00, 0x0f, 0x7c, 0x0b, 0x04, 0xd0, 0x60, 0x04, //0x20
    0x00, 0x62, 0xf3, 0x75, 0x05, 0x02, 0x60, 0x04, 0x00, 0x02, 0xb1, 0x68, 0x05, 0xd4, 0x60, 0x04, //0x30
    0x00, 0x00, 0x05, 0x1b, 0x06, 0x02, 0x60, 0x04, 0x00, 0x20, 0x49, 0x13, 0x07, 0x02, 0x60, 0x04, //0x40
    0x00, 0x06, 0xa7, 0xe9, 0x08, 0x02, 0x60, 0x04, 0x00, 0x00, 0x72, 0xcf, 0x09, 0x02, 0x60, 0x04, //0x50
    0x00, 0x00, 0x00, 0x00, 0x0a, 0x02, 0x60, 0x04, 0x00, 0x00, 0x00, 0x2a, 0x0c, 0x02, 0x60, 0x04, //0x60
    0x00, 0x4d, 0xcb, 0x5c, 0x0c, 0x0e, 0x60, 0x04, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x12, 0x60, 0x04, //0x70
    0x00, 0x4d, 0xcb, 0x5c, 0x0c, 0x1e, 0x60, 0x04, 0x00, 0x00, 0x07, 0x03, 0x0c, 0x22, 0x60, 0x04, //0x80
    0x00, 0x00, 0x00, 0x00, 0x0c, 0x2e, 0x60, 0x04, 0x00, 0x00, 0x00, 0x00, 0x0c, 0xa2, 0x60, 0x04, //0x90
    0x00, 0x00, 0x22, 0x39, 0x0c, 0xae, 0x60, 0x04, 0x00, 0x00, 0x00, 0x00, 0x0d, 0x14, 0x60, 0x04, //0xa0
    0x00, 0x02, 0x23, 0xac, 0x0d, 0x24, 0x60, 0x04, 0x00, 0x00, 0x00, 0x00, 0x0d, 0xa4, 0x60, 0x04, //0xb0
    0x00, 0x00, 0x00, 0x00, 0x0d, 0xf0, 0x60, 0x04, 0x00, 0x00, 0x00, 0x00, 0x0d, 0xf1, 0x60, 0x04, //0xc0
    0x00, 0x00, 0x00, 0x00 //0xd0
  };

  unsigned char *output = 0;
  unsigned int output_size = 0;
  if(cdb->subPageCode == 0x80 || cdb->subPageCode == 0x40) {
    output = output_80;
    output_size = sizeof(output_80);
  }
  else if(cdb->subPageCode == 0x91 || cdb->subPageCode == 0x51) { ;
    output = output_91;
    output_size = sizeof(output_91);
  }
  if (output_size > sgio_h->dxfer_len) {
    errno = EINVAL;
    return -1;
  }
  memcpy(sgio_h->dxferp, output, output_size);
  return 0;
}









int System::stDeviceFile::logSenseSequentialAccessDevicePage(sg_io_hdr_t * sgio_h) {
  /**
   * This is a real reply from the enterprise T10000C STK drive. 
   * We only fill the testing values in the corresponding fields for the 
   * compression statistics. The replay1 is the replay with not empty
   * data and the replay2 is the replay with zero statistics.
   */
  unsigned char replay1[] = {
    0x0c, 0x00, 0x00, 0x40, 0x00, 0x00, 0x74, 0x08, 0xab, 0xcd, 0xef, 0x11, 0x22, 0x33, 0x44, 0x55, // 0x00
    0x00, 0x01, 0x74, 0x08, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x00, 0x02, 0x74, 0x08, // 0x10
    0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff, 0x11, 0x00, 0x03, 0x74, 0x08, 0x22, 0x33, 0x44, 0x55, // 0x20
    0x66, 0x77, 0x88, 0x99, 0x01, 0x00, 0x74, 0x04, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x74, 0x04, // 0x30 
    0x00, 0x00, 0x00, 0x00 // 0x40 
  };
  unsigned char replay2[] = {
    0x0c, 0x00, 0x00, 0x40, 0x00, 0x00, 0x74, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x00
    0x00, 0x01, 0x74, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x74, 0x08, // 0x10
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x74, 0x08, 0x00, 0x00, 0x00, 0x00, // 0x20
    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x74, 0x04, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x74, 0x04, // 0x30 
    0x00, 0x00, 0x00, 0x00 // 0x40 
  };

  if (sizeof (replay1) > sgio_h->dxfer_len) {
    errno = EINVAL;
    return -1;
  }
  if (clearCompressionStats) {
    memcpy(sgio_h->dxferp, replay2, sizeof (replay2));
  } else {
    memcpy(sgio_h->dxferp, replay1, sizeof (replay1));
  }
  return 0;
}

int System::stDeviceFile::logSenseDataCompression32h(sg_io_hdr_t * sgio_h) {
  /**
   * This is a real reply from the IBM ULTRIUM-TD5 LTO5 drive. 
   * We only fill the testing values in the corresponding fields for the 
   * compression statistics. The replay1 is the replay with not empty
   * data and the replay2 is the replay with zero statistics.
   */
  unsigned char replay1[] = {
    0x32, 0x00, 0x00, 0x4c, 0x00, 0x00, 0x40, 0x02, 0x00, 0x00, 0x00, 0x01, 0x40, 0x02, 0x00, 0x64, // 0x00
    0x00, 0x02, 0x40, 0x04, 0x11, 0x22, 0x33, 0x44, 0x00, 0x03, 0x40, 0x04, 0x55, 0x66, 0x77, 0x88, // 0x10
    0x00, 0x04, 0x40, 0x04, 0x99, 0xaa, 0xbb, 0xcc, 0x00, 0x05, 0x40, 0x04, 0xdd, 0xee, 0xff, 0x11, // 0x20
    0x00, 0x06, 0x40, 0x04, 0x22, 0x33, 0x44, 0x55, 0x00, 0x07, 0x40, 0x04, 0x66, 0x77, 0x88, 0x99, // 0x30
    0x00, 0x08, 0x40, 0x04, 0xaa, 0xbb, 0xcc, 0xdd, 0x00, 0x09, 0x40, 0x04, 0xee, 0xff, 0x11, 0x22  // 0x40
  };
  unsigned char replay2[] = {
    0x32, 0x00, 0x00, 0x4c, 0x00, 0x00, 0x40, 0x02, 0x00, 0x00, 0x00, 0x01, 0x40, 0x02, 0x00, 0x64, // 0x00
    0x00, 0x02, 0x40, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x40, 0x04, 0x00, 0x00, 0x00, 0x00, // 0x10
    0x00, 0x04, 0x40, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x40, 0x04, 0x00, 0x00, 0x00, 0x00, // 0x20
    0x00, 0x06, 0x40, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x40, 0x04, 0x00, 0x00, 0x00, 0x00, // 0x30
    0x00, 0x08, 0x40, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x40, 0x04, 0x00, 0x00, 0x00, 0x00  // 0x40
  };

  if (sizeof (replay1) > sgio_h->dxfer_len) {
    errno = EINVAL;
    return -1;
  }
  if (clearCompressionStats) {
    memcpy(sgio_h->dxferp, replay2, sizeof (replay2));
  } else {
    memcpy(sgio_h->dxferp, replay1, sizeof (replay1));
  }
  return 0;
}

int System::stDeviceFile::logSenseBlockBytesTransferred(sg_io_hdr_t * sgio_h) {
  /**
   * This is a real reply from the enterprise IBM 03592E06 drive. 
   * We only fill the testing values in the corresponding fields for the 
   * compression statistics. The replay1 is the replay with not empty
   * data and the replay2 is the replay with zero statistics.
   */
  unsigned char replay1[] = {
    0x38, 0x00, 0x00, 0x8a, 0x00, 0x00, 0x60, 0x04, 0x00, 0x00, 0x1f, 0xfe, 0x00, 0x01, 0x60, 0x04, // 0x00
    0x11, 0x22, 0x33, 0x44, 0x00, 0x02, 0x60, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x60, 0x04, // 0x10
    0x55, 0x66, 0x77, 0x88, 0x00, 0x04, 0x60, 0x04, 0x00, 0x00, 0x03, 0x21, 0x00, 0x05, 0x60, 0x04, // 0x20
    0x99, 0xaa, 0xbb, 0xcc, 0x00, 0x06, 0x60, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x60, 0x04, // 0x30
    0xdd, 0xee, 0xff, 0x11, 0x00, 0x08, 0x60, 0x04, 0x00, 0x00, 0x03, 0x21, 0x00, 0x09, 0x60, 0x04, // 0x40
    0x00, 0x13, 0x47, 0xeb, 0x00, 0x0a, 0x60, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x60, 0x04, // 0x50
    0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x60, 0x04, 0x3a, 0x35, 0x29, 0x44, 0x00, 0x0d, 0x60, 0x01, // 0x60
    0x00, 0x00, 0x0e, 0x60, 0x04, 0x3a, 0x35, 0x29, 0x44, 0x00, 0x0f, 0x60, 0x01, 0x00, 0x00, 0x10, // 0x70
    0x60, 0x04, 0x3a, 0x21, 0x9b, 0x54, 0x00, 0x11, 0x60, 0x04, 0x3a, 0x21, 0x9b, 0x54              // 0x80
  };
  unsigned char replay2[] = {
    0x38, 0x00, 0x00, 0x8a, 0x00, 0x00, 0x60, 0x04, 0x00, 0x00, 0x1f, 0xfe, 0x00, 0x01, 0x60, 0x04, // 0x00
    0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x60, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x60, 0x04, // 0x10
    0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x60, 0x04, 0x00, 0x00, 0x03, 0x21, 0x00, 0x05, 0x60, 0x04, // 0x20
    0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x60, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x60, 0x04, // 0x30
    0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x60, 0x04, 0x00, 0x00, 0x03, 0x21, 0x00, 0x09, 0x60, 0x04, // 0x40
    0x00, 0x13, 0x47, 0xeb, 0x00, 0x0a, 0x60, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x60, 0x04, // 0x50
    0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x60, 0x04, 0x3a, 0x35, 0x29, 0x44, 0x00, 0x0d, 0x60, 0x01, // 0x60
    0x00, 0x00, 0x0e, 0x60, 0x04, 0x3a, 0x35, 0x29, 0x44, 0x00, 0x0f, 0x60, 0x01, 0x00, 0x00, 0x10, // 0x70
    0x60, 0x04, 0x3a, 0x21, 0x9b, 0x54, 0x00, 0x11, 0x60, 0x04, 0x3a, 0x21, 0x9b, 0x54              // 0x80
  };
  if (sizeof (replay1) > sgio_h->dxfer_len) {
    errno = EINVAL;
    return -1;
  }
  if (clearCompressionStats) {
    memcpy(sgio_h->dxferp, replay2, sizeof (replay2));
  } else {
    memcpy(sgio_h->dxferp, replay1, sizeof (replay1));
  }
  return 0;
}

int System::stDeviceFile::logSenseTapeAlerts(sg_io_hdr_t* sgio_h) {
  size_t remaining = sgio_h->dxfer_len;
  /* Truncation of any field should yield an error */
  if (remaining < (4 + 320)) {
    errno = EINVAL;
    return -1;
  }
  /* Header as-is from mhvtl. */
  unsigned char * data = (unsigned char *) sgio_h->dxferp;
  data[0] = 0x2eU;
  /* 145h bytes, with parameters of 5 bytes means 65 parameters */
  data[2] = 0x1U;
  data[3] = 0x45U;
  data += 4; remaining -= 4;
  /* This array was extracted from p/x in gdb of the tape alert log page from
   * mhvtl, then processed through:
   * cat mhvtlAlerts.txt  | tr -d "\n" | perl -p -e 's/\},/}\n/g' |  grep parameterCode | 
   * perl -e 'while (<>) { if ( /\{\s*(0x[[:xdigit:]]+),\s*(0x[[:xdigit:]]+)\}/ ) { print (hex($1) * 256 + hex($2)); print ", " } }'*/
  /* We also add an out-of-range 65 */
  uint16_t parameterCodes[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 
  15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 
  34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 
  53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65 };
  size_t i = 0;
  while (remaining > 5 && i < 65) {
    /* small gymnastic to turn a bare buffer into a SCSI u16 storage */
    struct u16wrap { unsigned char u16[2]; };
    struct u16wrap * s((struct u16wrap *) &(data[0]));
    SCSI::Structures::setU16(s->u16, parameterCodes[i]);
    data[2] = 0U;
    data[3] = 1U;
    data[4] = 0U; /* TODO: at least some parameters should get set */
    switch (parameterCodes[i]) {
      case 0x28:
      case 0x10:
      case 65:
      case 0x32: // tapeAlertLostStatistics
        data[4] |= 1; /* Set flag */
    }
    i++; data += 5; remaining -=5;
  }
  return 0;
}

int System::stDeviceFile::ioctlModSense6(sg_io_hdr_t * sgio_h) {
  if (SG_DXFER_FROM_DEV != sgio_h->dxfer_direction) {
    errno = EINVAL;
    return -1;
  }
  SCSI::Structures::modeSense6CDB_t & cdb =
          *(SCSI::Structures::modeSense6CDB_t *) sgio_h->cmdp;
    
  switch (cdb.pageCode) {
    case SCSI::modeSensePages::deviceConfiguration:
      return modeSenseDeviceConfiguration(sgio_h);
    case SCSI::modeSensePages::controlDataProtection:
      return modeSenseControlDataProtection(sgio_h);
  }
  errno = EINVAL;
  return -1;
}

int System::stDeviceFile::modeSenseDeviceConfiguration(sg_io_hdr_t * sgio_h) {
  SCSI::Structures::modeSense6CDB_t & cdb =
          *(SCSI::Structures::modeSense6CDB_t *) sgio_h->cmdp;
  if (SCSI::modeSensePages::deviceConfiguration != cdb.pageCode) {
    errno = EINVAL;
    return -1;
  }
  SCSI::Structures::modeSenseDeviceConfiguration_t & devConfig =
          *(SCSI::Structures::modeSenseDeviceConfiguration_t *) sgio_h->dxferp;

  if (sizeof (devConfig) > sgio_h->dxfer_len) {
    errno = EINVAL;
    return -1;
  }
  /* fill the replay with random data */
  srandom(SCSI::Commands::MODE_SENSE_6);
  memset(sgio_h->dxferp, random(), sizeof (devConfig));
  
  /* sets fileds to be used*/
  devConfig.modePage.pageCode = SCSI::modeSensePages::deviceConfiguration;
  return 0;
}

int System::stDeviceFile::modeSenseControlDataProtection(sg_io_hdr_t * sgio_h) {
  SCSI::Structures::modeSense6CDB_t & cdb =
          *(SCSI::Structures::modeSense6CDB_t *) sgio_h->cmdp;
  if (SCSI::modeSensePages::controlDataProtection != cdb.pageCode) {
    errno = EINVAL;
    return -1;
  }  
 
  if (cdb.subPageCode != SCSI::modePageControlDataProtection::subpageCode) {
    errno = EINVAL;
    return -1;
  }        
  
  SCSI::Structures::modeSenseControlDataProtection_t & controlDataProtection =
    *(SCSI::Structures::modeSenseControlDataProtection_t *) sgio_h->dxferp;

  if (sizeof (controlDataProtection) > sgio_h->dxfer_len) {
    errno = EINVAL;
    return -1;
  }
  /* fill the replay with random data */
  srandom(SCSI::Commands::MODE_SENSE_6);
  memset(sgio_h->dxferp, random(), sizeof (controlDataProtection));
  
  /* fils only used fields */
  controlDataProtection.modePage.LBPMethod = m_LBPInfoMethod;
  controlDataProtection.modePage.LBPInformationLength = m_LBPInfoLength;
  controlDataProtection.modePage.LBP_R = m_LBPInfo_R;
  controlDataProtection.modePage.LBP_W = m_LBPInfo_W;
  // 28 bytes as IBM and LTO
  SCSI::Structures::setU16(controlDataProtection.modePage.pageLength, 28);
  controlDataProtection.modePage.pageCode =
    SCSI::modeSensePages::controlDataProtection;
  return 0;
}

int System::stDeviceFile::ioctlModSelect6(sg_io_hdr_t * sgio_h) {
  if (SG_DXFER_TO_DEV != sgio_h->dxfer_direction) {
    errno = EINVAL;
    return -1;
  }
  unsigned char * data = (unsigned char *) sgio_h->dxferp;
  
  SCSI::Structures::modeParameterHeader6_t & header =
    *(SCSI::Structures::modeParameterHeader6_t *) sgio_h->dxferp;  

  SCSI::Structures::modeParameterBlockDecriptor_t & blockDescriptor = 
    *(SCSI::Structures::modeParameterBlockDecriptor_t *) (data+sizeof(header));
  
  unsigned char * modeSelectBlock = data+sizeof(header)+sizeof(blockDescriptor);

  switch (modeSelectBlock[0]&0x3F) {  // only 6bits are the page code
    case SCSI::modeSensePages::deviceConfiguration:
      return modeSelectDeviceConfiguration(sgio_h);
    case SCSI::modeSensePages::controlDataProtection:
      return modeSelectControlDataProtection(sgio_h);
  }
  errno = EINVAL;
  return -1;
}

int System::stDeviceFile::modeSelectDeviceConfiguration(sg_io_hdr_t * sgio_h) {
  SCSI::Structures::modeSelect6CDB_t & cdb =
    *(SCSI::Structures::modeSelect6CDB_t *) sgio_h->cmdp;

  SCSI::Structures::modeSenseDeviceConfiguration_t & devConfig =
    *(SCSI::Structures::modeSenseDeviceConfiguration_t *) sgio_h->dxferp;
  
  if (devConfig.modePage.pageCode != SCSI::modeSensePages::deviceConfiguration) {
    errno = 5;
    return -1;
  }
  
  if (sizeof (devConfig) > sgio_h->dxfer_len) {
    errno = 6;
    return -1;
  }

  if (1 != cdb.PF || sizeof (devConfig) != cdb.paramListLength ||
      0 != devConfig.header.modeDataLength) {
    errno = 7;
    return -1;
  }

  if (1 != devConfig.modePage.selectDataComprAlgorithm &&
      0 != devConfig.modePage.selectDataComprAlgorithm) {
    errno = 8;
    return -1;
  }
  return 0;
}

int System::stDeviceFile::modeSelectControlDataProtection(sg_io_hdr_t * sgio_h) {
  SCSI::Structures::modeSelect6CDB_t & cdb =
    *(SCSI::Structures::modeSelect6CDB_t *) sgio_h->cmdp;

  SCSI::Structures::modeSenseControlDataProtection_t & controlData =
    *(SCSI::Structures::modeSenseControlDataProtection_t *) sgio_h->dxferp;
  
  if (controlData.modePage.pageCode != SCSI::modeSensePages::controlDataProtection) {
    errno = EINVAL;
    return -1;
  }
  
  if (sizeof (controlData) > sgio_h->dxfer_len) {
    errno = EINVAL;
    return -1;
  }

  if (1 != cdb.PF || sizeof (controlData) != cdb.paramListLength ||
      0 != controlData.header.modeDataLength) {
    errno = EINVAL;
    return -1;
  }
  
  m_LBPInfoMethod =  controlData.modePage.LBPMethod;
  m_LBPInfoLength = controlData.modePage.LBPInformationLength;
  m_LBPInfo_R = controlData.modePage.LBP_R;
  m_LBPInfo_W = controlData.modePage.LBP_W;
  return 0;
}

int System::stOracleT10000Device::ioctlInquiry(sg_io_hdr_t * sgio_h) {
 if (SG_DXFER_FROM_DEV != sgio_h->dxfer_direction) {
    errno = EINVAL;
    return -1;
  }
  SCSI::Structures::inquiryCDB_t & cdb =
          *(SCSI::Structures::inquiryCDB_t *) sgio_h->cmdp;

  if (0 == cdb.EVPD && 0 == cdb.pageCode) {
    /* the Standard Inquiry Data is returned*/
    SCSI::Structures::inquiryData_t & inqData =
            *(SCSI::Structures::inquiryData_t *) sgio_h->dxferp;
    if (sizeof (inqData) > sgio_h->dxfer_len) {
      errno = EINVAL;
      return -1;
    }
    /* fill the replay with random data */
    srandom(SCSI::Commands::INQUIRY);
    memset(sgio_h->dxferp, random(), sizeof (inqData));
    /* We fill only fields we need.
     * The emptiness in the strings fields we fill with spaces.
     * And we do not need '\0' in the end of strings. For the tests
     * there are mhvtl data.
     */
    const char *prodId = "T10000B                       ";
    memcpy(inqData.prodId, prodId, sizeof (inqData.prodId));
    const char *prodRevLvl = "0104                      ";
    memcpy(inqData.prodRevLvl, prodRevLvl, sizeof (inqData.prodRevLvl));
    const char *T10Vendor = "STK                        ";
    memcpy(inqData.T10Vendor, T10Vendor, sizeof (inqData.T10Vendor));
    inqData.protect = 1;
  } else if (1 == cdb.EVPD && SCSI::inquiryVPDPages::unitSerialNumber == cdb.pageCode) {
    /* the unit serial number VPD page is returned*/
    SCSI::Structures::inquiryUnitSerialNumberData_t & inqSerialData =
            *(SCSI::Structures::inquiryUnitSerialNumberData_t *) sgio_h->dxferp;
    if (sizeof (inqSerialData) > sgio_h->dxfer_len) {
      errno = EINVAL;
      return -1;
    }
    /* fill the replay with random data */
    srandom(SCSI::Commands::INQUIRY);
    memset(sgio_h->dxferp, random(), sgio_h->dxfer_len);
    const char serialNumber[11] = "XYZZY_A2  ";
    memcpy(inqSerialData.productSerialNumber, serialNumber, 10);
    inqSerialData.pageLength = 10;
  } else {
    errno = EINVAL;
    return -1;
  }
  return 0;
}

int System::stIBM3592DeviceFile::ioctlInquiry(sg_io_hdr_t * sgio_h) {
  if (SG_DXFER_FROM_DEV != sgio_h->dxfer_direction) {
    errno = EINVAL;
    return -1;
  }
  SCSI::Structures::inquiryCDB_t & cdb =
    *(SCSI::Structures::inquiryCDB_t *) sgio_h->cmdp;

  if (0 == cdb.EVPD && 0 == cdb.pageCode) {
    /* the Standard Inquiry Data is returned*/
    SCSI::Structures::inquiryData_t & inqData =
      *(SCSI::Structures::inquiryData_t *) sgio_h->dxferp;
    if (sizeof (inqData) > sgio_h->dxfer_len) {
      errno = EINVAL;
      return -1;
    }
    /* fill the replay with random data */
    srandom(SCSI::Commands::INQUIRY);
    memset(sgio_h->dxferp, random(), sizeof (inqData));
    /* We fill only fields we need.
     * The emptiness in the strings fields we fill with spaces.
     * And we do not need '\0' in the end of strings. For the tests
     * there are mhvtl data.
     */
    const char *prodId = "03592E08                      ";
    memcpy(inqData.prodId, prodId, sizeof (inqData.prodId));
    const char *prodRevLvl = "460E                      ";
    memcpy(inqData.prodRevLvl, prodRevLvl, sizeof (inqData.prodRevLvl));
    const char *T10Vendor = "IBM                        ";
    memcpy(inqData.T10Vendor, T10Vendor, sizeof (inqData.T10Vendor));
  } else if (1 == cdb.EVPD && SCSI::inquiryVPDPages::unitSerialNumber == cdb.pageCode) {
    /* the unit serial number VPD page is returned*/
    SCSI::Structures::inquiryUnitSerialNumberData_t & inqSerialData =
      *(SCSI::Structures::inquiryUnitSerialNumberData_t *) sgio_h->dxferp;
    if (sizeof (inqSerialData) > sgio_h->dxfer_len) {
      errno = EINVAL;
      return -1;
    }
    /* fill the replay with random data */
    srandom(SCSI::Commands::INQUIRY);
    memset(sgio_h->dxferp, random(), sgio_h->dxfer_len);
    const char serialNumber[11] = "XYZZY_A2  ";
    memcpy(inqSerialData.productSerialNumber, serialNumber, 10);
    inqSerialData.pageLength = 10;
  } else {
    errno = EINVAL;
    return -1;
  }
  return 0;
}

