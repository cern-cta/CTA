/*
 * Copyright (C) 1999-2002 by CERN/IT/PDP/DM
 * All rights reserved
 */
 
#ifndef lint
static char sccsid[] = "@(#)$RCSfile: Cupv_oracle_ifce.pc,v $ $Revision: 1.8 $ $Date: 2005/07/11 12:47:47 $ CERN IT-PDP/DM Ben Couturier";
#endif /* not lint */

#include <stdio.h>
#include <errno.h>
#include <string.h>
#include <sys/types.h>
#include <sqlca.h>
#ifndef USE_ORACLE
#define USE_ORACLE
#endif
#include "serrno.h"
#include "u64subr.h"
#include "Cupv.h"
#include "Cupv_server.h"

static sql_context ctx[CUPV_NBTHREADS];

Cupv_init_dbpkg()
{
  int i;

  EXEC SQL ENABLE THREADS;
  for (i = 0; i < CUPV_NBTHREADS; i++) {
    EXEC SQL CONTEXT ALLOCATE :ctx[i];
  }
  return (0);
}

EXEC SQL CONTEXT USE :ctx[dbfd->idx]; 

Cupv_abort_tr(dbfd)
     struct Cupv_dbfd *dbfd;
{
  EXEC SQL ROLLBACK WORK;
  dbfd->tr_started = 0;
  return (0);
}

Cupv_opendb(db_srvr, db_user, db_pwd, dbfd)
     char *db_srvr;
     char *db_user;
     char *db_pwd;
     struct Cupv_dbfd *dbfd;
{
  int c;
  char func[16];
  int ntries;
  struct sqlca sqlca;

  strcpy (func, "Cupv_opendb");
  ntries = 0;
  while (1) {
    EXEC SQL CONNECT :db_user IDENTIFIED BY :db_pwd;
    if (sqlca.sqlcode == 0) {
      return (0);
    }
    if (sqlca.sqlcode != -1014 && sqlca.sqlcode != -1033 &&
	sqlca.sqlcode != -1034) break;
    if (ntries++ >= MAXRETRY) break;
    sleep (RETRYI);
  }
  Cupvlogit (func, "CONNECT error: %.*s\n", sqlca.sqlerrm.sqlerrml,
	     sqlca.sqlerrm.sqlerrmc);
  serrno = SEINTERNAL;
  return (-1);
}

Cupv_closedb(dbfd)
     struct Cupv_dbfd *dbfd;
{
  EXEC SQL CONTEXT FREE :ctx[dbfd->idx];
  return (0);
}

Cupv_start_tr(s, dbfd)
     int s;
     struct Cupv_dbfd *dbfd;
{
  dbfd->tr_started = 1;
  return (0);
}

Cupv_end_tr(dbfd)
     struct Cupv_dbfd *dbfd;
{
  EXEC SQL COMMIT WORK;
  dbfd->tr_started = 0;
  return (0);
}

Cupv_get_privilege_entry(dbfd, priv_entry,  lock, rec_addr)
     struct Cupv_dbfd *dbfd;
     struct Cupv_userpriv *priv_entry;
     int lock;
     Cupv_dbrec_addr *rec_addr;
{
  char func[21];
  char rowid_value[19];
  int lensrc, lentgt;
  struct sqlca sqlca;

  lensrc = strlen(priv_entry->srchost);
  lentgt = strlen(priv_entry->tgthost);

  EXEC SQL DECLARE priv_cursor CURSOR FOR
    SELECT 
    U_ID, G_ID, SRC_HOST, TGT_HOST, PRIV_CAT 
    FROM USER_PRIVILEGE 
    WHERE U_ID = :priv_entry->uid 
    AND G_ID = :priv_entry->gid
    AND SRC_HOST LIKE :priv_entry->srchost 
    AND TGT_HOST LIKE :priv_entry->tgthost
    ORDER BY U_ID, G_ID, SRC_HOST, TGT_HOST;   

  EXEC SQL DECLARE priv_cursor4upd CURSOR FOR
    SELECT ROWID,
    U_ID, G_ID, SRC_HOST, TGT_HOST, PRIV_CAT 
    FROM USER_PRIVILEGE 
    WHERE U_ID = :priv_entry->uid 
    AND G_ID = :priv_entry->gid
    AND SRC_HOST LIKE :priv_entry->srchost 
    AND TGT_HOST LIKE :priv_entry->tgthost
    ORDER BY U_ID, G_ID, SRC_HOST, TGT_HOST;   

  strcpy (func, "Cupv_get_priv_entry");
  if (lock) {
    EXEC SQL OPEN priv_cursor4upd;
    if (sqlca.sqlcode) {
      Cupvlogit (func, "OPEN CURSOR error: %.*s\n",
		 sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc);
      serrno = SEINTERNAL;
      return (-1);
    }
    EXEC SQL FETCH priv_cursor4upd INTO
      :rowid_value,
      :priv_entry->uid, :priv_entry->gid, 
      :priv_entry->srchost, :priv_entry->tgthost, :priv_entry->privcat; 
 
  } else {
    EXEC SQL OPEN priv_cursor;
    if (sqlca.sqlcode) {
      Cupvlogit (func, "OPEN CURSOR error: %.*s\n",
		 sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc);
      serrno = SEINTERNAL;
      return (-1);
    }
    EXEC SQL FETCH priv_cursor INTO
      :priv_entry->uid, :priv_entry->gid, 
      :priv_entry->srchost, :priv_entry->tgthost, :priv_entry->privcat; 
  }
  switch (sqlca.sqlcode) {
  case 0:
    if (lock)
      memcpy (rec_addr, rowid_value, sizeof(rowid_value));
    return (0);
  case 1403:
    serrno = ENOENT;
    break;
  default:
    Cupvlogit (func, "FETCH error: %.*s\n", sqlca.sqlerrm.sqlerrml,
	       sqlca.sqlerrm.sqlerrmc);
    serrno = SEINTERNAL;
  }
  return (-1);
}

Cupv_delete_privilege_entry(dbfd, rec_addr)
     struct Cupv_dbfd *dbfd;
     Cupv_dbrec_addr *rec_addr;
{
  char func[24];
  char rowid_value[19];
  struct sqlca sqlca;

  strcpy (func, "Cupv_delete_priv_entry");
  
  memcpy (rowid_value, rec_addr, sizeof(rowid_value));
  
  EXEC SQL DELETE FROM user_privilege WHERE ROWID = :rowid_value;
  if (sqlca.sqlcode) {
    Cupvlogit (func, "DELETE error: %.*s\n", sqlca.sqlerrm.sqlerrml,
	       sqlca.sqlerrm.sqlerrmc);
    serrno = SEINTERNAL;
    return (-1);
  }
  return (0);
}



Cupv_insert_privilege_entry(dbfd, priv_entry)
     struct Cupv_dbfd *dbfd;
     struct Cupv_userpriv *priv_entry;
{
  char func[24];
  struct sqlca sqlca;

  strcpy (func, "Cupv_insert_priv_entry");

  EXEC SQL INSERT INTO USER_PRIVILEGE
    (U_ID, G_ID, SRC_HOST, TGT_HOST, PRIV_CAT)
    VALUES
    (:priv_entry->uid, :priv_entry->gid,
     :priv_entry->srchost, :priv_entry->tgthost, :priv_entry->privcat);
	
  switch (sqlca.sqlcode) {
  case 0:
    return (0);
  case -1:
    serrno = SEENTRYEXISTS;
    break;
  case -1631:
  case -1632:
  case -1654:
    serrno = ENOSPC;
    break;
  default:
    Cupvlogit (func, "INSERT error: %.*s\n", sqlca.sqlerrm.sqlerrml,
	       sqlca.sqlerrm.sqlerrmc);
    serrno = SEINTERNAL;
  }
  return (-1);	
}

Cupv_update_privilege_entry(dbfd, rec_addr, priv_entry)
     struct Cupv_dbfd *dbfd;
     Cupv_dbrec_addr *rec_addr;
     struct Cupv_userpriv *priv_entry;
{
  char func[24];
  char rowid_value[19];
  struct sqlca sqlca;
  char sqlstatement[MAXSQLSTMENTLEN +1];
  char *p;
  int nbfieldupdated = 0;
  
  strcpy (func, "Cupv_update_priv_entry");
  memcpy (rowid_value, rec_addr, sizeof(rowid_value));

  /* Building the sql statement */
  p = sqlstatement;
  
  p += sprintf(p, "UPDATE USER_PRIVILEGE SET ");
  
  if (priv_entry->privcat != -1) {
    p += sprintf(p, " PRIV_CAT = %d ", priv_entry->privcat);
    nbfieldupdated++;
  }
  if (priv_entry->srchost[0] != 0) {
    if (nbfieldupdated != 0) {
      p += sprintf(p, ", "); 
    }
    p += sprintf(p, " SRC_HOST = '%s' ", priv_entry->srchost);
    nbfieldupdated++;
  }
  if (priv_entry->tgthost[0] != 0) {
    if (nbfieldupdated != 0) {
      p += sprintf(p, ", "); 
    }
    p += sprintf(p, " TGT_HOST = '%s' ", priv_entry->tgthost);
    nbfieldupdated++;
  }
  
  /* Checing that there is a SET clause with at least one param */
  if (nbfieldupdated == 0) {
    Cupvlogit (func, "At least ONE field should be updated\n");
    serrno = SEINTERNAL;
    return(-1);
  }

  /* Adding the where clause */
  p += sprintf(p,"     WHERE ROWID = '%s' ", rowid_value);
  *p = '\0';

  Cupvlogit(func, "%s\n", sqlstatement);
  
  EXEC SQL EXECUTE IMMEDIATE :sqlstatement;
  
  switch (sqlca.sqlcode) {
  case 0:
    return(0);
  case -1631:
  case -1632:
  case -1654:
    serrno = ENOSPC;
    break;
  case 1403:
    serrno = SEENTRYNFND;
    break;
  default:
    Cupvlogit (func, "MODIFY error: %.*s\n", sqlca.sqlerrm.sqlerrml,
	       sqlca.sqlerrm.sqlerrmc);
    serrno = SEINTERNAL;
    break;;
  }
  
  return(-1);
}


Cupv_list_privilege_entry(dbfd, bol, priv_entry, filter, endlist, dblistptr)
     struct Cupv_dbfd *dbfd;
     int bol;
     struct Cupv_userpriv *priv_entry;
     struct Cupv_userpriv *filter;
     int endlist;
     DBLISTPTR *dblistptr;
{
  char func[22];
  struct sqlca sqlca;
  int lensrc = 0, lentgt = 0;

  strcpy(func, "list_priv");

  /*    Cupvlogit(func,"FILTER: <%d> <%d> <%s> <%s> <%d>\n", filter->uid, filter->gid, */
  /*  	    filter->srchost, filter->tgthost, filter->privcat); */

  lensrc = strlen(filter->srchost);
  lentgt = strlen(filter->tgthost);
	
  EXEC SQL DECLARE list_priv_cursor CURSOR FOR 
    SELECT 
    U_ID, G_ID, SRC_HOST, TGT_HOST, PRIV_CAT 
    FROM USER_PRIVILEGE 
    WHERE ( (:filter->uid = -1) OR (U_ID = :filter->uid)) 
    AND  ( (:filter->gid = -1) OR (G_ID = :filter->gid)) 
    AND  ( ( :lensrc = 0) OR (SRC_HOST LIKE :filter->srchost)) 
    AND  ( ( :lentgt = 0) OR (TGT_HOST LIKE :filter->tgthost))   
    AND  ( (:filter->privcat = -1) OR (PRIV_CAT = :filter->privcat)) 
    ORDER BY U_ID, G_ID, SRC_HOST, TGT_HOST;   

  strcpy (func, "Cupv_list_priv_entry");
  if (endlist)
    return (1);
  if (bol) {
    EXEC SQL OPEN list_priv_cursor;
    if (sqlca.sqlcode) {
      Cupvlogit (func, "OPEN CURSOR error: %.*s\n",
		 sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc);
      serrno = SEINTERNAL;
      return (-1);
    }
  }
  
  EXEC SQL FETCH list_priv_cursor INTO 
    :priv_entry->uid, :priv_entry->gid, 
    :priv_entry->srchost, :priv_entry->tgthost, :priv_entry->privcat; 

  switch (sqlca.sqlcode) {
  case 0:
    return (0);
  case 1403:
    return (1);
  default:
    Cupvlogit (func, "FETCH error: %.*s\n", sqlca.sqlerrm.sqlerrml,
	       sqlca.sqlerrm.sqlerrmc);
    serrno = SEINTERNAL;
    return (-1);
  }
}



/* BEGIN - DEPRECATED METHODS                                             */
/* ====================================================================== */

Cupv_delete_privilege_deprecated(dbfd, uid, gid, src, tgt) 
     struct Cupv_dbfd *dbfd; 
     int uid;
     int gid;
     char *src;
     char *tgt;
{ 
  char func[24]; 
  char rowid_value[19]; 
  struct sqlca sqlca; 
  
  strcpy (func, "Cupv_delete"); 

  EXEC SQL DELETE FROM USER_PRIVILEGE WHERE U_ID = :uid
    AND G_ID = :gid
    AND SRC_HOST = :src
    AND TGT_HOST = :tgt;
     
  switch(sqlca.sqlcode) {
  case 0:  
    return (0);  
  case 1403:  
    serrno = SEENTRYNFND;  
    break;  
  default:  
    serrno = SEINTERNAL;  
    break;
  }
  Cupvlogit (func, "DELETE error: %.*s\n", sqlca.sqlerrm.sqlerrml, 
	     sqlca.sqlerrm.sqlerrmc);  
  return (-1); 
}

Cupv_add_privilege_deprecated(dbfd, uid, gid, srcHost, tgtHost, priv)
     struct Cupv_dbfd *dbfd;
     int uid;
     int gid;
     char *srcHost;
     char *tgtHost;
     int priv;
{
  char func[24];
  struct sqlca sqlca;

  strcpy (func, "Cupv_add_privilege");

  EXEC SQL INSERT INTO USER_PRIVILEGE
    (U_ID, G_ID, SRC_HOST, TGT_HOST, PRIV_CAT)
    VALUES
    (:uid, :gid,
     :srcHost, :tgtHost, :priv);

  switch (sqlca.sqlcode) {
  case 0:
    return (0);
  case -1:
    serrno = SEENTRYEXISTS;
    break;
  case -1631:
  case -1632:
  case -1654:
    serrno = ENOSPC;
    break;
  default:
    Cupvlogit (func, "INSERT error: %.*s\n", sqlca.sqlerrm.sqlerrml,
	       sqlca.sqlerrm.sqlerrmc);
    serrno = SEINTERNAL;
  }
  return (-1);
}

Cupv_modify_privilege_deprecated(dbfd, uid, gid, srcHost, tgtHost, newsrcHost, newtgtHost,  priv)
     struct Cupv_dbfd *dbfd;
     int uid;
     int gid;
     char *srcHost;
     char *tgtHost;
     char *newsrcHost;
     char *newtgtHost;
     int priv;
{
  char func[24];
  struct sqlca sqlca;
  char sqlstatement[MAXSQLSTMENTLEN +1];
  char *p;
  int nbfieldupdated = 0;

  strcpy (func, "Cupv_modify_privilege");
  
  /* Building the sql statement */
  p = sqlstatement;

  p += sprintf(p, "UPDATE USER_PRIVILEGE SET ");
  
  if (priv != -1) {
    p += sprintf(p, " PRIV_CAT = %d ", priv);
    nbfieldupdated++;
  }
  if (newsrcHost[0] != 0) {
    if (nbfieldupdated != 0) {
      p += sprintf(p, ", "); 
    }
    p += sprintf(p, " SRC_HOST = '%s' ", newsrcHost);
    nbfieldupdated++;
  }
  if (newtgtHost[0] != 0) {
    if (nbfieldupdated != 0) {
      p += sprintf(p, ", "); 
    }
    p += sprintf(p, " TGT_HOST = '%s' ", newtgtHost);
    nbfieldupdated++;
  }
  
  /* Checking that there is a SET clause with at least one param */
  if (nbfieldupdated == 0) {
    Cupvlogit (func, "At least ONE field should be updated\n");
    serrno = SEINTERNAL;
    return(-1);
  }

  /* Adding the where clause */
  p += sprintf(p," WHERE U_ID = %d AND G_ID = %d AND SRC_HOST = '%s' AND TGT_HOST = '%s' ",
	       uid, gid, srcHost, tgtHost);
  *p = '\0';

  Cupvlogit(func, sqlstatement);

  EXEC SQL EXECUTE IMMEDIATE :sqlstatement;
    
  switch (sqlca.sqlcode) {
  case 0:
    return(0);
  case -1631:
  case -1632:
  case -1654:
    serrno = ENOSPC;
    break;
  case 1403:
    serrno = SEENTRYNFND;
    break;
  default:
    Cupvlogit (func, "MODIFY error: %.*s\n", sqlca.sqlerrm.sqlerrml,
	       sqlca.sqlerrm.sqlerrmc);
    serrno = SEINTERNAL;
    break;;
  }

  return(-1);

}




Cupv_list_privilege_deprecated(dbfd, bol, priv_entry) 
     struct Cupv_dbfd *dbfd; 
     int bol; 
     struct Cupv_userpriv *priv_entry; 
{ 
  char func[22]; 
  struct sqlca sqlca; 
  int lensrc = 0;
  int lentgt = 0;

  strcpy (func, "Cupv_list"); 

  lensrc = strlen(priv_entry->srchost);
  lentgt = strlen(priv_entry->tgthost);

  EXEC SQL DECLARE list_cursor CURSOR FOR 
    SELECT 
    U_ID, G_ID, SRC_HOST, TGT_HOST, PRIV_CAT 
    FROM USER_PRIVILEGE 
    WHERE ( (:priv_entry->uid = -1) OR (U_ID = :priv_entry->uid)) 
    AND  ( (:priv_entry->gid = -1) OR (G_ID = :priv_entry->gid)) 
    AND  ( ( :lensrc = 0) OR (SRC_HOST LIKE :priv_entry->srchost)) 
    AND  ( ( :lentgt = 0) OR (TGT_HOST LIKE :priv_entry->tgthost))   
    AND  ( (:priv_entry->privcat = -1) OR (PRIV_CAT = :priv_entry->privcat)) 
    ORDER BY U_ID, G_ID, SRC_HOST, TGT_HOST;   


  if (bol) { 

    EXEC SQL OPEN list_cursor; 

    if (sqlca.sqlcode) { 
      Cupvlogit (func, "OPEN CURSOR error: %.*s\n", 
		 sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc); 
      serrno = SEINTERNAL; 
      return (-1); 
    } 
  } 

  /*    Cupvlogit(func, "CURSOR opened\n"); */

  EXEC SQL FETCH list_cursor INTO 
    :priv_entry->uid, :priv_entry->gid, 
    :priv_entry->srchost, :priv_entry->tgthost, :priv_entry->privcat; 
  
  
  /*    Cupvlogit(func, "Fetch done\n"); */


  switch (sqlca.sqlcode) { 
  case 0: 
    
    Cupvlogit(func, "Fetch returned: <%d> <%d> <%s> <%s> <%d>\n", priv_entry->uid, priv_entry->gid, 
	      priv_entry->srchost, priv_entry->tgthost, priv_entry->privcat);

    return (0); 
  case 1403: 
    return (1); 
  default: 
    Cupvlogit (func, "FETCH error: %.*s\n", sqlca.sqlerrm.sqlerrml, 
	       sqlca.sqlerrm.sqlerrmc); 
    serrno = SEINTERNAL; 
    return (-1); 
  } 
}

/* END - DEPRECATED METHODS                                               */
/* ====================================================================== */
