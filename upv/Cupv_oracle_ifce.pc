/*
 * Copyright (C) 1999-2002 by CERN/IT/PDP/DM
 * All rights reserved
 */

#include <stdio.h>
#include <errno.h>
#include <string.h>
#include <sys/types.h>
#include <unistd.h>
#include <sqlca.h>
#include <sqlcpr.h>
#ifndef USE_ORACLE
#define USE_ORACLE
#endif
#include "serrno.h"
#include "u64subr.h"
#include "Cupv.h"
#include "Cupv_server.h"

static sql_context ctx[CUPV_MAXNBTHREADS];

int Cupv_init_dbpkg()
{
  EXEC SQL ENABLE THREADS;
  return (0);
}

static void
Cupv_oracle_error(func, sql_method, dbfd, sqlca)
char *func;
char *sql_method;
struct Cupv_dbfd *dbfd;
struct sqlca *sqlca;
{
  char   err_msg[512];
  size_t err_size = sizeof(err_msg);
  size_t err_len;
  
  sqlglmt(ctx[dbfd->idx], (unsigned char*)err_msg, &err_size, &err_len);
  if (err_msg[err_len - 1]  == '\n') {
    err_msg[err_len - 1] = '\0';
  }
  
  Cupvlogit (func, "%s error: %.*s\n", sql_method, err_len, err_msg);
  
  /* Connection to the database was lost ? */
  if (sqlca->sqlcode == -2396  || sqlca->sqlcode == -3113  ||
      sqlca->sqlcode == -28    || sqlca->sqlcode == -3114  || 
      sqlca->sqlcode == -32102 || sqlca->sqlcode == -3135  || 
      sqlca->sqlcode == -12170 || sqlca->sqlcode == -12541 || 
      sqlca->sqlcode == -1012  || sqlca->sqlcode == -1003  || 
      sqlca->sqlcode == -12571 || (sqlca->sqlcode <= -25401 && sqlca->sqlcode >= -25409) || 
      sqlca->sqlcode == -1033  || sqlca->sqlcode == -1089) {
    if (dbfd->connected == 1) {
      Cupv_closedb (dbfd);
    }
  }
  serrno = SEINTERNAL;
}

EXEC SQL CONTEXT USE :ctx[dbfd->idx]; 

int Cupv_abort_tr(dbfd)
     struct Cupv_dbfd *dbfd;
{
  EXEC SQL ROLLBACK WORK;
  dbfd->tr_started = 0;
  return (0);
}

int Cupv_opendb(dbfd)
     struct Cupv_dbfd *dbfd;
{
  extern char cupvconfigfile[CA_MAXPATHLEN+1];
  char func[16];
  struct sqlca sqlca;
  char db_connect[104];
  char buf[CA_MAXLINELEN+1];
  char db_user[CA_MAXLINELEN+1];
  char db_pwd[CA_MAXLINELEN+1];
  char db_srv[CA_MAXLINELEN+1];
  char db_name[CA_MAXLINELEN+1];
  char *p;
  FILE *fp;
  
  strcpy (func, "Cupv_opendb");
  EXEC SQL CONTEXT ALLOCATE :ctx[dbfd->idx];
  
  db_user[0] = db_pwd[0] = db_srv[0] = '\0';
  serrno = 0;
  if ((fp = fopen(cupvconfigfile, "r")) == NULL) {
    Cupvlogit(func, CUP23, cupvconfigfile);
    return (-1);
  }
  while (fgets(buf, sizeof(buf), fp)) {
    if (buf[0] == '#') {
      continue; /* ignore comments */
    }
    /* parse content */
    db_user[0] = db_pwd[0] = db_srv[0] = '\0';
    if ((p = strtok(buf, "/\n")) != NULL)
      strcpy (db_user, p);
    if ((p = strtok(NULL, "@\n")) != NULL)
      strcpy (db_pwd, p);
    if ((p = strtok(NULL, "/\n")) != NULL)
      strcpy (db_srv, p);
    if ((p = strtok(NULL, "\n")) != NULL)
      strcpy (db_name, p);
    else
      strcpy(db_name, "Cns_db");
  }
  fclose(fp);

  if ((db_user[0] == '\0') ||
      (db_pwd[0]  == '\0') ||
      (db_srv[0]  == '\0') ||
      (db_name[0] == '\0')) {
    Cupvlogit(func, CUP09, cupvconfigfile, "incorrect");
    return (-1);
  }

  /* connect */
  if (strlen(db_srv) > 0) {
    sprintf(db_connect, "%s/%s@%s", db_user, db_pwd, db_srv);
  } else {
    sprintf(db_connect, "%s/%s", db_user, db_pwd);
  }
  Cupvlogit(func, "attempting to connect to database\n");

  EXEC SQL CONNECT :db_connect;
  if (sqlca.sqlcode == 0) {
    dbfd->connected = 1;
  } else {
    Cupv_closedb (dbfd);
    Cupv_oracle_error (func, "CONNECT", dbfd, &sqlca);
    return -1;
  }

  return (0);
}

int Cupv_closedb(dbfd)
     struct Cupv_dbfd *dbfd;
{
  EXEC SQL ROLLBACK WORK RELEASE;
  EXEC SQL CONTEXT FREE :ctx[dbfd->idx];
  dbfd->connected = 0;
  return (0);
}

int Cupv_start_tr(s, dbfd)
     int s;
     struct Cupv_dbfd *dbfd;
{
  dbfd->tr_started = 1;
  return (0);
}

int Cupv_end_tr(dbfd)
     struct Cupv_dbfd *dbfd;
{
  EXEC SQL COMMIT WORK;
  dbfd->tr_started = 0;
  return (0);
}

int Cupv_get_privilege_entry(dbfd, priv_entry,  lock, rec_addr)
     struct Cupv_dbfd *dbfd;
     struct Cupv_userpriv *priv_entry;
     int lock;
     Cupv_dbrec_addr *rec_addr;
{
  char func[21];
  char rowid_value[19];
  int lensrc, lentgt;
  struct sqlca sqlca;

  lensrc = strlen(priv_entry->srchost);
  lentgt = strlen(priv_entry->tgthost);

  EXEC SQL DECLARE priv_cursor CURSOR FOR
    SELECT 
    U_ID, G_ID, SRC_HOST, TGT_HOST, PRIV_CAT 
    FROM USER_PRIVILEGE 
    WHERE U_ID = :priv_entry->uid 
    AND G_ID = :priv_entry->gid
    AND SRC_HOST LIKE :priv_entry->srchost 
    AND TGT_HOST LIKE :priv_entry->tgthost
    ORDER BY U_ID, G_ID, SRC_HOST, TGT_HOST;   

  EXEC SQL DECLARE priv_cursor4upd CURSOR FOR
    SELECT ROWID,
    U_ID, G_ID, SRC_HOST, TGT_HOST, PRIV_CAT 
    FROM USER_PRIVILEGE 
    WHERE U_ID = :priv_entry->uid 
    AND G_ID = :priv_entry->gid
    AND SRC_HOST LIKE :priv_entry->srchost 
    AND TGT_HOST LIKE :priv_entry->tgthost
    ORDER BY U_ID, G_ID, SRC_HOST, TGT_HOST;   

  strcpy (func, "Cupv_get_priv_entry");
  if (lock) {
    EXEC SQL OPEN priv_cursor4upd;
    if (sqlca.sqlcode) {
      Cupv_oracle_error (func, "OPEN CURSOR", dbfd, &sqlca);
      return (-1);
    }
    EXEC SQL FETCH priv_cursor4upd INTO
      :rowid_value,
      :priv_entry->uid, :priv_entry->gid, 
      :priv_entry->srchost, :priv_entry->tgthost, :priv_entry->privcat; 
 
  } else {
    EXEC SQL OPEN priv_cursor;
    if (sqlca.sqlcode) {
      Cupv_oracle_error (func, "OPEN CURSOR", dbfd, &sqlca);
      return (-1);
    }
    EXEC SQL FETCH priv_cursor INTO
      :priv_entry->uid, :priv_entry->gid, 
      :priv_entry->srchost, :priv_entry->tgthost, :priv_entry->privcat; 
  }
  switch (sqlca.sqlcode) {
  case 0:
    if (lock)
      memcpy (rec_addr, rowid_value, sizeof(rowid_value));
    return (0);
  case 1403:
    serrno = ENOENT;
    break;
  default:
    Cupv_oracle_error (func, "FETCH", dbfd, &sqlca);
    break;
  }
  return (-1);
}

int Cupv_delete_privilege_entry(dbfd, rec_addr)
     struct Cupv_dbfd *dbfd;
     Cupv_dbrec_addr *rec_addr;
{
  char func[24];
  char rowid_value[19];
  struct sqlca sqlca;

  strcpy (func, "Cupv_delete_priv_entry");
  
  memcpy (rowid_value, rec_addr, sizeof(rowid_value));
  
  EXEC SQL DELETE FROM user_privilege WHERE ROWID = :rowid_value;
  if (sqlca.sqlcode) {
    Cupv_oracle_error (func, "DELETE", dbfd, &sqlca);
    return (-1);
  }
  return (0);
}

int Cupv_insert_privilege_entry(dbfd, priv_entry)
     struct Cupv_dbfd *dbfd;
     struct Cupv_userpriv *priv_entry;
{
  char func[24];
  struct sqlca sqlca;

  strcpy (func, "Cupv_insert_priv_entry");

  EXEC SQL INSERT INTO USER_PRIVILEGE
    (U_ID, G_ID, SRC_HOST, TGT_HOST, PRIV_CAT)
    VALUES
    (:priv_entry->uid, :priv_entry->gid,
     :priv_entry->srchost, :priv_entry->tgthost, :priv_entry->privcat);
	
  switch (sqlca.sqlcode) {
  case 0:
    return (0);
  case -1:
    serrno = SEENTRYEXISTS;
    break;
  case -1631:
  case -1632:
  case -1654:
    serrno = ENOSPC;
    break;
  default:
    Cupv_oracle_error (func, "INSERT", dbfd, &sqlca);
    break;
  }
  return (-1);	
}

int Cupv_update_privilege_entry(dbfd, rec_addr, priv_entry)
     struct Cupv_dbfd *dbfd;
     Cupv_dbrec_addr *rec_addr;
     struct Cupv_userpriv *priv_entry;
{
  char func[24];
  char rowid_value[19];
  struct sqlca sqlca;
  char sqlstatement[MAXSQLSTMENTLEN +1];
  char *p;
  int nbfieldupdated = 0;
  
  strcpy (func, "Cupv_update_priv_entry");
  memcpy (rowid_value, rec_addr, sizeof(rowid_value));

  /* Building the sql statement */
  p = sqlstatement;
  
  p += sprintf(p, "UPDATE USER_PRIVILEGE SET ");
  
  if (priv_entry->privcat != -1) {
    p += sprintf(p, " PRIV_CAT = %d ", priv_entry->privcat);
    nbfieldupdated++;
  }
  if (priv_entry->srchost[0] != 0) {
    if (nbfieldupdated != 0) {
      p += sprintf(p, ", "); 
    }
    p += sprintf(p, " SRC_HOST = '%s' ", priv_entry->srchost);
    nbfieldupdated++;
  }
  if (priv_entry->tgthost[0] != 0) {
    if (nbfieldupdated != 0) {
      p += sprintf(p, ", "); 
    }
    p += sprintf(p, " TGT_HOST = '%s' ", priv_entry->tgthost);
    nbfieldupdated++;
  }
  
  /* Checing that there is a SET clause with at least one param */
  if (nbfieldupdated == 0) {
    Cupvlogit (func, "At least ONE field should be updated\n");
    serrno = SEINTERNAL;
    return(-1);
  }

  /* Adding the where clause */
  p += sprintf(p,"     WHERE ROWID = '%s' ", rowid_value);
  *p = '\0';

  Cupvlogit(func, "%s\n", sqlstatement);
  
  EXEC SQL EXECUTE IMMEDIATE :sqlstatement;
  
  switch (sqlca.sqlcode) {
  case 0:
    return(0);
  case -1631:
  case -1632:
  case -1654:
    serrno = ENOSPC;
    break;
  case 1403:
    serrno = SEENTRYNFND;
    break;
  default:
    Cupv_oracle_error (func, "MODIFY", dbfd, &sqlca);
    break;
  }
  
  return(-1);
}

int Cupv_list_privilege_entry(dbfd, bol, priv_entry, filter, endlist, dblistptr)
     struct Cupv_dbfd *dbfd;
     int bol;
     struct Cupv_userpriv *priv_entry;
     struct Cupv_userpriv *filter;
     int endlist;
     DBLISTPTR *dblistptr;
{
  char func[22];
  struct sqlca sqlca;
  int lensrc = 0, lentgt = 0;

  strcpy(func, "list_priv");

  /*    Cupvlogit(func,"FILTER: <%d> <%d> <%s> <%s> <%d>\n", filter->uid, filter->gid, */
  /*  	    filter->srchost, filter->tgthost, filter->privcat); */

  lensrc = strlen(filter->srchost);
  lentgt = strlen(filter->tgthost);
	
  EXEC SQL DECLARE list_priv_cursor CURSOR FOR 
    SELECT 
    U_ID, G_ID, SRC_HOST, TGT_HOST, PRIV_CAT 
    FROM USER_PRIVILEGE 
    WHERE ( (:filter->uid = -1) OR (U_ID = :filter->uid)) 
    AND  ( (:filter->gid = -1) OR (G_ID = :filter->gid)) 
    AND  ( ( :lensrc = 0) OR (SRC_HOST LIKE :filter->srchost)) 
    AND  ( ( :lentgt = 0) OR (TGT_HOST LIKE :filter->tgthost))   
    AND  ( (:filter->privcat = -1) OR (PRIV_CAT = :filter->privcat)) 
    ORDER BY U_ID, G_ID, SRC_HOST, TGT_HOST;   

  strcpy (func, "Cupv_list_priv_entry");
  if (endlist)
    return (1);
  if (bol) {
    EXEC SQL OPEN list_priv_cursor;
    if (sqlca.sqlcode) {
      Cupv_oracle_error (func, "OPEN CURSOR", dbfd, &sqlca);
      return (-1);
    }
  }
  
  EXEC SQL FETCH list_priv_cursor INTO 
    :priv_entry->uid, :priv_entry->gid, 
    :priv_entry->srchost, :priv_entry->tgthost, :priv_entry->privcat; 

  switch (sqlca.sqlcode) {
  case 0:
    return (0);
  case 1403:
    return (1);
  default:
    Cupv_oracle_error (func, "FETCH", dbfd, &sqlca);
    return (-1);
  }
}

