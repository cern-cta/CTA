#!/bin/bash

# @project      The CERN Tape Archive (CTA) - NooBaa Integration  
# @copyright    Copyright Â© 2024 CERN
# @license      This program is free software, distributed under the terms of the GNU General Public
#               Licence version 3 (GPL Version 3), copied verbatim in the file "COPYING".

# Simplified NooBaa NSFS Glacier migrate executable
# Based on working manual curl command
# Input: File containing list of files to archive
# Output: eeadm migrate-compliant format

set -eo pipefail

# Configuration
EOS_MGM_HOST="eos-mgm-0.eos-mgm.dev.svc.cluster.local"
EOS_PORT="8443"
TOKEN_CACHE_FILE="/tmp/eos_power_token"

# Counters
TOTAL_FILES=0
SUCCEEDED_FILES=0
FAILED_FILES=0

# Logging function
log() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') [MIGRATE] $*"
}

# Get token from cache file
get_token() {
    if [[ ! -f "${TOKEN_CACHE_FILE}" ]]; then
        log "ERROR: Token cache file not found: ${TOKEN_CACHE_FILE}"
        return 1
    fi
    
    local cached_token
    cached_token=$(cat "${TOKEN_CACHE_FILE}")
    echo "${cached_token}" | cut -d: -f2-
}

# Archive single file using working curl command
archive_file() {
    local file_path="$1"
    
    log "Processing file: ${file_path}"
    
    # Check if file exists and is readable
    if [[ ! -f "${file_path}" ]] || [[ ! -r "${file_path}" ]]; then
        echo "FAILED ${file_path} File not readable or does not exist"
        return 1
    fi
    
    # Get token
    local token
    token=$(get_token) || {
        echo "FAILED ${file_path} Could not get valid token"
        return 1
    }
    
    # Generate archive path 
    local archive_path="/eos/ctaeos/preprod/$(basename "${file_path}")"
    
    log "Uploading to: ${archive_path}"
    
    # Use exact working curl command
    local upload_response
    upload_response=$(curl -L --insecure \
        -H "Accept: application/json" \
        -H "Authorization: Bearer ${token}" \
        --upload-file "${file_path}" \
        "https://${EOS_MGM_HOST}:${EOS_PORT}${archive_path}" 2>&1)
    
    local curl_exit_code=$?
    
    log "Upload response: ${upload_response}"
    
    # Check for success (curl exit code 0 and no error messages)
    if [[ ${curl_exit_code} -eq 0 ]] && [[ ! "${upload_response}" == *"Unable to"* ]] && [[ ! "${upload_response}" == *"Operation not permitted"* ]]; then
        log "Upload successful, polling archiveinfo endpoint for archival status"
        
        # Poll archiveinfo endpoint to validate archival
        local archive_filename
        archive_filename=$(basename "${file_path}")
        local max_attempts=30
        local attempt=1
        local archived=false
        
        while [[ ${attempt} -le ${max_attempts} ]]; do
            log "Archival check attempt ${attempt}/${max_attempts} for ${archive_filename}"
            
            local archiveinfo_response
            archiveinfo_response=$(curl -L --insecure \
                -H "Accept: application/json" \
                -H "Authorization: Bearer ${token}" \
                "https://${EOS_MGM_HOST}:${EOS_PORT}/api/v1/archiveinfo/" \
                -d "{\"paths\":[\"${archive_path}\"]}" 2>&1)
            
            local archiveinfo_exit_code=$?
            
            if [[ ${archiveinfo_exit_code} -eq 0 ]] && [[ "${archiveinfo_response}" == *'"locality" : "TAPE"'* ]]; then
                log "File successfully archived to tape: ${archive_filename}"
                archived=true
                break
            else
                log "File not yet archived (attempt ${attempt}): ${archiveinfo_response}"
                sleep 10
            fi
            
            attempt=$((attempt + 1))
        done
        
        if [[ "${archived}" == "true" ]]; then
            echo "COMPLETED ${file_path} File successfully uploaded and archived to tape"
            SUCCEEDED_FILES=$((SUCCEEDED_FILES + 1))
            return 0
        else
            echo "FAILED ${file_path} File uploaded but archival validation failed after ${max_attempts} attempts"
            FAILED_FILES=$((FAILED_FILES + 1))
            return 1
        fi
    else
        echo "FAILED ${file_path} Upload failed - ${upload_response}"
        FAILED_FILES=$((FAILED_FILES + 1))
        return 1
    fi
}

# Process file list
process_files() {
    local file_list="$1"
    
    if [[ ! -f "${file_list}" ]]; then
        log "ERROR: File list not found: ${file_list}"
        return 1
    fi
    
    log "Processing file list: ${file_list}"
    
    while IFS= read -r file_path; do
        # Skip empty lines and comments
        [[ -z "${file_path}" ]] || [[ "${file_path}" =~ ^[[:space:]]*# ]] && continue
        
        log "Read file from list: '${file_path}'"
        TOTAL_FILES=$((TOTAL_FILES + 1))
        log "Total files counter: ${TOTAL_FILES}"
        
        if archive_file "${file_path}"; then
            log "Successfully processed: ${file_path}"
        else
            log "Failed to process: ${file_path}"
        fi
    done < "${file_list}"
    
    log "Finished processing file list, total files: ${TOTAL_FILES}"
}


# Main function
main() {
    local file_list="${1:-}"
    
    if [[ -z "${file_list}" ]]; then
        log "Usage: $0 <file_list>"
        echo "If necessary press ^D to continue."
        exit 1
    fi
    
    log "Starting migration process for files in: ${file_list}"
    
    # Process files
    process_files "${file_list}"
    
    # Output summary
    
    log "Migration process completed"
    log "Summary: ${SUCCEEDED_FILES}/${TOTAL_FILES} files successfully processed"
    
    # Exit with error code if any files failed
    [[ ${FAILED_FILES} -eq 0 ]]
}

# Run main function
main "$@"
