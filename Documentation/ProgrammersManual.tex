\chapter*{Preface}
\addcontentsline{toc}{chapter}{Preface}

The Tape server project is targeted at replacing the CAStor tape server with a new drop-{}in reimplementation. The reimplementation will replace a legacy implementation that is written in C.

The reimplementation will be done using the latest tools available to us in the current Scientific Linux distribution. The language will be C++, to group concept and variables in self-contained
(and unit testable) objects.

The interface to the mounting deamons might still change with repect to CAStor 2.1.14 as the mounting daemons are being reviewed in parallel.

This documentation itself currently references the older tape server this project is intending to replace. The references will have to be removed as they become unnecessary. 
Likewise, the layout of the document will be adapted.

The tape drive primitives have now been developed, and the rest of the project's
plan is being laid out.

% ------------------------------------------------------------------------------ 
% Chapter: Developer's manual
% ------------------------------------------------------------------------------

\chapter{Developer's manual}

% Section:  Targeted environment
% ------------------------------------------------------------------------------

\section{Targeted environment}

CERN SLC5 and SLC6, 64bits. Although it should compile in theory, the 32 bits version is not tested. The unit test purposely returns an error when run on non-64 bits architecture.


% Section:  Reference documentations
% ------------------------------------------------------------------------------

\section{Reference documentations}
\subsection{SCSI specifications}

The SCSI commands can be found in the SCSI section of Hackipedia.org
      \footnote{ \href{http://hackipedia.org/Hardware/SCSI/}{http://hackipedia.org/Hardware/SCSI/} }
      \footnote{The official site for SCSI standard is \href{http://T10.org}{http://T10.org}. All specifications
      can be found there in their approved version, but behind a paywall. Nevertheless all previous drafts were
      public and can conveniently be found on the web. Hackipedia hold a very nice collection of such
      documentations.}.
 The most significant documents for tape server development are the SCSI stream commands (SSC-3
      \footnote{ \href{http://hackipedia.org/Hardware/SCSI/Stream\%20Commands/SCSI\%20Stream\%20Commands\%20-\%203.pdf}
                      {http://hackipedia.org/Hardware/SCSI/Stream\%20Commands/SCSI\%20Stream\%20Commands\%20-\%203.pdf} })
 and the SCSI primary commands (SPC-4
      \footnote{ \href{http://hackipedia.org/Hardware/SCSI/Primary\%20Commands/SCSI\%20Primary\%20Commands\%20-\%204.pdf}
                      {http://hackipedia.org/Hardware/SCSI/Primary\%20Commands/SCSI\%20Primary\%20Commands\%20-\%204.pdf} }).

\subsubsection{Manufacturer's specificities}
\label{Manufacturer's specificities}
The SCSI specification allows for some flexibility for the manufacturers of tape drives, and 
each of them has differences. The details can be found in the following documentations:

\begin{itemize}
\item{}StorageTek\texttrademark T10000 Tape Drive
       \footnote{ \href{http://docs.oracle.com/cd/E19957-01/96174E/96174E.pdf}
                       {http://docs.oracle.com/cd/E19957-01/96174E/96174E.pdf} }
\item{}Sun StorageTek\texttrademark T10000 Tape Drive Fibre Channel Interface Reference Manual
       \footnote{ \href{http://docs.oracle.com/cd/E19772-01/MT9259L/MT9259L.pdf}
                       {http://docs.oracle.com/cd/E19772-01/MT9259L/MT9259L.pdf} }
\item{}IBM System Storage TS1120 and TS1130 Tape Drives and TS1120 ControllerOperator Guide3592 Models J1A, E05, E06, EU6, J70 and C06
       \footnote{ \href{ftp://ftp.software.ibm.com/storage/TS1130/a86opg02.pdf}
                       {ftp://ftp.software.ibm.com/storage/TS1130/a86opg02.pdf} }
\item{}IBM System Storage Tape Drive 3592 SCSI Reference
       \footnote{ \href{http://www-01.ibm.com/support/docview.wss?uid=ssg1S7003248\&aid=1}
                       {http://www-01.ibm.com/support/docview.wss?uid=ssg1S7003248\&aid=1} }
\item{}IBM TotalStorage LTO Ultrium Tape Drive SCSI Reference  (LTO-5 through LTO-6)
       \footnote{ \href{http://www-01.ibm.com/support/docview.wss?uid=ssg1S7003556\&aid=1}
                       {http://www-01.ibm.com/support/docview.wss?uid=ssg1S7003556\&aid=1} }
\end{itemize}

\subsection{SCSI support in Linux}
On the Linux side, the main references are the Linux 2.4 SCSI subsystem HOWTO
       \footnote{ \href{http://mirrors.kernel.org/LDP/HOWTO/pdf/SCSI-2.4-HOWTO.pdf}
                       {http://mirrors.kernel.org/LDP/HOWTO/pdf/SCSI-2.4-HOWTO.pdf} },
especially for its section 9.3 on the st driver,
and the Linux SCSI Generic (sg) HOWTO 
       \footnote{ \href{http://mirrors.kernel.org/LDP/HOWTO/pdf/SCSI-Generic-HOWTO.pdf}
                       {http://mirrors.kernel.org/LDP/HOWTO/pdf/SCSI-Generic-HOWTO.pdf} }. 

More details regarding the Generic SCSI driver can be found on the SCSI subsystem maintainer's web site 
       \footnote{ \href{http://sg.danny.cz/sg/}{http://sg.danny.cz/sg/} }.

The section on the SG\_IO ioctl, \footnote{ \href{http://sg.danny.cz/sg/sg\textunderscore{}io.html}{http://sg.danny.cz/sg/sg\textunderscore{}io.html} } details the usage of the 
simplest ioctl for the generic SCSI driver, which allows the invocation of a SCSI command and the collection of the 
result in a single system call.

This ioctl is provided in the middle layer of the SCSI subsystem of Linux. All SCSI drivers, st included, fall back
to the middle layer when encountering an unknown ioctl. This means there is no need to open the matching generic SCSI,
unless we want to control command queueing with separate sending of commands and result collection, which
requires the use of read and write calls from the generic SCSI (sg) driver.

\subsection{Unsorted CAStor docs}
A collection of links to various documentations written in the past is available on one of CAStor's web pages
       \footnote{ \href{http://castorwww.web.cern.ch/castorwww/links.htm}{http://castorwww.web.cern.ch/castorwww/links.htm} }.

\subsection{SCSI tape support in Linux (st driver)}
Generic SCSI allows detailed control of the operations, but the bulk of them (including reading and
writing) can be managed by the higher level SCSI tape (or st) driver provided by the Linux kernel.
More information on the st driver can be found in the man page "st" and in \verb#Documentation/scsi/st.txt#
in the sources of the kernel.

\section{Tools used during development}
\subsection{Required tools for build}
\begin{itemize}
\item{}GCC/G++ (Basic SLC version)
\item{}CMake (Basic SLC version)
\item{}rpmbuild (Basic SLC version)
\item{}Google Mock/Google test (GTest is provided in EPEL repository for SLC. 
  GMock requires recompilation. The source RPMs can be found for newer versions of RPM based distributions, for example from rpmfind 
  \footnote{ \href{http://rpmfind.net/linux/rpm2html/search.php?query=gmock}{http://rpmfind.net/linux/rpm2html/search.php?query=gmock} }.
 For convenience, 
  they are also available on AFS as a temporary solution
      \footnote{ \href{file:///afs/cern.ch/user/c/canoc3/public/GoogleTest-Mock}{/afs/cern.ch/user/c/canoc3/public/GoogleTest-Mock} }.
\item{}Valgrind (Basic SLC version)
\item{}\LaTeX (Basic SLC version) to compile this document
\item{}Doxygen for code documentation (Basic SLC version)
\end{itemize}

\subsection{Tools used during development}
\begin{itemize}
\item{}mhvtl \footnote{ \href{https://sites.google.com/site/linuxvtl2/}{https://sites.google.com/site/linuxvtl2/} } for developing against virtual drives and libraries.
\item{}TeamCity for continuous integration
\item{}NetBeans as an IDE, including for remote development\
\end{itemize}

\subsection{Code coverage using lcov}
Although the code coverage is not integrated in the build process, it is
straightforward to run on the code. The following recipe will deliver a set of 
web pages indicating which parts of the code are covered or not in the unit tests.
The lcov package is required. It is only available on SLC6, and can be installed via yum.
\begin{itemize}
\item{}Change the main CMakeFiles.txt as in this diff:
\begin{small}
\begin{verbatim}
Index: CMakeLists.txt
===================================================================
--- CMakeLists.txt      (revision 76)
+++ CMakeLists.txt      (working copy)
@@ -45,7 +45,8 @@
 ###########################################################################
 # compiler options
 ###########################################################################
-set (CMAKE_CXX_FLAGS "-g3 -Wall -Werror -pedantic -O2")
+set (CMAKE_CXX_FLAGS "-g3 -Wall -Werror -pedantic -O2 --coverage")
+set (CMAKE_LD_FLAGS "--coverage")

 ###########################################################################
 # dependancies
\end{verbatim}
\end{small}

\item{}Re-run cmake, recompile as usual and run the unit test.
\item{}Capture the result:

        \small{}\verb#lcov --capture --directory 00build/ --output-file 00build/coverage.info#.
\item{}\normalsize{}Generate the resulting html pages: 
        
        \small{}\verb#genhtml 00build/coverage.info --output-directory 00build/coverage#.
\end{itemize}

\section{Software layout}

\subsection{SCSI structures, constants and endianness}

In order to make the code readable, and to avoid heavy mask-and-shift usage (which one would tend
to code using litterals in order to avoid many constants definitions), we use bit field structures.
The unused fields can be left anonymous.
The definition is shown in listing \ref{SCSI_struct}, and usage in listing \ref{SCSI_struct_usage}.
As there could be endianness issues, we limit this usage to within bytes. Fortunately, the SCSI 
standard nicely adheres to this rule.

\begin{table}[h]
\begin{lstlisting}[caption=SCSI::Structures example,label=SCSI_struct]
namespace SCSI {
  namespace Structures {

    /*
     * Inquiry data as described in SPC-4.
     */
    typedef struct {
      unsigned char perifDevType : 5;
      unsigned char perifQualifyer : 3;

      unsigned char : 7;
      unsigned char RMB : 1;

      unsigned char version : 8;

      unsigned char respDataFmt : 4;
      unsigned char HiSup : 1;
      unsigned char normACA : 1;
      unsigned char : 2;
[...]
    } inquiryData_t;
  }
}
\end{lstlisting}
\end{table}

\begin{table}[h]
\begin{lstlisting}[caption=SCSI::Structures usage example,label=SCSI_struct_usage]
      SCSI::Structures::inquiryData_t & inq = *((SCSI::Structures::inquiryData_t *) dataBuff);
      std::stringstream inqDump;
      inqDump << std::hex << std::showbase << std::nouppercase
              << "inq.perifDevType=" << (int) inq.perifDevType << std::endl
              << "inq.perifQualifyer=" << (int) inq.perifQualifyer << std::endl
[...]
              << "inq.T10Vendor="      << SCSI::Structures::toString(inq.T10Vendor) << std::endl
              << "inq.prodId="         << SCSI::Structures::toString(inq.prodId) << std::endl
              << "inq.prodRevLv="      << SCSI::Structures::toString(inq.prodRevLvl) << std::endl
              << "inq.vendorSpecific1="<< SCSI::Structures::toString(inq.vendorSpecific1)<< std::endl
\end{lstlisting}
\end{table}

The unit test resorts to shift and mask, once and only once, to validate the bit fields in
another way. There is an example for this validation in \verb#SCSI/StructureTest.cc# an excerpt is in listing \ref{SCSI_struct_testing}.

\begin{table}
\begin{lstlisting}[caption=SCSI::Structures usage example,label=SCSI_struct_testing]
namespace UnitTests {
  TEST(SCSI_Structures, inquiryData_t_multi_byte_numbers_strings) {
    /* Validate the bit field behavior of the struct inquiryData_t,
     which represents the standard INQUIRY data format as defined in 
     SPC-4. This test also validates the handling of multi-bytes numbers,
     as SCSI structures are big endian (and main development target is 
     little endian.  */
    unsigned char inqBuff [100];
    memset(inqBuff, 0, sizeof(inqBuff));
    SCSI::Structures::inquiryData_t & inq = *((SCSI::Structures::inquiryData_t *) inqBuff);
    /* Peripheral device type */
    ASSERT_EQ(0, inq.perifDevType);
    inqBuff[0] |= (0x1A & 0x1F) << 0;
    ASSERT_EQ(0x1A, inq.perifDevType);
    
    /* Peripheral qualifier */
    ASSERT_EQ(0, inq.perifQualifyer);
    inqBuff[0] |= (0x5 & 0x7) << 5;
    ASSERT_EQ(0x5, inq.perifQualifyer);
[...]
  }
}
\end{lstlisting}
\end{table}

Other common types in the SCSI specification are multi-bytes
number, which are represented by \verb#unsigned char[2/* (or 4)*/]# and handled by helper functions 
\verb#toU16()# and \verb#toU32()#. The helper functions
conveniently use \verb#ntoh{l|s}#, as SCSI and network orders are the same. The reverse
is covered by \verb#setU16()# and \verb#setU32()#. Another helper function 
takes care of string extraction from fixed sized char arrays. See listing \ref{SCSI_data_helpers}.

\begin{table}
\begin{lstlisting}[caption=SCSI::Structures helper functions,label=SCSI_data_helpers]
SCSI::Structures::uint32_t toU32(const char(& t)[4]);
SCSI::Structures::uint32_t toU32(const char(& t)[4]);

template <size_t n>
std::string toString(const char(& t)[n]);
\end{lstlisting}
\end{table}

Those arrays are space-padded, and may not be 0 terminated. It is seen in listing \ref{SCSI_struct_usage}.
The helper function extracts the string, dealing with potential zeros at the end,
and the fixed length. They keep the space-padding at the end of the extracted
string.

To avoid literals in the code, which forces anyone reading it to do tedious lookups,
the SCSI constants are also defined as constants in the code. See listing \ref{SCSI_consts}.

\begin{table}
\begin{lstlisting}[caption=SCSI::Constants,label=SCSI_consts]
namespace SCSI {
  class Commands {
  public:
    enum {
      /*
       *      SCSI opcodes, taken from linux kernel sources
       *      Linux kernel's is more complete than system's
       *      includes.
       */
      TEST_UNIT_READY                               = 0x00,
      REZERO_UNIT                                   = 0x01,
      REQUEST_SENSE                                 = 0x03,
[...]
\end{lstlisting}
\end{table}

Finally all structures have a constructor, which at least zeroes all the data.
Some structures (typically the CDBs, where the first byte is the operation's code)
automatically set the value of fields which can only have one value. Helper
functions are created as needed, where accessing/setting the data in the structure
requires non-trivial processing (and when the case is not covered by the common
tools handling strings that endianness).

\subsection{Exceptions hierarchy and error handling strategy}

There is a small class hierarchy for exceptions: \verb#Tape::Exception# inherits from
\verb#std::exception#, and \verb#Tape::Exceptions::Errnum# inherits from the latter.
\verb#Tape::Exceptions::Errnum# manages the errnos. It collects the errno value and turns it
into a string automatically at construction time.

\verb#Tape::Exception# and all its heirs automatically generate a stack trace at creation time.
This allows easy tracing of unhandled exceptions, as the stack trace is embedded in the content
of the \verb#what()# method. For the cases where the exception is indeed handled, a shorter version
called \verb#shortWhat()# allows the logging of the problem without bloating the logs with long stack 
traces.

Another exception class, \verb#SCSI::Exception#, turns the SCSI status and sense buffer into a
user readable string. In addition, a helper exception thrower function avoids code
repetitions (\verb#ExceptionLauncher()#).

Throughout the project, the error handling strategy is to throw an exception when any
error condition occurs. This ensures that any returned value is valid, and prevents the 
calling function from testing for error conditions. The default exception throwing is
coming from a narrow set of exceptions types. This gives a crude exception handling capacity
to the user of the functions. When finer grained exceptions will turn out to be required,
we will add them on an as needed basis.

\subsection{Non-fatal warnings strategy}
\label{Non-fatal warnings strategy}


We want to deliver an interface, preferably common, to most object where the non-fatal
problems are recorded (with time of occurrence) and stored for further retrieval by
upstream caller. This allow developers to deal with the logging interface only in the 
top "application" class which glues all the bricks of the project together.

A lower level failure (exception) could also be turned into a warning by a higher level
retry.

TODO: define API.

\subsection{The Tape::Drive object}

This first deliverable is a tape drive object. This tape drive object abstracts all
SCSI and technical details and provides a high level interface, to be used by the 
file structure layer.

It will provide as much data safety as possible by blocking writes in situations
where they are not safe (to be defined in details, but the most obvious is right
after positioning, as the file layer is expected to check the position by reading
the trailer of the previous file before writing.

The SCSI commands and st driver's functions used in previous software (CAStor's taped/rtcpd) are:
\begin{itemize}
\item Individual SCSI commands sent using generic SCSI:
  \begin{itemize}
    \item Read status (inquiry SCSI command used by posovl)
    \item Read serial number (inquiry SCSI command, asking for vital product data page 0x80)
    \item Locate (locate(10) SCSI command: 32 bits logical object identifiers)
                      \footnote{There is also a locate(16) command allowing 64 bis addresses.
                      This might become necessary as tapes grow. Discounting the per-file overhead,
                      with 256kB block, it still takes 1PB to get $2^{32}$ blocks.}
    \item Read position (read position SCSI command -- short form): get the current logical object
          location (a.k.a. block ID).
    \item Log select (for clearing compression stats page. The function clear\_compression\_stats
          actually does a blanket reset of all statistics. It sets the PCR/SP/PC combination
          to 1/0/3. The basic SCSI specification states that the value pf PC is not important,
          but for the IBM drives, the documentation recommends PC=11b, which we have for all drives.
    \item Log sense, to read the compression pages. This is device dependant. The code covers
          5 blocks of device types: DAT, DLT-SDLT-LTO, IBM(3490, 3590, 3592), StorageTek RedWood(SD3),
          StorageTek(9840, 9940, T10000).
    \item Log sense for page 0x2E (tape alert, as defined in SSC-3) on all modern tape drives to detect tape alerts.
    \item Mode sense was used in setdens called itself by mounttape. It sets density and compression
          parameters based on the drive type and the density requested by the caller. On all modern tape drives,
          the compression page is 0x10. This will be replaced by the function \verb#Tape::Drive::setCompressionAndDensity()#.
          Some work is still needed to fully understand the original function.
  \end{itemize}
\item st driver's commands, leading to internal variables setting or SCSI actions:
  \begin{itemize}
    \item Get internal driver state via the MTIOCGET ioctl (for drive ready, write protection, 
          get some error condition, when MTIOSENSE failed, to get the EOD, BOT bits (readlbl)).
          This functionality is covered by \verb#Drive::getDriveStatus#.
    \item Try and get the sense data for the last-ish command with MTIOSENSE. This
          relies on a CERN-made patch. As the patch is not available in SLC6, 
          MTIOSENSE will not be used in this project. This is also covered \verb#Drive::getDriveStatus#.
    \item Setup the driver's parameters (MTIOCTOP/MTSETDRVBUFFER) for (un)buffered 
          writes and asynchronous writes (in confdrive, a child process of taped).
          This option is currently not set in production environments.
    \item Jump to end of media (before rewinding, as a mean to rebuild the MIR) (MTIOCTOP/MTEOM, 
          with some MTIOCTOP/MTSETDRVBUFFER before, in repairbadmir). The setting of the driver
          buffer is used to set the boolean flag MT\_ST\_FAST\_MTEOM to 0. If not, the mt driver uses
          a nasty trick asks the device to skip 0x7fffff files forward. The comment in the CAStor code
          claims it's 32k files, but $2^{23}-1$ is indeed 8M files. Anyway, after turning off the 
          option, the st driver reverts to telling the SCSI device to space to end of data.
          This behavior is documented in the IBM's operator manual mentioned in \ref{Manufacturer's specificities},
          on page 53 for tape alert 18 (Tape directory corrupted on load).

          It is not mentioned for other tape server's documentations. Specifically, StorageTek
          only lists operator-initiated methods for MIR rebuild.

          Nevertheless, we will still issue this operation in all drives as it is not known
          if it works in practice for StorageTek drives (or others).
    \item Rewind (MTIOCTOP/MTREW, in rwndtape).
    \item Skip to end of data (MTIOCTOP/MTEOM, in skip2eod, without the trick of repairbadmir).
    \item Skip n file marks backwards (MTIOCTOP/MTBSF, in skiptpfb).
    \item Skip n file marks forward (MTIOCTOP/MTFSF, in skiptpff).
    \item Skip n file marks forward (MTIOCTOP/MTFSF, in skiptpfff). skiptpfff and skiptpff differ only 
          by error reporting. Both functions exists since CAStor has been put in SVN (20/07/1999)
    \item Skip n blocks backwards (MTIOCTOP/MTBSR, in skiptprb).
    \item Skip n blocks forward (MTIOCTOP/MTFSR, in skiptprf).
    \item Unload the tape (MTIOCTOP/MTOFFL, in unldtape).
    \item Write synchronous file mark(s) (tape marks in CAStor jargon) (MTIOCTOP/MTWEOF, in wrttpmrk).
    \item Write immediate (asynchronous file marks (MTIOCTOP/MTWEOFI, also in wrttpmrk).
    \item Clear the EOT condition by calling MTIOCGET. This is done in wrttrllbl, 3 times.
          In MTIOCGET, indeed, a member of the scsi\_tape structure called recover\_reg is reset to 0.
          This clearing is used to properly report errors in label writing functions.
          The usefulness of this function is dubious and it is not included in the current
          API.
    \item Write is used in 2 places only : twrite and writelbl (which is a specialized 
          function to write 80 bytes blocks). twrite is not checking the size of blocks,
          which is determined in the calling functions.
    \item Read is used in tread, which is used in a single place of TapeToMemory. It is 
          also used in readlbl. The latter uses a trick to detect that a tape is blank.
          This could be turned into a specialized function.
  \end{itemize}
\end{itemize}

The interface is shown in listing \ref{drive_if}.

TODO: define end of tape behavior for write (create an exception, and throw it).

TODO: define how detect a blank tape.

\begin{table}
\begin{lstlisting}[caption=Tape::Drive interface,label=drive_if]
namespace Tape {
  class Drive {
  public:
    Drive(SCSI::DeviceInfo di, System::virtualWrapper & sw);
    /* Direct SCSI operations */
    virtual compressionStats getCompression() throw (Exception);
    virtual void clearCompressionStats() throw (Exception);
    virtual deviceInfo getDeviceInfo() throw (Exception);
    virtual std::string getSerialNumber() throw (Exception);
    virtual void positionToLogicalObject(uint32_t blockId) throw (Exception);
    virtual positionInfo getPositionInfo() throw (Exception);
    virtual std::vector<std::string> getTapeAlerts() throw (Exception);
    virtual void setDensityAndCompression(unsigned char densityCode = 0,
            bool compression = true) throw (Exception);
    virtual driveStatus getDriveStatus() throw (Exception);
    virtual tapeError getTapeError() throw (Exception);
    /* ST driver based operations */
    virtual void setSTBufferWrite(bool bufWrite) throw (Exception);
    virtual void fastSpaceToEOM(void) throw (Exception);
    virtual void rewind(void) throw (Exception);
    virtual void spaceToEOM(void) throw (Exception);
    virtual void spaceFileMarksBackwards(size_t count) throw (Exception);
    virtual void spaceFileMarksForward(size_t count) throw (Exception);
    virtual void spaceBlocksBackwards(size_t count) throw (Exception);
    virtual void spaceBlocksForward(size_t count) throw (Exception);
    virtual void unloadTape(void) throw (Exception);
    virtual void sync(void) throw (Exception);
    virtual void writeSyncFileMarks(size_t count) throw (Exception);
    virtual void writeImmediateFileMarks(size_t count) throw (Exception);
    virtual void writeBlock(const unsigned char * data, size_t count) throw (Exception);
    virtual void readBlock(unsigned char * data, size_t count) throw (Exception);
    virtual ~Drive()
  };
} // namespace Tape
\end{lstlisting}
\end{table}

\subsection{The Tape::File class}

\subsubsection{CAStor file format}
Over time, CAStor used several file formats, but as of 2013, only one file format
is used, called AUL. This format is described an old CERN web site
\footnote{ \href{http://it-dep-fio-ds.web.cern.ch/it-dep-fio-ds/Documentation/tapedrive/labels.html}{http://it-dep-fio-ds.web.cern.ch/it-dep-fio-ds/Documentation/tapedrive/labels.html} },
and the general description of the ANSI fields can be found in IBM's z/OS documentation
\footnote{ \href{http://publib.boulder.ibm.com/infocenter/zos/v1r12/index.jsp?topic=\%2Fcom.ibm.zos.r12.idam300\%2Flabdef.htm}{http://publib.boulder.ibm.com/infocenter/zos/v1r12/index.jsp?topic=\%2Fcom.ibm.zos.r12.idam300\%2Flabdef.htm} }.

The AUL format consists of volume label, header blocks and trailer blocks. All those
descriptors are contained in tape blocks of 80 kilobytes. All data is in ASCII nowadays.

The structure of the volume label is:

\begin{center}
\begin{tabularx}{\textwidth}{ |c|X| }
  \hline
  \multicolumn{2}{|c|}{VOL1} \\
  \hline
  Bytes & \multicolumn{1}{c|}{Content} \\
  \hline \hline
  0-3 & Volume label indicator: the caracters "VOL1" \\
  \hline
  4-9 & Volume serial number (VSN) (ex: "AB1234") \\
  \hline
  10 (0x0A) & Accessibility (In CAStor, left as space) \\
  \hline
  11-23 (0x0B-0x17) & Reserved for future (spaces) \\
  \hline
  24-36 (0x18-0x24) & Implementation identifier (left as spaces by CAStor) \\
  \hline
  37-50 (0x25-0x32) & Owner identifier (in CAStor, the string "CASTOR" padded with spaces)\\
  \hline
  51-78 (0x33-0x4E) & Reserved (spaces) \\
  \hline
  79 (0x4F) & Label standard level (1,3 and 4 are listed as valid in IBM's documentation. CAStor uses ASCII '3') \\
  \hline

\end{tabularx}
\end{center}

TODO: finish the descriptions (remaining: HDR1, HDR2, UHL1, EOF1, EOF2, UTL1).

\subsubsection{File block management}

Some files tapes have mixed block sizes,
some files used to have mixed block sizes. Current proposal is to have a fixed
block size per tape, and to have operators choose the optimal block size for 
drive performance (too small blocks reduce performance). 

Currently 256kB is used everywhere, so hardcoding this block size for writing 
to this value is an acceptable for the time being. On the long run, this should 
be a configurable parameter by the operators.

Ideally, only the Tape::File class should handle all aspects of cutting the disk
file, which is a continuous stream, into fixed size blocks. But this would have the 
downside of having the Tape::File class a client of the FIFOs, and potentially 
have its own thread, which is far beyond the scope of this class. Therefore, it 
is the duty of the caller to provide the file cut into fixed size blocks.
The Tape::File class will require pre-declaration of the block size, and 
enforce it.

\subsubsection{Responsibilities of the class}
This class will have the responsibility to check file structure and content,
including checksum, block sizes and header/trailer content. In case of non-fatal
errors, the warnings will be reported through the warning interface described in
\ref{Non-fatal warnings strategy}.

\subsubsection{Checksums}
The checksum in CAStor uses the Adler32 checksum. Adler32 can be computed 
incrementally on a stream of data. The zlib contains an implementation of adler32
\footnote{\href{http://www.zlib.net/manual.html\#Checksum}{http://www.zlib.net/manual.html\#Checksum}}.
The checksum will be computer automatically when writing or reading the file to
tape. Reading a file with a wrong checksum will throw an exception.
TODO: define writing behavior (is the checksum pre-declared?).

\subsubsection{Tape::File API}
TODO.

\subsection{Memory chunk manager}

The memory block manager allocates (usually all at once) a large chunk of memory.
This memory is then shared between the various FIFOs in the system. Deallocation
of memory on exit will allow memory leak checks. This class will have to be 
thread safe.

TODO: Define API.

\subsection{FIFOs}

FIFOs will be used to synchronize the data transfer between the tape thread and 
disk threads. The Tape thread will manage the block-to-stream transformation. The
FIFO might not always be able to provide blocks in one piece at chunk boundary.
The first attempt solution for this case will be a copy of the cut block. With
a chunk size significantly bigger than the block size, the event should be rare
enough to not affect performance. FIFOs will probably need some thread safety,
but as they will be single user, single consumer, some parts might possible 
be lockless.

\subsection{Disk client library}

\subsection{VDQM client library}

TODO: describe how we will link with the VDQM client library. The VDQM is also 
the initial client which triggers the tape sessions. It carries a feature
where the tape drive can recycle a tape mount. This is not very useful today,
and the first release of the TapeServer will not support it. All sessions
will be force-closed by the TapeServer.

\subsection{VMGR client library}

\subsection{Stager/TapeGateway client library}

\subsection{Logging system client library}

\subsection{Application architecture}

\subsubsection{Session spawner}

\subsubsection{Session process}

\subsubsection{Tape read thread}

\subsubsection{Tape write thread}

\subsubsection{Disk read thread}

\subsubsection{Disk write thread}


