\chapter*{Preface}
\addcontentsline{toc}{chapter}{Preface}

The Tape server project is targeted at replacing the CAStor tape server with a new drop-{}in reimplementation. The reimplementation will replace a legacy implementation that is written in C.

The reimplementation will be done using the latest tools available to us in the current Scientific Linux distribution. The language will be C++, to group concept and variables in self-contained
(and unit testable) objects.

The interface to the mounting deamons might still change with repect to CAStor 2.1.14 as the mounting daemons are being reviewed in parallel.

This documentation itself currently references the older tape server this project is intending to replace. The references will have to be removed as they become unnecessary. 
Likewise, the layout of the document will be adapted.

The initial focus is to provide access to the tape drive primitives, so the current version of this documentation is limited to this subject.

% ------- 
% Chapter 
% ------- 

\chapter{Developer's manual}

\section{Targeted environment}

CERN SLC5 and SLC6, 64bits. Although it should compile in theory, the 32 bits version is not tested. The unit test purposely returns an error when run on non-64 bits architecture.

\section{Reference documentations}
\subsection{SCSI specifications}

The SCSI commands can be found in the SCSI section of hackipedia
      \footnote{ \href{http://hackipedia.org/Hardware/SCSI/}{http://hackipedia.org/Hardware/SCSI/} }.
 The most significant documents for tape server development are the stream commands
      \footnote{ \href{http://hackipedia.org/Hardware/SCSI/Stream\%20Commands/SCSI\%20Stream\%20Commands\%20-\%203.pdf}
                      {http://hackipedia.org/Hardware/SCSI/Stream\%20Commands/SCSI\%20Stream\%20Commands\%20-\%203.pdf} }
 and the SCSI primary commands
      \footnote{ \href{http://hackipedia.org/Hardware/SCSI/Primary\%20Commands/SCSI\%20Primary\%20Commands\%20-\%204.pdf}
                      {http://hackipedia.org/Hardware/SCSI/Primary\%20Commands/SCSI\%20Primary\%20Commands\%20-\%204.pdf} }).
      \footnote{The official site for SCSI standard is \href{http://T10.org}{http://T10.org}. All specifications
      can be found there in their approved version, but behind a paywall. Nevertheless all previous drafts were
      public and can conveniently be found on the web. Hackipedia hold a very nice collection of such
      documentations.}

\subsubsection{Manufacturer's specificities}
\label{Manufacturer's specificities}
The SCSI specification allows for some flexibility for the manufacturers of tape drives, and 
each of them has differences in details. The detailed can be found in the following documentations:

\begin{itemize}
\item{}StorageTek\texttrademark T10000 Tape Drive
       \footnote{ \href{http://docs.oracle.com/cd/E19957-01/96174E/96174E.pdf}
                       {http://docs.oracle.com/cd/E19957-01/96174E/96174E.pdf} }
\item{}Sun StorageTek\texttrademark T10000 Tape Drive Fibre Channel Interface Reference Manual
       \footnote{ \href{http://docs.oracle.com/cd/E19772-01/MT9259L/MT9259L.pdf}
                       {http://docs.oracle.com/cd/E19772-01/MT9259L/MT9259L.pdf} }
\item{}IBM System Storage TS1120 and TS1130 Tape Drives and TS1120 ControllerOperator Guide3592 Models J1A, E05, E06, EU6, J70 and C06
       \footnote{ \href{ftp://ftp.software.ibm.com/storage/TS1130/a86opg02.pdf}
                       {ftp://ftp.software.ibm.com/storage/TS1130/a86opg02.pdf} }
\item{}IBM System Storage Tape Drive 3592 SCSI Reference
       \footnote{ \href{http://www-01.ibm.com/support/docview.wss?uid=ssg1S7003248\&aid=1}
                       {http://www-01.ibm.com/support/docview.wss?uid=ssg1S7003248\&aid=1} }
\item{}IBM TotalStorage LTO Ultrium Tape Drive SCSI Reference  (LTO-5 through LTO-6)
       \footnote{ \href{http://www-01.ibm.com/support/docview.wss?uid=ssg1S7003556\&aid=1}
                       {http://www-01.ibm.com/support/docview.wss?uid=ssg1S7003556\&aid=1} }
\end{itemize}

\subsection{SCSI support in Linux}
On the Linux side, the main references are the Linux 2.4 SCSI subsystem HOWTO
       \footnote{ \href{http://mirrors.kernel.org/LDP/HOWTO/pdf/SCSI-2.4-HOWTO.pdf}
                       {http://mirrors.kernel.org/LDP/HOWTO/pdf/SCSI-2.4-HOWTO.pdf} },
especially for is section 9.3 on the st driver,
and the Linux SCSI Generic (sg) HOWTO 
       \footnote{ \href{http://mirrors.kernel.org/LDP/HOWTO/pdf/SCSI-Generic-HOWTO.pdf}
                       {http://mirrors.kernel.org/LDP/HOWTO/pdf/SCSI-Generic-HOWTO.pdf} }. 

More details regarding the Generic SCSI driver can be found on the SCSI subsystem maintainer's web site 
       \footnote{ \href{http://sg.danny.cz/sg/}{http://sg.danny.cz/sg/} }.

The section on the SG\_IO ioctl, \footnote{ \href{http://sg.danny.cz/sg/sg\textunderscore{}io.html}{http://sg.danny.cz/sg/sg\textunderscore{}io.html} } details the usage of the 
simplest ioctl for the generic SCSI driver, which allows the invocation of a SCSI command and the collection of the 
result in a single system call.

This ioctl is provided in the middle layer of the SCSI subsystem of Linux. All SCSI drivers, including st, fall back
to the middle layer when encountering an unknown ioctl. This means there is no need to open the matching generic SCSI,
unless we want to control command queueing with separate sending of commands and result collection.

\subsection{Unsorted CAStor docs}
A collection of links to various documentations written in the past is available on one of CAStor's web pages
       \footnote{ \href{http://castorwww.web.cern.ch/castorwww/links.htm}{http://castorwww.web.cern.ch/castorwww/links.htm} }.

\subsection{SCSI tape support in Linux (st driver)}
Generic SCSI allows detailed control of the operations, but the bulk of them (including reading and
writing) can be managed by the higher level SCSI tape (or st) driver provided by the Linux kernel.
More information on the st driver can be found in the man page "st" and in \verb#Documentation/scsi/st.txt#
in the sources of the kernel.

\section{Tools used during development}
\subsection{Required tools for build}
\begin{itemize}
\item{}GCC/G++ (Basic SLC version)
\item{}CMake (Basic SLC version)
\item{}rpmbuild (Basic SLC version)
\item{}Google Mock/Google test (GTest is provided in EPEL repository for SLC. 
  GMock requires recompilation. The source RPMs can be found for newer versions of RPM based distributions, for example from rpmfind 
  \footnote{ \href{http://rpmfind.net/linux/rpm2html/search.php?query=gmock}{http://rpmfind.net/linux/rpm2html/search.php?query=gmock} }.
 For convenience, 
  they are also available on AFS as a temporary solution
      \footnote{ \href{file:///afs/cern.ch/user/c/canoc3/public/GoogleTest-Mock}{/afs/cern.ch/user/c/canoc3/public/GoogleTest-Mock} }.
\item{}Valgrind (Basic SLC version)
\item{}\LaTeX (Basic SLC version) to compile this document
\item{}Doxygen for code documentation (Basic SLC version)
\end{itemize}

\subsection{Tools used during development}
\begin{itemize}
\item{}mhvtl \footnote{ \href{https://sites.google.com/site/linuxvtl2/}{https://sites.google.com/site/linuxvtl2/} } for developing against virtual drives and libraries.
\item{}TeamCity for continuous integration
\item{}NetBeans as an IDE, including for remote development\
\end{itemize}

\subsection{Code coverage using lcov}
Although the code coverage is not integrated in the build process, it is
straightforward to run on the code. The following recipe will deliver a set of 
web pages indicating which parts of the code are covered or not in the unit tests.
The lcov package is required. It is only available on SLC6, and can be installed via yum.
\begin{itemize}
\item{}Change the main CMakeFiles.txt as in this diff:
\begin{small}
\begin{verbatim}
Index: CMakeLists.txt
===================================================================
--- CMakeLists.txt      (revision 76)
+++ CMakeLists.txt      (working copy)
@@ -45,7 +45,8 @@
 ###########################################################################
 # compiler options
 ###########################################################################
-set (CMAKE_CXX_FLAGS "-g3 -Wall -Werror -pedantic -O2")
+set (CMAKE_CXX_FLAGS "-g3 -Wall -Werror -pedantic -O2 --coverage")
+set (CMAKE_LD_FLAGS "--coverage")

 ###########################################################################
 # dependancies
\end{verbatim}
\end{small}

\item{}Re-run cmake and recompile as usual.
\item{}Capture the result:

        \small{}\verb#lcov --capture --directory 00build/ --output-file 00build/coverage.info#.
\item{}\normalsize{}Generate the resulting html pages: 
        
        \small{}\verb#genhtml 00build/coverage.info --output-directory 00build/coverage#.
\end{itemize}

\section{Software layout}

\subsection{SCSI structures, constants and endianness}

In order to make the code readable, and to avoid heavy mask-and-shift usage (which one would tend
to code using litterals in order to avoid many constants definitions), we use bit field structures.
The unused fields can be left anonymous.
The definition is shown in listing \ref{SCSI_struct}, and usage in listing \ref{SCSI_struct_usage}.
As there could be endianness issues, we limit this usage to within bytes. Fortunately, the SCSI 
standard nicely adheres to this rule.

\begin{table}[h]
\begin{lstlisting}[caption=SCSI::Structures example,label=SCSI_struct]
namespace SCSI {
  namespace Structures {

    /*
     * Inquiry data as described in SPC-4.
     */
    typedef struct {
      unsigned char perifDevType : 5;
      unsigned char perifQualifyer : 3;

      unsigned char : 7;
      unsigned char RMB : 1;

      unsigned char version : 8;

      unsigned char respDataFmt : 4;
      unsigned char HiSup : 1;
      unsigned char normACA : 1;
      unsigned char : 2;
[...]
    } inquiryData_t;
  }
}
\end{lstlisting}
\end{table}

\begin{table}[h]
\begin{lstlisting}[caption=SCSI::Structures usage example,label=SCSI_struct_usage]
      SCSI::Structures::inquiryData_t & inq = *((SCSI::Structures::inquiryData_t *) dataBuff);
      std::stringstream inqDump;
      inqDump << std::hex << std::showbase << std::nouppercase
              << "inq.perifDevType=" << (int) inq.perifDevType << std::endl
              << "inq.perifQualifyer=" << (int) inq.perifQualifyer << std::endl
[...]
              << "inq.T10Vendor="      << SCSI::Structures::toString(inq.T10Vendor) << std::endl
              << "inq.prodId="         << SCSI::Structures::toString(inq.prodId) << std::endl
              << "inq.prodRevLv="      << SCSI::Structures::toString(inq.prodRevLvl) << std::endl
              << "inq.vendorSpecific1="<< SCSI::Structures::toString(inq.vendorSpecific1)<< std::endl
\end{lstlisting}
\end{table}

The unit test resorts to shift and mask, once and only once, to validate the bit fields in
another way. There is an example for this validation in \verb#SCSI/StructureTest.cc#; an excerpt is in listing \ref{SCSI_struct_testing}.

\begin{table}
\begin{lstlisting}[caption=SCSI::Structures usage example,label=SCSI_struct_testing]
namespace UnitTests {
  TEST(SCSI_Structures, inquiryData_t_multi_byte_numbers_strings) {
    /* Validate the bit field behavior of the struct inquiryData_t,
     which represents the standard INQUIRY data format as defined in 
     SPC-4. This test also validates the handling of multi-bytes numbers,
     as SCSI structures are big endian (and main development target is 
     little endian.  */
    unsigned char inqBuff [100];
    memset(inqBuff, 0, sizeof(inqBuff));
    SCSI::Structures::inquiryData_t & inq = *((SCSI::Structures::inquiryData_t *) inqBuff);
    /* Peripheral device type */
    ASSERT_EQ(0, inq.perifDevType);
    inqBuff[0] |= (0x1A & 0x1F) << 0;
    ASSERT_EQ(0x1A, inq.perifDevType);
    
    /* Peripheral qualifier */
    ASSERT_EQ(0, inq.perifQualifyer);
    inqBuff[0] |= (0x5 & 0x7) << 5;
    ASSERT_EQ(0x5, inq.perifQualifyer);
[...]
  }
}
\end{lstlisting}
\end{table}

Other common types in the SCSI specification are multi-bytes
number, which are represented by \verb#unsigned char[2/* (or 4)*/]# and handled by helper functions 
\verb#toU16()# and \verb#toU32()#. The helper functions
conveniently use \verb#ntoh{l|s}#, as SCSI and netowrk orders are the same. Another helper function 
takes care of string extraction from fixed sized char arrays. See listing \ref{SCSI_data_helpers}.

\begin{table}
\begin{lstlisting}[caption=SCSI::Structures helper functions,label=SCSI_data_helpers]
SCSI::Structures::uint32_t toU32(const char(& t)[4]);
SCSI::Structures::uint32_t toU32(const char(& t)[4]);

template <size_t n>
std::string toString(const char(& t)[n]);
\end{lstlisting}
\end{table}

Those arrays are 0-padded, but may not be 0 terminated used completely. It is seen in listing \ref{SCSI_struct_usage}.

To avoid literals in the code, which forces anyone reading it to do tedious lookups,
the SCSI constants are also defined as constants in the code. See listing \ref{SCSI_consts}.

\begin{table}
\begin{lstlisting}[caption=SCSI::Constants,label=SCSI_consts]
namespace SCSI {
  class Commands {
  public:
    enum {
      /*
       *      SCSI opcodes, taken from linux kernel sources
       *      Linux kernel's is more complete than system's
       *      includes.
       */
      TEST_UNIT_READY                               = 0x00,
      REZERO_UNIT                                   = 0x01,
      REQUEST_SENSE                                 = 0x03,
[...]
\end{lstlisting}
\end{table}

\subsection{Exceptions hierarchy and error handling strategy}

There is a small class hierarchy for exceptions: \verb#Tape::Exception# inherits from
\verb#std::exception#, and \verb#Tape::Exceptions::Errnum# inherits from the latter.
\verb#Tape::Exceptions::Errnum# manages the errnos. It collects the errno value and turns it
into a string automatically at construction time.  \verb#Tape::Exception# and all inheriting
classes collect a stack trace at construction time.

\verb#Tape::Exception# and all its heirs automatically generate a stack trace at creation time.
This allows easy tracing of unhandled exceptions, as the stack trace embedded in the content
of the \verb#what()# method. For the cases where the exception is indeed handled, a shorter version
called \verb#shortWhat()# allows the logging of the problem without bloating the logs with long stack 
traces.

Another exception class, \verb#SCSI::Exception#, turns the SCSI status and sense buffer into a
user readable string.

Throughout the project, the error handling strategy is to throw an exception when any
error condition occurs. This ensures that any returned value is valid, and prevents the 
calling function from testing for error conditions. The default exception throwing is
coming from a narrow set of exceptions types. This gives a crude exception handling capacity
to the user of the functions. When finer grained exceptions will turn out to be required,
we will add them on an as needed basis.

\subsection{The Tape::Drive object}

This first deliverable is a tape drive object. This tape drive object abstracts all
SCSI and technical details and provides a high level interface, to be used by the 
file structure layer.

It will provide as much data safety as possible by blocking writes in situations
where they are not safe (to be defined in details, but the most obvious is right
after positioning, as the file layer is expected to check the position by reading
the trailer of the previous file before writing.

The SCSI commands and st driver's functions used in previous software (CAStor's taped/rtcpd) are:
\begin{itemize}
\item Individual SCSI commands sent using generic SCSI:
  \begin{itemize}
    \item Read status (inquiry SCSI command used by posovl)
    \item Read serial number (inquiry SCSI command, asking for vital product data page 0x80)
    \item Locate (locate(10) SCSI command: 32 bits logical object identifiers)
                      \footnote{There is also a locate(16) command allowing 64 bis addresses.
                      This might become necessary as tapes grow. Discounting the per-file overhead,
                      with 256kB block, it still takes 1PB to get $2^{32}$ blocks.}
    \item Read position (read position SCSI command -- short form): get the current logical object
          location (a.k.a. block ID).
    \item Log select (for clearing compression stats page. The function clear\_compression\_stats
          actually does a blanket reset of all statistics. It sets the PCR/SP/PC combination
          to 1/0/3. The basic SCSI specification states that the value pf PC is not important,
          but for the IBM drives, the documentation recommends PC=11b, which we have for all drives.
    \item Log sense, to read the compression pages. This is device dependant. The code covers
          5 blocks of device types: DAT, DLT-SDLT-LTO, IBM(3490, 3590, 3592), StorageTek RedWood(SD3),
          StorageTek(9840, 9940, T10000).
    \item Log sense for page 0x2E (tape alert, as defined in SSC-3) on all modern tape drives to detect tape alerts.
    \item Mode sense was used in setdens called itself by mounttape. It sets density and compression
          parameters based on the drive type and the density requested by the caller. On all modern tape drives,
          the compression page is 0x10. This will be replaced by the function \verb#Tape::Drive::setCompressionAndDensity()#.
          Some work is still needed to fully understand the original function.
  \end{itemize}
\item st driver's commands, leading to internal variables setting or SCSI actions:
  \begin{itemize}
    \item Get internal driver state via the MTIOCGET ioctl (for drive ready, write protection, 
          get some error condition, when MTIOSENSE failed, to get the EOD, BOT bits (readlbl)).
          This functionality is covered by \verb#Drive::getDriveStatus#.
    \item Try and get the sense data for the last-ish command with MTIOSENSE. This
          relies on a CERN-made patch. This is also covered \verb#Drive::getDriveStatus#.
    \item Setup the driver's parameters (MTIOCTOP/MTSETDRVBUFFER) for (un)buffered 
          writes and asynchronous writes (in confdrive, a child process of taped).
          This option is currently not set in production environments.
    \item Jump to end of media (before rewinding, as a mean to rebuild the MIR) (MTIOCTOP/MTEOM, 
          with some MTIOCTOP/MTSETDRVBUFFER before, in repairbadmir). The setting of the driver
          buffer is used to set the boolean flag MT\_ST\_FAST\_MTEOM to 0. If not, the mt driver uses
          a nasty trick asks the device to skip 0x7fffff files forward. The comment in the CAStor code
          claims it's 32k files, but $2^{23}-1$ is indeed 8M files. Anyway, after turning off the 
          option, the st driver reverts to telling the SCSI device to space to end of data.
          This behavior is documented in the IBM's operator manual mentioned in \ref{Manufacturer's specificities},
          on page 53 for tape alert 18 (Tape directory corrupted on load).

          It is not mentioned for other tape server's documentations. Specifically, StorageTek
          only lists operator-initiated methods for MIR rebuild.

          Nevertheless, we will still issue this operation in all drives as it is not known
          if it works in practice for StorageTek drives (or others).
    \item Rewind (MTIOCTOP/MTREW, in rwndtape).
    \item Skip to end of data (MTIOCTOP/MTEOM, in skip2eod, without the trick of repairbadmir).
    \item Skip n files backwards (MTIOCTOP/MTBSF, in skiptpfb).
    \item Skip n files forward (MTIOCTOP/MTFSF, in skiptpff).
    \item Skip n files forward (MTIOCTOP/MTFSF, in skiptpfff). skiptpfff and skiptpff differ only 
          by error reporting. Both functions exists since CAStor has been put in SVN (20/07/1999)
    \item Skip n blocks backwards (MTIOCTOP/MTBSR, in skiptprb).
    \item Skip n blocks forward (MTIOCTOP/MTFSR, in skiptprf).
    \item Unload the tape (MTIOCTOP/MTOFFL, in unldtape).
    \item Write synchronous file mark(s) (tape marks in CAStor jargon) (MTIOCTOP/MTWEOF, in wrttpmrk).
    \item Write immediate (asynchronous file marks (MTIOCTOP/MTWEOFI, also in wrttpmrk).
    \item Clear the EOT condition by calling MTIOCGET. This is done in wrttrllbl, 3 times.
          In MTIOCGET, indeed, a member of the scsi\_tape structure called recover\_reg is reset to 0.
          This clearing is used to properly report errors in label writing functions.
          The usefulness of this function is dubious and it is not included in the current
          API.
    \item Write is used in 2 places only : twrite and writelbl (which is a specialized 
          function to write 80 bytes blocks). twrite is not checking the size of blocks,
          which is determined in the calling functions.
    \item Read is used in tread, which is used in a single place of TapeToMemory. It is 
          also used in readlbl. The latter uses a trick to detect that a tape is blank.
          This could be turned into a specialized function.
  \end{itemize}
\end{itemize}

The interface is shown in listing \ref{drive_if}.

\begin{table}
\begin{lstlisting}[caption=Tape::Drive interface,label=drive_if]
namespace Tape {
  class Drive {
  public:
    Drive();
    /* TODO */
  };
} // namespace Tape
\end{lstlisting}
\end{table}
