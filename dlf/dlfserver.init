#------------------------------------------------------------------------------------------------------#
#                                                                                                      #
#  dlfserver.init - Castor Distribution Logging Facility Control Script                                #
#  Copyright (C) 2005 CERN IT/FIO (castor-dev@cern.ch)                                                 #
#                                                                                                      #
#  This program is free software; you can redistribute it and/or modify it under the terms of the GNU  #
#  General Public License as published by the Free Software Foundation; either version 2 of the        #
#  License, or (at your option) any later version.                                                     #
#                                                                                                      #
#  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without   #
#  even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU      #
#  General Public License for more details.                                                            #
#                                                                                                      #
#  You should have received a copy of the GNU General Public License along with this program; if not,  #
#  write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,   #
#  USA.                                                                                                #
#                                                                                                      #
#  Usage: dlfserver {start|stop|status|restart|suspend|resume}                                         #
#                                                                                                      #
#------------------------------------------------------------------------------------------------------#

#
# Oracle environment not needed if cern-instant client is used
#
if [ -r /etc/sysconfig/castor ]; then
        . /etc/sysconfig/castor
fi

sysname=`uname -s`

# source function library
if [ -r /etc/rc.d/init.d/functions ]; then
	. /etc/rc.d/init.d/functions
	DAEMON=daemon
	FAILURE=failure
	ECHO_FAILURE=failure
	SUCCESS=success
	ECHO_SUCCESS=echo_success
	ECHO_END=echo
	if [ $sysname = "Linux" ]; then
		ECHOOPT=-n
	fi
else
	DAEMON=
	FAILURE=
	ECHO_FAILURE=
	SUCCESS=
	ECHO_SUCCESS=
	ECHOOPT=
	ECHO_END=
fi

RETVAL=0
prog="dlfserver"
PIDFILE=/var/run/$prog.pid
PIDDIR=/var/run
SUBSYS=/var/lock/subsys/$prog
SUBSYSDIR=/var/lock/subsys
[ -z "$SILENTSTOP" ] && SILENTSTOP=0
DLFSERVER=/usr/bin/$prog
OPTIONS=""
SYSCONFIGDLFSERVER=/etc/sysconfig/$prog

#
# Blindly attempt to create useful directories
#
[ ! -d $PIDDIR ] && mkdir -p $PIDDIR >& /dev/null
[ ! -d $SUBSYSDIR ] && mkdir -p $SUBSYSDIR >& /dev/null

if [ $sysname = "HP-UX" ]; then
	export UNIX95=1
fi
if [ $sysname = "SunOS" ]; then
	format4comm="fname"
else
	format4comm="comm"
fi

#
# Unless sysconfig says no the default is to run the server
#
DLFSERVER_RUN=yes

mycheckpid() {
    pid=`ps -eo pid,ppid,$format4comm | egrep " 1 $prog\$" | awk '{print $1}'`
    [ "$pid" = "$1" ] && return 1
    return 0
}


# Process options
case "$1" in
  start)
	echo $ECHOOPT "Starting $prog: "
    	if [ $sysname = "Linux" -a `whoami` = "root" ]; then
        	netstat -ap | egrep '\*:5035|\*:dlf' | grep LISTEN | egrep "\/$prog *\$" > /dev/null
    	else
        	netstat -a  | egrep '\*:5035|\*:dlf' | egrep 'LISTEN *$' > /dev/null
    	fi
	# ps -eo ppid,$format4comm | egrep '^[ \t]+1 $prog' > /dev/null
	if [ $? -eq 0 ]; then
		echo $ECHOOPT "$prog already started: "
		[ -n "$FAILURE" ] && $FAILURE "$prog already started: "
		RETVAL=1
	else
        if [ -r $SYSCONFIGDLFSERVER ]; then
            	#
            	# Source the configuration
            	#
            	. $SYSCONFIGDLFSERVER
            	if [ "${RUN_DLFSERVER}" != "yes" ]; then
                	echo $ECHOOPT "$SYSCONFIGDLFSERVER says NO: "
                	[ -n "$FAILURE" ] && $FAILURE "$SYSCONFIGDLFSERVER says NO: "
                	RETVAL=1
            	fi
            	if [ -n "${ULIMIT_N}" ]; then
                	ulimit -n ${ULIMIT_N}
            	fi
		if [ -n "${ULIMIT_S}" ]; then
			ulimit -s ${ULIMIT_S}
		fi
        fi
        if [ $RETVAL -eq 0 ]; then
            	#
            	# Because we might generate a core file we explicitely chdir in the workdir
            	#
	    	cd /var/spool/dlf
            	$DAEMON $DLFSERVER_OPTIONS
            	if [ $? -eq 0 ]; then
                	[ -d $SUBSYSDIR ] && touch $SUBSYS
                	if [ -d $PIDDIR ]; then
                    	pid=`ps -eo pid,ppid,$format4comm | egrep " 1 $prog\$" | awk '{print $1}'`
                    	# The point of $PIDFILE is that it kills only
                    	# the master daemon.
                    	rm -f $PIDFILE
		    	if [ -n "$pid" ]; then
				echo $pid > $PIDFILE
				RETVAL=0
		    	else
				echo $ECHOOPT "$prog not started: "
				[ -n "$FAILURE" ] && $FAILURE "$prog not started: "
				RETVAL=1
		    	fi
                	else
                  		RETVAL=0
			fi
            	else
                	echo $ECHOOPT "$prog not started: "
                	[ -n "$FAILURE" ] && $FAILURE "$prog not started: "
                	RETVAL=1
            	fi
        fi
	fi
	$ECHO_END
	;;

  stop)
    	if [ -f $PIDFILE ]; then
        	[ $SILENTSTOP -eq 0 ] && echo $ECHOOPT "Stopping $prog: "
        	kill -15 -`cat $PIDFILE` >& /dev/null
        	#
        	# Wait 60 seconds maximum
        	#
        	stopped=0
        	for i in 0 10 20 30 40 50; do
            		for j in 0 1 2 3 4 5 6 7 8 9; do
                		sleep 1
    	        	    	mycheckpid `cat $PIDFILE`
        	        	if [ $? -eq 0 ]; then
                    			stopped=1
                    			break
                		fi
                		[ $stopped -eq 1 ] && break
            		done
        	done
        	if [ $stopped -ne 1 ]; then
            		[ $SILENTSTOP -eq 0 ] && echo $ECHOOPT "Using kill -9 `cat $PIDFILE` "
            		kill -9 -`cat $PIDFILE` >& /dev/null
            		RETVAL=$?
       		 else
            		RETVAL=0
        	fi
        	if [ $RETVAL -eq 0 ]; then
            		rm -f $PIDFILE
       		fi
   	else

        # dlfserver might have been started by hand
        pid=`ps -eo pid,ppid,$format4comm | egrep " 1 $prog\$" | awk '{print $1}'`
        if [ -n "$pid" ]; then
            	[ $SILENTSTOP -eq 0 ] && echo $ECHOOPT "Stopping $prog: "
            	kill -15 -$pid >& /dev/null
            	#
            	# Wait 60 seconds maximum
            	#
            	stopped=0
            	for i in 0 10 20 30 40 50; do
                	for j in 0 1 2 3 4 5 6 7 8 9; do
                    	sleep 1
                    	mycheckpid $pid
                    	if [ $? -eq 0 ]; then
                        	stopped=1
                        	break
                    	fi
                    	[ $stopped -eq 1 ] && break
                	done
            	done
            	if [ $stopped -ne 1 ]; then
                	[ $SILENTSTOP -eq 0 ] && echo $ECHOOPT "Using kill -9 `cat $PIDFILE` "
               		 kill -9 -`cat $PIDFILE` >& /dev/null
                	RETVAL=$?
            	else
                	RETVAL=0
            	fi
        	else
            		[ $SILENTSTOP -eq 0 ] && echo $ECHOOPT "$prog already stopped: "
            		[ $SILENTSTOP -eq 0 -a -n "$FAILURE" ] && $FAILURE "$prog already stopped: "
            		RETVAL=1
        	fi
    	fi
    	if [ $SILENTSTOP -eq 0 -a $sysname = "Linux" ]; then
        	if [ $RETVAL -eq 0 ]; then
           		$ECHO_SUCCESS
        	else
           		$ECHO_FAILURE
        	fi
    	fi
    	[ -d $SUBSYSDIR ] && rm -f $SUBSYS
    	[ $SILENTSTOP -eq 0 -a -n "$ECHO_END" ] && $ECHO_END
    	#
    	# Basically: if SILENTSTOP is not 0 when we never print something
    	# But if the stop is successful... One might want to see stop: OK
    	# anyway ?
    	#
    	if [ $SILENTSTOP -ne 0 -a $RETVAL -eq 0 ]; then
        	echo $ECHOOPT "Stopping $prog: "
        	[ $sysname = "Linux" ] && $ECHO_SUCCESS
        	[ -n "$ECHO_END" ] && $ECHO_END
    	fi
  restart)
        $0 stop
        if [ $? -eq 0 -o $SILENTSTOP -eq 0 ]; then
            	$0 start
            	RETVAL=$?
        else
        	#
        	# It is legal to return zero it if was a conditional restart
        	#
         	if [ $SILENTSTOP -eq 0 ]; then
                	RETVAL=1
            	else
                	RETVAL=0
            	fi
        fi
        ;;
  condrestart)
        SILENTSTOP=1
        export SILENTSTOP
        $0 restart
        RETVAL=$?
        ;;
  suspend)
	if [ -f $PIDFILE ]; then
		echo $ECHOOPT "Suspending $prog: "
        	kill -10 -`cat $PIDFILE` >& /dev/null
		RETVAL=$?
	else
		pid=`ps -eo pid,ppid,$format4comm | egrep " 1 $prog\$" | awk '{print $1}'`
        	if [ -n "$pid" ]; then
			echo $ECHOOPT "Suspending $prog: "
        		kill -10 -`cat $pid` >& /dev/null
			RETVAL=$?	
		else 
			echo $ECHOOPT "$prog not started: "
			[ -n "$FAILURE" ] && $FAILURE "$prog not started: "
			RETVAL=1
		fi		
	fi
	$ECHO_END
	;;
  resume)
	if [ -f $PIDFILE ]; then
		echo $ECHOOPT "Suspending $prog: "
        	kill -12 -`cat $PIDFILE` >& /dev/null
		RETVAL=$?
	else
		pid=`ps -eo pid,ppid,$format4comm | egrep " 1 $prog\$" | awk '{print $1}'`
        	if [ -n "$pid" ]; then
			echo $ECHOOPT "Suspending $prog: "
        		kill -12 -`cat $pid` >& /dev/null
			RETVAL=$?	
		else 
			echo $ECHOOPT "$prog not started: "
			[ -n "$FAILURE" ] && $FAILURE "$prog not started: "
			RETVAL=1
		fi		
	fi
	$ECHO_END
	;;
  status)
        pid=`ps -eo pid,ppid,$format4comm | egrep " 1 $prog\$" | awk '{print $1}'`
        if [ -n "$pid" ]; then
            	echo $ECHOOPT "$prog (pid $pid) is running..."
            	$ECHO_SUCCESS
            	$ECHO_END
        else
            	if [ -f $PIDFILE ]; then
                	pid=`head -1 $PIDFILE`
                	if [ "$pid" != "" ] ; then
                    		echo $ECHOOPT "$prog dead but pid file exists"
                    		$ECHO_FAILURE
                    		$ECHO_END
                	fi
            	else
                	if [ -f $SUBSYS ]; then
                    		echo $ECHOOPT "$prog dead but subsys ($SUBSYS) locked"
                	else
                    		echo $ECHOOPT "$prog is stopped"
                	fi
                	$ECHO_FAILURE
                	$ECHO_END
            	fi
        fi
        ;;
  *)
        echo "Usage: $0 {start|stop|status|restart|condrestart|suspend|resume}"
        RETVAL=1
        ;;
esac

exit $RETVAL


#-- End-of-File ---------------------------------------------------------------------------------------#
