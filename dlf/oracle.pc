/******************************************************************************************************
 *                                                                                                    *
 * oracle.pc - Castor Distribution Logging Facility                                                   *
 * Copyright (C) 2006 CERN IT/FIO (castor-dev@cern.ch)                                                *
 *                                                                                                    *
 * This program is free software; you can redistribute it and/or modify it under the terms of the GNU *
 * General Public License as published by the Free Software Foundation; either version 2 of the       *
 * License, or (at your option) any later version.                                                    *
 *                                                                                                    *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without  *
 * even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU     *
 * General Public License for more details.                                                           *
 *                                                                                                    *
 * You should have received a copy of the GNU General Public License along with this program; if not, *
 * write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,  *
 * USA.                                                                                               *
 *                                                                                                    *
 ******************************************************************************************************/

/**
 * $Id: oracle.pc,v 1.21 2007/04/19 13:45:04 waldron Exp $
 */

/* headers */
#include <errno.h>
#include <sqlca.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/time.h>
#include <time.h>
#include <unistd.h>

#include "Cthread_api.h"
#include "common.h"
#include "dbi.h"
#include "dlf_api.h"
#include "hash.h"
#include "log.h"
#include "queue.h"
#include "serrno.h"


/* pools */
static database_t   *dpool[MAX_THREADS];     /**< thread pool for database connections  */

/* hashes */
static hash_t       *hosthash     = NULL;    /**< hostname hash                         */
static hash_t       *nshosthash   = NULL;    /**< name server hostname hash             */
static hash_t       *msgtexthash  = NULL;    /**< message text hash                     */
static hash_t       *facilityhash = NULL;    /**< facility hash                         */  

/* mutexes
 *   - used to generate msg sequence numbers and lock access to arrays
 */
static int database_mutex;

/* database sequences */
static long   seq_id       = -1;             /**< primary key id for dlf_messages       */
static long   seq_hostid   = -1;             /**< primary key id for dlf_host_map       */
static long   seq_nshostid = -1;             /**< primary key id for dlf_nshost_map     */

/* global variables */
static time_t last_monitoring = 0;           /**< time of last call to dlf_monitoring() */
static time_t last_mode       = 0;           /**< time of last call to dlf_mode()       */

/* externs */
extern int       server_mode;                /**< server mode                           */
extern long      server_start;               /**< server startup time                   */
extern queue_t   *queue;                     /**< internal server fifo queue            */

/**
 * structures
 */

struct database_t {
	int                tid;
	int                index;
	long               mode;
	time_t             last_flush;
	time_t             last_connect;
	int                first_connect;
	int                mutex;

	sql_context        ctx;

	/* database tables */
	struct msgtable_t  *mtable;
	struct numtable_t  *ntable;
	struct strtable_t  *stable;

	/* statistics
	 *   - must be purged at a regular interval, otherwise overflows in the counters will occur
	 */
	unsigned long      commits;
	unsigned long      errors;
	unsigned long      inserts;
	unsigned long      rollbacks;
	unsigned long      selects;
	unsigned long      updates;
	unsigned long      messages;
	unsigned long      cursors;
	unsigned long      inits;
	double             response;
};


/** oracle specific structures
 *   - used to store records prior to bulk insertion
 *   - this may appear to be far more duplication of data then necessary, but oracle bulk insertion
 *     requires this and wont allow dynamic memory allocation - only fixed arrays or a fixed length!
 */

struct msgtable_t {
	int       count;
	long      id[DB_ORA_ARRAY_SIZE];
	char      timestamp[DB_ORA_ARRAY_SIZE][DLF_LEN_TIMESTAMP + 1];
	int       timeusec[DB_ORA_ARRAY_SIZE];
	char      reqid[DB_ORA_ARRAY_SIZE][CUUID_STRING_LEN + 1];
	char      subreqid[DB_ORA_ARRAY_SIZE][CUUID_STRING_LEN + 1];
	int       hostid[DB_ORA_ARRAY_SIZE];
	int       facility[DB_ORA_ARRAY_SIZE];
	int       severity[DB_ORA_ARRAY_SIZE];
	int       msg_no[DB_ORA_ARRAY_SIZE];
	int       pid[DB_ORA_ARRAY_SIZE];
	int       tid[DB_ORA_ARRAY_SIZE];
	int       nshostid[DB_ORA_ARRAY_SIZE];
	char      nsfileid[DB_ORA_ARRAY_SIZE][CUUID_STRING_LEN + 1];
	char      tapevid[DB_ORA_ARRAY_SIZE][DLF_LEN_TAPEID + 1];
	int       userid[DB_ORA_ARRAY_SIZE];
	int       groupid[DB_ORA_ARRAY_SIZE];
	char      stype[DB_ORA_ARRAY_SIZE][DLF_LEN_STYPE + 1];
	char      sname[DB_ORA_ARRAY_SIZE][DLF_LEN_SNAME + 1];
};

struct numtable_t {
	int       count;
	long      id[DB_ORA_ARRAY_SIZE];
	char      timestamp[DB_ORA_ARRAY_SIZE][DLF_LEN_TIMESTAMP + 1];
	char      parname[DB_ORA_ARRAY_SIZE][DLF_LEN_PARAMNAME + 1];
	char      parvalue[DB_ORA_ARRAY_SIZE][DLF_LEN_NUMBERVALUE + 1];
};

struct strtable_t {
	int       count;
	long      id[DB_ORA_ARRAY_SIZE];
	char      timestamp[DB_ORA_ARRAY_SIZE][DLF_LEN_TIMESTAMP + 1];
	char      parname[DB_ORA_ARRAY_SIZE][DLF_LEN_PARAMNAME + 1];
	char      parvalue[DB_ORA_ARRAY_SIZE][DLF_LEN_STRINGVALUE + 1];
};


/*
 * db_init
 */

int DLL_DECL db_init(int threads) {

        /* variables */
        database_t *db;
        struct     sqlca sqlca;
        char       err_msg[512];
        size_t     err_size;
        size_t     err_len;
        int        i;
        int        rv;

        /* flush thread pool */
        for (i = 0; i < MAX_THREADS; i++) {
		dpool[i] = NULL;
        }
	db = NULL;

	/* pro*c thread mode */
	EXEC SQL ENABLE THREADS;

	/* suspend database insertion until init completion
	 *   - at this point data may already be waiting for insertion in the central queue, allowing
	 *     the newly created threads in the next section to begin working on data would cause data
	 *     corruption as the sequence numbers have yet to be determined.
 	 */
	SetSuspendedDB(server_mode);

	/* initialise hashes */
	rv = hash_create(&hosthash, 512);
	if (rv != APP_SUCCESS) {
		log(LOG_ERR, "db_init() - failed to initialise host hash\n");
		return APP_FAILURE;
	}

	rv = hash_create(&nshosthash, 100);
	if (rv != APP_SUCCESS) {
		log(LOG_ERR, "db_init() - failed to initialise name server host hash\n");
		return APP_FAILURE;
	}

	rv = hash_create(&msgtexthash, 512);
	if (rv != APP_SUCCESS) {
		log(LOG_ERR, "db_init() - failed to initialise message text hash\n");
		return APP_FAILURE;
	}

	rv = hash_create(&facilityhash, 100);
	if (rv != APP_SUCCESS) {
		log(LOG_ERR, "db_init() - failed to initialise facility hash\n");
		return APP_FAILURE;
	}

	last_monitoring = time(NULL);
	last_mode       = time(NULL) - 60;

	if (threads <= 0) {
		return APP_SUCCESS;
	}

	/* create database threads */
	for (i = 0; i < threads; i++) {

		/* create structure */
		db = (database_t *) malloc(sizeof(database_t));
		if (db == NULL) {
			log(LOG_ERR, "db_init() - failed to malloc() database structure : %s\n", strerror(errno));
			return APP_FAILURE;
		}

		/* initialise database_t structure */
		db->index         = i;
		db->last_flush    = time(NULL);
		db->last_connect  = 0;
		db->first_connect = 1;
		db->mode          = MODE_DEFAULT;

		/* table structures */
		db->mtable = (struct msgtable_t *) malloc(sizeof(struct msgtable_t));
		db->ntable = (struct numtable_t *) malloc(sizeof(struct numtable_t));
		db->stable = (struct strtable_t *) malloc(sizeof(struct strtable_t));

		/* malloc errors ? */
		if ((db->mtable == NULL) || (db->ntable == NULL) || (db->stable == NULL)) {
			log(LOG_ERR, "db_init() - failued to malloc() table structures : %s\n", strerror(errno));
			return APP_FAILURE;
		}

		/* initialise statistics */
		db->commits = db->errors  = db->inserts  = db->rollbacks = 0;
		db->selects = db->updates = db->messages = db->cursors   = 0;
		db->inits   = 0;

  		/* allocate context for thread safe pro*c */
		EXEC SQL CONTEXT ALLOCATE :db->ctx;

		/* create thread */
		db->tid = Cthread_create_detached((void *(*)(void *))db_worker, (database_t *)db);
		if (db->tid == APP_FAILURE) {
			log(LOG_EMERG, "db_init() - failed to Cthread_create_detached() : %s\n", sstrerror(serrno));
			return APP_FAILURE;
		}

		/* assign thread to database pool */
		dpool[i] = db;
	}

	/* initialise internal sequence numbers
	 *   - failure to determine the sequence numbers for tables dlf_messages, dlf_nshost_map and
	 *     dlf_host_map result in db_shutdown(). This error is unrecoverable!
	 */

	/* use the first thread in the pool */
	rv = db_open(dpool[0], 3);
	if (rv != APP_SUCCESS) {
		log(LOG_ERR, "db_init() - maximum connection attempts reached\n");
		return APP_FAILURE;
	}

	/* set context and error handling */
	Cthread_mutex_lock(&dpool[0]->mutex);

	SetActive(dpool[0]->mode);
	EXEC SQL WHENEVER SQLERROR GOTO error;
	EXEC SQL CONTEXT USE :dpool[0]->ctx;

	EXEC SQL SELECT seq_no INTO :seq_id       FROM dlf_sequences WHERE (seq_name = 'id');
	EXEC SQL SELECT seq_no INTO :seq_hostid   FROM dlf_sequences WHERE (seq_name = 'hostid');
	EXEC SQL SELECT seq_no INTO :seq_nshostid FROM dlf_sequences WHERE (seq_name = 'nshostid');

	dpool[0]->selects = 3;

        ClrActive(dpool[0]->mode);
	Cthread_mutex_unlock(&dpool[0]->mutex);

	/* unsuspend */
	ClrSuspendedDB(server_mode);

	return APP_SUCCESS;

error:

        /* get error message (thread-safe) */
        err_size = sizeof(err_msg);
        sqlglmt(dpool[0]->ctx, err_msg, &err_size, &err_len);

        EXEC SQL WHENEVER SQLERROR CONTINUE;

	strip_newline(err_msg, err_len);
        log(LOG_ERR, "db_init() : %.*s\n", err_len, err_msg);

        if ((sqlca.sqlcode == -12571) || (sqlca.sqlcode == -1012) || 
	    (sqlca.sqlcode == -1089)  || (sqlca.sqlcode == -3114) ||
	    (sqlca.sqlcode == -2131)  || (sqlca.sqlcode == -3113) ||
	    (sqlca.sqlcode == -12170) || (sqlca.sqlcode == -12541) ||
	    (sqlca.sqlcode == -1003)) {
                ClrConnected(dpool[0]->mode);
        }
        dpool[0]->errors++;
        ClrActive(dpool[0]->mode);

        Cthread_mutex_unlock(&dpool[0]->mutex);
        return APP_FAILURE;
}


/*
 * db_open
 */

int DLL_DECL db_open(database_t *db, unsigned int retries) {

	/* variables */
	struct  sqlca sqlca;
	char    username[100];
	char    password[100];
	char    database[100];
	char    buf[100];
	int     count;

	char    err_msg[512];
	size_t  err_size;
	size_t  err_len;

	FILE    *fp;

	/* initialise variables */
	username[0] = password[0] = database[0] = '\0';
	count = 0;

	/* connection already open */
	if (IsConnected(db->mode)) {
		return APP_SUCCESS;
	}

	/* throttle connection attempts */
	if (db->last_connect > (time(NULL) - 30)) {
		return APP_FAILURE;
	}

	/* try to establish a connection until the maximum number of retries has been reached */
	do {
		/* throttle the connection attempts */
		if (count != 0) {
			sleep(10);
		}
		count++;

		/* read connection string
		 *    - the string should be in the format <username>/<password>@<database>
		 *    - all parameters are mandatory and must not be blank
		 */
		fp = fopen(DLFCONFIG, "r");
		if (fp == NULL) {
			log(LOG_ERR, "db_open() - failed to open config '%s' : %s\n",
				DLFCONFIG, strerror(errno));
			continue;
		}

		/* read the first line */
		if (fgets(buf, sizeof(buf) - 1, fp) == NULL) {
			fclose(fp);
			continue;
		}

		fclose(fp);

		/* extract values */
		if (sscanf(buf, "%25[^/]/%25[^@]@%25s", username, password, database) != 3) {
			log(LOG_ERR, "db_open() - invalid connect string in '%s'\n", DLFCONFIG);
			continue;
		}
		db->last_connect = time(NULL);

		log(LOG_DEBUG, "db_open() - attempting connection to %s@%s\n", username, database);

		/* connect to database, set commits to not block
		 *   - http://www.oracle-base.com/articles/10g/Commit_10gR2.php
	 	 */
		EXEC SQL CONTEXT USE :db->ctx;
		EXEC SQL WHENEVER SQLERROR GOTO error;
		EXEC SQL CONNECT :username IDENTIFIED BY :password USING :database;
		EXEC SQL ALTER SESSION SET COMMIT_WRITE = 'NOWAIT';
		EXEC SQL ALTER SESSION SET NLS_DATE_FORMAT = 'YYYYMMDDHH24MISS';

		/* flag new connection status */	
		db->last_connect = 0;
		SetConnected(db->mode);
		if (!db->first_connect) {
			log(LOG_INFO, "db_open() - connection established to %s@%s\n", username, database);
		}
		db->first_connect = 0;

		return APP_SUCCESS;

	error:
		/* get error message (thread-safe) */
		err_size = sizeof(err_msg);
		sqlglmt(db->ctx, err_msg, &err_size, &err_len);

		strip_newline(err_msg, err_len);
		log(LOG_ERR, "db_open() : %.*s\n", err_len, err_msg);

		EXEC SQL WHENEVER SQLERROR CONTINUE;

	} while ((retries == 0) || (count < retries));

	return APP_FAILURE;
}


/*
 * Shutdown database layer
 */

int DLL_DECL db_shutdown(void) {

	/* variables */
	struct    sqlca sqlca;
	int       i;

	/* destroy database thread pool */
	for (i = 0; i < MAX_THREADS; i++) {
		if (dpool[i] != NULL) {

			/* commit all pending changes and disconnect from the database */
			Cthread_mutex_lock(&dpool[i]->mutex);

			EXEC SQL CONTEXT USE :dpool[i]->ctx;
			EXEC SQL COMMIT WORK RELEASE;
			EXEC SQL CONTEXT FREE :dpool[i]->ctx;

			/* free allocated structures */
			free(dpool[i]->mtable);
			free(dpool[i]->ntable);
			free(dpool[i]->stable);

			if (IsConnected(dpool[i]->mode)) {
				log(LOG_NOTICE, "db_shutdown() - connection closed\n");
			}
			Cthread_mutex_unlock(&dpool[i]->mutex);

			free(dpool[i]);
		}
	}

	/* destroy hashes */
	hash_destroy(hosthash,     (void *(*)(void *))free);
	hash_destroy(nshosthash,   (void *(*)(void *))free);
	hash_destroy(msgtexthash,  (void *(*)(void *))free);
	hash_destroy(facilityhash, (void *(*)(void *))free);

	return APP_SUCCESS;
}



/*
 * db_reset
 */

int DLL_DECL db_reset(void) {

	/* variables */
	int       i;

	/* reset the active state of all threads */
	for (i = 0; i < MAX_THREADS; i++) {
		if (dpool[i] == NULL)
			continue;
		ClrConnected(dpool[i]->mode);			
	}	

	return APP_SUCCESS;
}


/*
 * db_initfac
 */

int DLL_DECL db_initfac(char *facility, msgtext_t *texts[], int *fac_no) {

	/* variables */
	database_t *db;
	struct     sqlca sqlca;
	char       err_msg[512];
	char       *key   = NULL;
	size_t     err_size;
	size_t     err_len;
	int        i;
	int        rv;
	int        found;
	int        id;
	int        commit = 0;
	int        *value = NULL;
	void       *v     = NULL;

	/* attempt to find a database connection which is currently connected and not in a busy state
	 *   - if no connection can be found pick any connected connection
	 */
	for (i = 0, found = 0; i < MAX_THREADS; i++) {
		if (dpool[i] == NULL)
			continue;
		if (IsConnected(dpool[i]->mode) && !IsActive(dpool[i]->mode)) {
			found = 1;
			break;
		}
	}

	/* pick any ? */
	if (found != 1) {
		for (i = 0, found = 0; i < MAX_THREADS; i++) {
			if (dpool[i] == NULL)
				continue;
			if (IsConnected(dpool[i]->mode)) {
				found = 1;
				break;
			}
		}
	}

	/* no connections available ? */
	if (found == 0) {
		log(LOG_ERR, "db_initfac() - no database connections available\n");
		return APP_FAILURE;
	}
	db = dpool[i];

	/* inserting msg texts bypasses the central fifo queue and has priority over normal incoming
	 * data. As threads are heavily coupled to the queue concept it is necessary to hijack another
	 * threads db connection. This requires us to hold a mutex over the statistics data
	 *   - any delays here will impact insertion globally across the system
	 */
	Cthread_mutex_lock(&db->mutex);
	db->inits++;

	/* set context and error handling */
	SetActive(db->mode);
	EXEC SQL WHENEVER SQLERROR GOTO error;
	EXEC SQL WHENEVER NOTFOUND GOTO not_found;
	EXEC SQL CONTEXT USE :db->ctx;

	/* resolve the facility name to a number */
	rv = hash_search(facilityhash, facility, &v);
	if (rv == APP_SUCCESS) {
		*fac_no = *(int *)v;
	} else {
		db->selects++;
		EXEC SQL SELECT fac_no INTO :id FROM dlf_facilities WHERE fac_name = :facility;
	
		/* add new facility to hash */
		value  = malloc(sizeof(int));
		*value = id;
		hash_insert(facilityhash, facility, value);
		*fac_no = id;
	}

	/* the arrays msg_text array passed to this function cannot simply be inserted into the database
	 * checks must be performed first to determine whether the message is new to the system or
	 * already exists and requires an update.
	 */
	for (i = 0; i < DLF_MAX_MSGTEXTS; i++) {
		if (texts[i] == NULL)
			continue;

		/* construct hash lookup key */
		key = malloc(100 + strlen(texts[i]->msg_text));
		if (key == NULL) {
			log(LOG_CRIT, "db_initfac() - failed to malloc hash key for msgtexthash : %s", 
			    strerror(errno));
			db->errors++;
			Cthread_mutex_unlock(&db->mutex);
			return APP_FAILURE;
		}
		sprintf(key, "%d:%d:%s", *fac_no, texts[i]->msg_no, texts[i]->msg_text);

		/* entry already exists ? */
		rv = hash_search(msgtexthash, key, &v);
		if (rv != APP_SUCCESS) {
			db->selects++;
			EXEC SQL SELECT COUNT(*) INTO :found FROM dlf_msg_texts
			WHERE (fac_no = :fac_no) AND (msg_no = :texts[i]->msg_no);

			/* found entry ? */
			if (found) {
				db->updates++;

				EXEC SQL UPDATE dlf_msg_texts SET msg_text = :texts[i]->msg_text
				WHERE (fac_no = :fac_no) AND (msg_no = :texts[i]->msg_no);
			} else {
				db->inserts++;
			
				EXEC SQL INSERT INTO dlf_msg_texts (fac_no, msg_no, msg_text)
				VALUES (:fac_no, :texts[i]->msg_no, :texts[i]->msg_text);
			}
			commit = 1;

			/* update message text hash */
			value  = malloc(sizeof(int));
			*value = 1;
			hash_insert(msgtexthash, key, value);
		}
		free(key);
	}

	if (commit) {
		db->commits++;
		EXEC SQL COMMIT WORK;
	}

 	ClrActive(db->mode);

	Cthread_mutex_unlock(&db->mutex);
	return APP_SUCCESS;

not_found:

	EXEC SQL WHENEVER SQLERROR CONTINUE;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	ClrActive(db->mode);

	*fac_no = -1;
	if (key != NULL) {
		free(key);
	}
	Cthread_mutex_unlock(&db->mutex);
	return APP_FAILURE;

error:

	/* get error message (thread-safe) */
	err_size = sizeof(err_msg);
	sqlglmt(db->ctx, err_msg, &err_size, &err_len);

	EXEC SQL WHENEVER SQLERROR CONTINUE;

	strip_newline(err_msg, err_len);
	log(LOG_ERR, "db_initfac() : %.*s\n", err_len, err_msg);

	if ((sqlca.sqlcode == -12571) || (sqlca.sqlcode == -1012) || 
	    (sqlca.sqlcode == -1089)  || (sqlca.sqlcode == -3114) ||
	    (sqlca.sqlcode == -2131)  || (sqlca.sqlcode == -3113) ||
	    (sqlca.sqlcode == -12170) || (sqlca.sqlcode == -12541) ||
	    (sqlca.sqlcode == -1003)) {
		ClrConnected(db->mode);
	}

	db->errors++;
	ClrActive(db->mode);
	if (key != NULL) {
		free(key);
	}
	Cthread_mutex_unlock(&db->mutex);
	return APP_FAILURE;
}


/*
 * db_hostid
 */

int DLL_DECL db_hostid(database_t *db, char *hostname, int *id) {

        /* variables */
        struct    sqlca sqlca;
        char      err_msg[512];
        size_t    err_size;
        size_t    err_len;
        int       rv;
        int       hostid;
        int       *value = NULL;
        void      *v     = NULL;

        /* hostname defined ? */
        if (hostname == NULL) {
                return APP_FAILURE;
        }

        /* cached ? */
        rv = hash_search(hosthash, hostname, &v);
        if (rv == APP_SUCCESS) {
		*id = *(int *)v;
                return APP_SUCCESS;
        }

        Cthread_mutex_lock(&database_mutex);

        /* re-check the hash
         *   - the last thread may have inserted the data we are looking for.
         */
        rv = hash_search(hosthash, hostname, &v);
        if (rv == APP_SUCCESS) {
		*id = *(int *)v;
                Cthread_mutex_unlock(&database_mutex);
                return APP_SUCCESS;
        }

        /* set context and error handling */
        Cthread_mutex_lock(&db->mutex);

        SetActive(db->mode);
        EXEC SQL WHENEVER SQLERROR GOTO error;
        EXEC SQL WHENEVER NOTFOUND GOTO not_found;
        EXEC SQL CONTEXT USE :db->ctx;

        db->selects++;
   	EXEC SQL SELECT hostid INTO :hostid FROM dlf_host_map WHERE hostname = :hostname;
        ClrActive(db->mode);

        /* cache the value */
	value = malloc(sizeof(int));
	if (value == NULL) {
		log(LOG_CRIT, "db_hostid() - failed to malloc hash entry : %s", strerror(errno));

		db->errors++;
		Cthread_mutex_unlock(&db->mutex);
		Cthread_mutex_unlock(&database_mutex);

		return APP_FAILURE;
	}
	*value = hostid;

        hash_insert(hosthash, hostname, value);
        *id = hostid;

        Cthread_mutex_unlock(&db->mutex);
        Cthread_mutex_unlock(&database_mutex);

        return APP_SUCCESS;

not_found:

        /* insert a new host */
        hostid = seq_hostid++;

        EXEC SQL WHENEVER NOTFOUND CONTINUE;

        db->inserts++;
        EXEC SQL INSERT INTO dlf_host_map (hostid, hostname) VALUES (:hostid, :hostname);
        db->updates++;
        EXEC SQL UPDATE dlf_sequences SET seq_no = (seq_no + 1) WHERE seq_name = 'hostid';
        db->commits++;
        EXEC SQL COMMIT WORK;

        *id = hostid;
        ClrActive(db->mode);

        Cthread_mutex_unlock(&db->mutex);
        Cthread_mutex_unlock(&database_mutex);

        return APP_SUCCESS;

error:

        /* get error message (thread-safe) */
        err_size = sizeof(err_msg);
        sqlglmt(db->ctx, err_msg, &err_size, &err_len);

        EXEC SQL WHENEVER SQLERROR CONTINUE;

	strip_newline(err_msg, err_len);
        log(LOG_ERR, "db_hostid() : %.*s\n", err_len, err_msg);

        if ((sqlca.sqlcode == -12571) || (sqlca.sqlcode == -1012) || 
	    (sqlca.sqlcode == -1089)  || (sqlca.sqlcode == -3114) ||
	    (sqlca.sqlcode == -2131)  || (sqlca.sqlcode == -3113) ||
	    (sqlca.sqlcode == -12170) || (sqlca.sqlcode == -12541) ||
	    (sqlca.sqlcode == -1003)) {
                ClrConnected(db->mode);
        }
        db->errors++;

        db->rollbacks++;
        EXEC SQL ROLLBACK WORK;
        ClrActive(db->mode);

        Cthread_mutex_unlock(&db->mutex);
        Cthread_mutex_unlock(&database_mutex);

        return APP_FAILURE;
}


/* db_nshostid
 *   - this function is almost identical to db_hostid() apart from the querying of different tables and
 *     updating of different sequences. We could have created one generic function to do both hostnames
 *     and nshostnames but it would just be full of IF statements!!
 */

int DLL_DECL db_nshostid(database_t *db, char *hostname, int *id) {

	/* variables */
	struct    sqlca sqlca;
	char      err_msg[512];
	size_t    err_size;
	size_t    err_len;
	int       rv;
	int       nshostid;
	int       *value = NULL;
	void      *v     = NULL;

	/* hostname defined ? */
	if (hostname == NULL) {
		return APP_FAILURE;
	}

	/* cached ? */
	rv = hash_search(nshosthash, hostname, &v);
	if (rv == APP_SUCCESS) {
		*id = *(int *)v;
		return APP_SUCCESS;
	}

	Cthread_mutex_lock(&database_mutex);

	/* re-check the hash
	 *   - the last thread may have inserted the data we are looking for.
	 */
	rv = hash_search(nshosthash, hostname, &v);
	if (rv == APP_SUCCESS) {
		*id = *(int *)v;
		Cthread_mutex_unlock(&database_mutex);
		return APP_SUCCESS;
	}

	/* set context and error handling */
	Cthread_mutex_lock(&db->mutex);

	SetActive(db->mode);
	EXEC SQL WHENEVER SQLERROR GOTO error;
	EXEC SQL WHENEVER NOTFOUND GOTO not_found;
	EXEC SQL CONTEXT USE :db->ctx;

	db->selects++;
	EXEC SQL SELECT nshostid INTO :nshostid FROM dlf_nshost_map WHERE nshostname = :hostname;
	ClrActive(db->mode);

	/* cache the value */
	value = malloc(sizeof(int));
	if (value == NULL) {
		log(LOG_CRIT, "db_nshostid() - failed to malloc nshash entry : %s", strerror(errno));

		db->errors++;
		Cthread_mutex_unlock(&db->mutex);
		Cthread_mutex_unlock(&database_mutex);

		return APP_FAILURE;
	}
	*value = nshostid;

	hash_insert(nshosthash, hostname, value);
	*id = nshostid;

	Cthread_mutex_unlock(&db->mutex);
	Cthread_mutex_unlock(&database_mutex);

	return APP_SUCCESS;

not_found:

	/* insert a new host */
	nshostid = seq_nshostid++;

	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	db->inserts++;
	EXEC SQL INSERT INTO dlf_nshost_map (nshostid, nshostname) VALUES (:nshostid, :hostname);
	db->updates++;
	EXEC SQL UPDATE dlf_sequences SET seq_no = (seq_no + 1) WHERE seq_name = 'nshostid';
	db->commits++;
	EXEC SQL COMMIT WORK;

	*id = nshostid;
	ClrActive(db->mode);

	Cthread_mutex_unlock(&db->mutex);
	Cthread_mutex_unlock(&database_mutex);
	return APP_SUCCESS;

error:

	/* get error message (thread-safe) */
	err_size = sizeof(err_msg);
	sqlglmt(db->ctx, err_msg, &err_size, &err_len);

	EXEC SQL WHENEVER SQLERROR CONTINUE;

	strip_newline(err_msg, err_len);
	log(LOG_ERR, "db_nshostid() : %.*s\n", err_len, err_msg);

	if ((sqlca.sqlcode == -12571) || (sqlca.sqlcode == -1012) || 
	    (sqlca.sqlcode == -1089)  || (sqlca.sqlcode == -3114) ||
	    (sqlca.sqlcode == -2131)  || (sqlca.sqlcode == -3113) ||
	    (sqlca.sqlcode == -12170) || (sqlca.sqlcode == -12541) ||
	    (sqlca.sqlcode == -1003)) {
		ClrConnected(db->mode);
	}
	db->errors++;

	db->rollbacks++;
	EXEC SQL ROLLBACK WORK;
	ClrActive(db->mode);

	Cthread_mutex_unlock(&db->mutex);
	Cthread_mutex_unlock(&database_mutex);

	return APP_FAILURE;
}


/*
 * db_flush
 */

int DLL_DECL db_flush(database_t *db) {

        /* variables */
        struct    sqlca sqlca;
        char      err_msg[512];
        size_t    err_size;
        size_t    err_len;

        /* set context and error handling */
        Cthread_mutex_lock(&db->mutex);

        SetActive(db->mode);
        EXEC SQL WHENEVER NOTFOUND GOTO error;
        EXEC SQL WHENEVER SQLERROR GOTO error;
        EXEC SQL CONTEXT USE :db->ctx;

	log(LOG_DEBUG, "db_flush() called\n");

        /* table: dlf_messages */
        if (db->mtable->count) {
                EXEC SQL FOR :db->mtable->count
                INSERT INTO dlf_messages
                        (id, timestamp, timeusec, reqid, subreqid, hostid, facility, severity, msg_no, pid, tid, nshostid, nsfileid, tapevid, userid, groupid, sec_type, sec_name)
                VALUES (:db->mtable->id,
                        TO_DATE(:db->mtable->timestamp, 'YYYYMMDDHH24MISS'),
                        :db->mtable->timeusec,
                        :db->mtable->reqid,
			:db->mtable->subreqid,
                        :db->mtable->hostid,
                        :db->mtable->facility,
                        :db->mtable->severity,
                        :db->mtable->msg_no,
                        :db->mtable->pid,
                        :db->mtable->tid,
			:db->mtable->nshostid,
			TO_NUMBER(:db->mtable->nsfileid),
			:db->mtable->tapevid,
			:db->mtable->userid,
			:db->mtable->groupid,
			:db->mtable->stype,
			:db->mtable->sname);
        }

        /* table: dlf_num_param_values */
        if (db->ntable->count) {
                EXEC SQL FOR :db->ntable->count
                INSERT INTO dlf_num_param_values
                        (id, timestamp, name, value)
                VALUES (:db->ntable->id,
                        TO_DATE(:db->ntable->timestamp, 'YYYYMMDDHH24MISS'),
                        :db->ntable->parname,
                        TO_NUMBER(:db->ntable->parvalue));
        }

        /* table: dlf_str_param_values */
        if (db->stable->count) {
                EXEC SQL FOR :db->stable->count
                INSERT INTO dlf_str_param_values
                        (id, timestamp, name, value)
                VALUES (:db->stable->id,
                        TO_DATE(:db->stable->timestamp, 'YYYYMMDDHH24MISS'),
                        :db->stable->parname,
                        :db->stable->parvalue);
        }

	/* update the sequence number
         *   - this could have been done with a trigger, but this is costly for bulk inserts so we do
         *     it manually. We have to do a commit here otherwise deadlocks would occur
         */

        db->updates++;
        EXEC SQL UPDATE dlf_sequences SET seq_no = (seq_no + :db->mtable->count) WHERE seq_name = 'id';
        db->commits++;
        EXEC SQL COMMIT WORK;

        ClrActive(db->mode);

        Cthread_mutex_unlock(&db->mutex);
        return APP_SUCCESS;
        /* process any sql errors which may of occurred during the bulk insertion
         *   - these errors are rare so under these circumstances we rollback any changes and move onto
         *     the next set of data.
         *   - we could create a global error handler for sql queries but as the number of functions
         *     using embedded sql is low its easier to handler the issue here!
         */
error:

        /* get error message (thread-safe) */
        err_size = sizeof(err_msg);
        sqlglmt(db->ctx, err_msg, &err_size, &err_len);

        EXEC SQL WHENEVER SQLERROR CONTINUE;
        EXEC SQL WHENEVER NOTFOUND CONTINUE;

	strip_newline(err_msg, err_len);
        log(LOG_ERR, "db_flush() : %.*s\n", err_len, err_msg);

        if ((sqlca.sqlcode == -12571) || (sqlca.sqlcode == -1012) || 
	    (sqlca.sqlcode == -1089)  || (sqlca.sqlcode == -3114) ||
	    (sqlca.sqlcode == -2131)  || (sqlca.sqlcode == -3113) ||
	    (sqlca.sqlcode == -12170) || (sqlca.sqlcode == -12541) ||
	    (sqlca.sqlcode == -1003)) {
                ClrConnected(db->mode);
        }
        db->errors++;

        db->rollbacks++;
        EXEC SQL ROLLBACK WORK;
        ClrActive(db->mode);

        Cthread_mutex_unlock(&db->mutex);
        return APP_FAILURE;
}


/*
 * db_worker
 */

void DLL_DECL db_worker(database_t *db) {

	/* variables */
	struct timeval tv;
	message_t *message;
	param_t   *param;
	int       rv;
	int       i;

	/* initialise table and statistic variables */
	db->commits  = db->errors = db->inserts = db->rollbacks = db->updates = db->messages = 0;
	db->response = 0.0;

	db->mtable->count = 0;
	db->ntable->count = 0;
	db->stable->count = 0;

	/* worker thread
	 *   - extract messages from the central fifo queue and translate the messages into host arrays
	 *     required for oracle bulk insertion
	 */
	while (!IsShutdown(server_mode)) {

		/* server suspended ?
		 *    - this maybe a user suspension via a signal or we are still in an initialisation
	 	 *      determining the unique id for the first message, either way we sleep and loop
		 */
		if (IsSuspendedDB(server_mode)) {
			sleep(1);
			continue;
		}

		/* connected to database ? */
		if (!IsConnected(db->mode)) {
			if ((rv = db_open(db, 1)) != APP_SUCCESS) {
				sleep(1);
				continue;
			}
		}
		message = NULL;
		i       = 0;

		/* pop a message from the queue */
		rv = queue_pop(queue, (void **)&message);

		/* queue errors ? */
		if (rv == APP_QUEUE_TERMINATED) {
			break;                        /* queue terminated, shutdown  */
		}
		else if (rv == APP_QUEUE_EMPTY) {
			if ((time(NULL) - db->last_flush) < DB_FLUSH_TIME) {
				sleep(1);
				continue;             /* not time to flush the queue */
			}
			db->last_flush = 0;
		}
		else if (rv != APP_SUCCESS) {
			log(LOG_CRIT, "db_worker() - failed to queue_pop()\n");
			break;
		}

		/* count the number of rows this new message would insert
		 *   - this calculation is necessary before checking for the host arrays reaching max
		 *     capacity as if this message has enough parameters it could cause the arrays to
		 *     overflow resulting in a segmentation fault.
		 */
		if (message != NULL) {
			for (param = message->plist; param != NULL; param = param->next, i++);
		}

		/* host arrays reaching critical capacity ? */
		if ((db->mtable->count + i > DB_FLUSH_ROWS) || (db->ntable->count + i > DB_FLUSH_ROWS) ||
		    (db->stable->count + i > DB_FLUSH_ROWS) || (db->last_flush == 0)) {

			if (db->mtable->count != 0) {
				int i = (db->mtable->count + db->ntable->count + db->stable->count);

				rv = db_flush(db);
				Cthread_mutex_lock(&db->mutex);
				if (rv != APP_SUCCESS) {
					db->errors  += i;
				} else {
					db->inserts += i;
				}
				Cthread_mutex_unlock(&db->mutex);

				/* reset counters */
				db->mtable->count = 0;
				db->ntable->count = 0;
				db->stable->count = 0;
			}

			db->last_flush = time(NULL);
		}

		/* message defined ? */
		if (message == NULL) {
			continue;
		}

		Cthread_mutex_lock(&db->mutex);
		db->messages++;
		Cthread_mutex_unlock(&db->mutex);

		/* accumulate the sql response time */
		rv = gettimeofday(&tv, NULL);
		if (rv == APP_SUCCESS) {
			Cthread_mutex_lock(&db->mutex);
			db->response += ((((double)tv.tv_sec * 1000) +
				  	 ((double)tv.tv_usec / 1000)) - message->received) * 0.001;
			Cthread_mutex_unlock(&db->mutex);
		}

		/* determine the next available unique id (primary key)
		 *   - the next number in the oracle sequence is determined at initialisation and updated
		 *     using a global mutex.
		 *   - a failure here is a clear indicator that something serious has gone wrong and the
		 *     thread will exit.
		 */
		if ((rv = Cthread_mutex_lock(&database_mutex)) != APP_SUCCESS) {
			break;
		}

		db->mtable->id[db->mtable->count] = seq_id;
		seq_id++;

		/* release mutex lock */
		if ((rv = Cthread_mutex_unlock(&database_mutex)) != APP_SUCCESS) {
			break;
		}

		/* table: dlf_messages */
		db->mtable->facility[db->mtable->count] = message->facility;
		db->mtable->msg_no[db->mtable->count]   = message->msg_no;
		db->mtable->pid[db->mtable->count]      = message->pid;
		db->mtable->severity[db->mtable->count] = message->severity;
		db->mtable->tid[db->mtable->count]      = message->tid;
		db->mtable->timeusec[db->mtable->count] = message->timeusec;

		/* hostname resolution (nshostname, hostname)
		 *   - if an error occurs attempting to resolve the hostname to an id, we simply ignore
		 *     the message
		 */
		if (db_hostid(db, message->hostname,
			&db->mtable->hostid[db->mtable->count]) != APP_SUCCESS) {
			free_message(message);
			continue;
		}

		if (db_nshostid(db, message->nshostname,
			&db->mtable->nshostid[db->mtable->count]) != APP_SUCCESS) {
			free_message(message);
			continue;
		}

		/* strings */
		strcpy(db->mtable->timestamp[db->mtable->count], message->timestamp);
		strcpy(db->mtable->reqid[db->mtable->count], message->reqid);
		strcpy(db->mtable->nsfileid[db->mtable->count], message->nsfileid);
		strcpy(db->mtable->tapevid[db->mtable->count], "N/A");
		strcpy(db->mtable->stype[db->mtable->count], "N/A");
		strcpy(db->mtable->sname[db->mtable->count], "N/A");
		db->mtable->userid[db->mtable->count]  = -1;
		db->mtable->groupid[db->mtable->count] = -1;

		/* process parameters */
		for (param = message->plist; param != NULL; param = param->next) {
			switch (param->type) {

			/* table: dlf_str_param_values */
			case DLF_MSG_PARAM_STR: {
				db->stable->id[db->stable->count] = db->mtable->id[db->mtable->count];
				strcpy(db->stable->timestamp[db->stable->count], db->mtable->timestamp[db->mtable->count]);
				strncpy(db->stable->parname[db->stable->count], param->name, DLF_LEN_PARAMNAME);
				strncpy(db->stable->parvalue[db->stable->count], param->value, DLF_LEN_STRINGVALUE);
				db->stable->count++;
				break;
			}

			/* table: dlf_reqid_map */
			case DLF_MSG_PARAM_UUID: {
				strcpy(db->mtable->subreqid[db->mtable->count], param->value);
				break;
			}

			/* table: dlf_num_param_values */
			case DLF_MSG_PARAM_DOUBLE: {
				db->ntable->id[db->ntable->count] = db->mtable->id[db->mtable->count];
				strcpy(db->ntable->timestamp[db->ntable->count], db->mtable->timestamp[db->mtable->count]);
				strncpy(db->ntable->parname[db->ntable->count], param->name, DLF_LEN_PARAMNAME);
				strncpy(db->ntable->parvalue[db->ntable->count],param->value, DLF_LEN_NUMBERVALUE);
				db->ntable->count++;
				break;
			}

			/* table: dlf_num_param_values */
			case DLF_MSG_PARAM_INT64: {
				db->ntable->id[db->ntable->count] = db->mtable->id[db->mtable->count];
				strcpy(db->ntable->timestamp[db->ntable->count], db->mtable->timestamp[db->mtable->count]);
				strncpy(db->ntable->parname[db->ntable->count], param->name, DLF_LEN_PARAMNAME);
				strncpy(db->ntable->parvalue[db->ntable->count], param->value, DLF_LEN_NUMBERVALUE);
				db->ntable->count++;
				break;
			}

			/* table: dlf_num_param_values */
			case DLF_MSG_PARAM_INT: {
				db->ntable->id[db->ntable->count] = db->mtable->id[db->mtable->count];
				strcpy(db->ntable->timestamp[db->ntable->count], db->mtable->timestamp[db->mtable->count]);
				strncpy(db->ntable->parname[db->ntable->count], param->name, DLF_LEN_PARAMNAME);
				strncpy(db->ntable->parvalue[db->ntable->count], param->value, DLF_LEN_NUMBERVALUE);
				db->ntable->count++;
				break;
			}

			/* table: dlf_tape_ids */
			case DLF_MSG_PARAM_TPVID: {
				strncpy(db->mtable->tapevid[db->mtable->count], param->value, DLF_LEN_TAPEID);
				break;
			}

			/* security related */
			case DLF_MSG_PARAM_UID: {
				db->mtable->userid[db->mtable->count] = atoi(param->value);
				break;
			}

			case DLF_MSG_PARAM_GID: {
				db->mtable->groupid[db->mtable->count] = atoi(param->value);
				break;
			}
			
			case DLF_MSG_PARAM_STYPE: {
				strncpy(db->mtable->stype[db->mtable->count], param->value, DLF_LEN_STYPE);
				break;
			}

			case DLF_MSG_PARAM_SNAME: {
				strncpy(db->mtable->sname[db->mtable->count], param->value, DLF_LEN_SNAME);
				break;
			}

			/* we shouldn't get here, but if we do we simple stop processing the params and
			 * enter the message to the database as normal. We could rollback the host
			 * arrays if we want the data to have 100% integrity
			 */
			default:
				break;
			}
		}

		db->mtable->count++;

		/* free messages */
		free_message(message);
	}

	/* exit */
	Cthread_exit(0);
}


/*
 * db_monitoring
 */

int DLL_DECL db_monitoring(handler_t **hpool, unsigned int interval) {

	/* variables */
	database_t *db;
	struct     tm tm_str;
	struct     sqlca sqlca;
	char       err_msg[512];
	char       timestr[DLF_LEN_TIMESTAMP + 1];
	size_t     err_size;
	size_t     err_len;
	time_t     now;
	int        i;
	int        found;
	int        s_hosthash;
	int        s_nshosthash;

	/* database accumulated stats */
	int db_threads, h_threads, s_uptime;

	long long db_commits    = 0, db_errors    = 0, db_inserts  = 0, db_rollbacks = 0, db_hashstats = 0;
	long long db_selects    = 0, db_updates   = 0, db_cursors  = 0, db_messages  = 0, db_inits = 0;
	long long h_connections = 0, h_clientpeak = 0, h_messages  = 0, h_errors     = 0;
	long long h_inits       = 0, h_timeouts   = 0;

	unsigned int size = 0;
	double response   = 0.0;


	/* interval passed ? */
	if ((time(NULL) - last_monitoring) < interval) {
		return APP_SUCCESS;
	}
	last_monitoring = time(NULL);

        /* attempt to find a database connection which is currently connected and not in a busy state
         *   - if no connection can be found pick any connected connection
         */
        for (i = 0, found = 0; i < MAX_THREADS; i++) {
                if (dpool[i] == NULL)
                        continue;
                if (IsConnected(dpool[i]->mode) && !IsActive(dpool[i]->mode)) {
                        found = 1;
                        break;
                }
        }

        /* pick any ? */
        if (found != 1) {
                for (i = 0, found = 0; i < MAX_THREADS; i++) {
                        if (dpool[i] == NULL)
                                continue;
                        if (IsConnected(dpool[i]->mode)) {
                                found = 1;
                                break;
                        }
                }
        }
	db = dpool[i];

	/* handler based statistics */
	for (i = 0, h_threads = 0; i < MAX_THREADS; i++) {
		if (hpool[i] == NULL)
			continue;

		Cthread_mutex_lock(&hpool[i]->mutex);

		h_threads++;
		h_connections += hpool[i]->connections;
		h_clientpeak  += hpool[i]->clientpeak;
		h_messages    += hpool[i]->messages;
		h_inits       += hpool[i]->inits;
		h_errors      += hpool[i]->errors;
		h_timeouts    += hpool[i]->timeouts;

		hpool[i]->connections = hpool[i]->clientpeak = hpool[i]->timeouts = 0;
		hpool[i]->messages    = hpool[i]->inits      = hpool[i]->errors   = 0;

		Cthread_mutex_unlock(&hpool[i]->mutex);
	}

	/* database based statistics */
        for (i = 0, db_threads = 0; i < MAX_THREADS; i++) {
		if (dpool[i] == NULL)
                        continue;

		Cthread_mutex_lock(&dpool[i]->mutex);

		db_threads++;
		db_commits    += dpool[i]->commits;
		db_errors     += dpool[i]->errors;
		db_inserts    += dpool[i]->inserts;
		db_rollbacks  += dpool[i]->rollbacks;
		db_selects    += dpool[i]->selects;
		db_updates    += dpool[i]->updates;
		db_messages   += dpool[i]->messages;
		db_cursors    += dpool[i]->cursors;
		db_inits      += dpool[i]->inits;

		/* average response rate */
		if (dpool[i]->messages > 0) {
			response += (dpool[i]->response / dpool[i]->messages);
		}

		/* reset counters */
		dpool[i]->commits  = dpool[i]->errors  = dpool[i]->inserts  = dpool[i]->rollbacks = 0;
		dpool[i]->selects  = dpool[i]->updates = dpool[i]->messages = dpool[i]->cursors   = 0;
		dpool[i]->inits    = 0;
		dpool[i]->response = 0.0;

		Cthread_mutex_unlock(&dpool[i]->mutex);
	}

	if (response > 0) {
		response = (response / db_threads);
	}
	size = queue_size(queue);

	/* create the table timestamp */
	now = time(NULL);
	localtime_r(&now, &tm_str);
	strftime(timestr, DLF_LEN_TIMESTAMP + 1, "%Y%m%d%H%M%S", &tm_str);

	/* no database connections available ?
	 *   - we could have checked this earlier, however we need to reset the counters otherwise
	 *     overflows will occur
	 */
	if (found == 0) {
		log(LOG_ERR, "db_monitoring() : no database connections available\n");
		return APP_FAILURE;
	}

	/* calculate the hash statistics */
	s_hosthash   = hash_stat(hosthash);
	s_nshosthash = hash_stat(nshosthash);

	if ((s_hosthash != APP_FAILURE) && (s_nshosthash != APP_FAILURE)) {
		db_hashstats = s_hosthash + s_nshosthash;
	} else {
		db_hashstats = -1.0;
	}
	s_uptime = (time(NULL) - server_start);

	/* set context and error handling */
	Cthread_mutex_lock(&db->mutex);

	SetActive(db->mode);
	EXEC SQL WHENEVER SQLERROR GOTO error;
	EXEC SQL WHENEVER NOT FOUND GOTO error;
	EXEC SQL CONTEXT USE :db->ctx;

	db->inserts++;
	EXEC SQL INSERT INTO dlf_monitoring
	VALUES (TO_DATE(:timestr, 'YYYYMMDDHH24MISS'),
		:h_threads,    :h_messages,   :h_inits,      :h_errors,    :h_connections,
	 	:h_clientpeak, :h_timeouts,   :db_threads,   :db_commits,  :db_errors,
		:db_inserts,   :db_rollbacks, :db_selects,   :db_updates,  :db_cursors,
		:db_messages,  :db_inits,     :db_hashstats, :s_uptime,	   :server_mode,
		:size,	       :response,     :interval);

	db->commits++;
	EXEC SQL COMMIT WORK;

	ClrActive(db->mode);
	Cthread_mutex_unlock(&db->mutex);

	return APP_SUCCESS;

error:

	/* get error message (thread-safe) */
	err_size = sizeof(err_msg);
	sqlglmt(db->ctx, err_msg, &err_size, &err_len);

	EXEC SQL WHENEVER SQLERROR CONTINUE;

	strip_newline(err_msg, err_len);
	log(LOG_ERR, "db_monitoring() : %.*s\n", err_len, err_msg);

	if ((sqlca.sqlcode == -12571) || (sqlca.sqlcode == -1012) || 
	    (sqlca.sqlcode == -1089)  || (sqlca.sqlcode == -3114) ||
	    (sqlca.sqlcode == -2131)  || (sqlca.sqlcode == -3113) ||
	    (sqlca.sqlcode == -12170) || (sqlca.sqlcode == -12541) ||
	    (sqlca.sqlcode == -1003)) {
		ClrConnected(db->mode);
	}
	db->errors++;

	ClrActive(db->mode);

	Cthread_mutex_unlock(&db->mutex);
	return APP_FAILURE;
}


/*
 * db_mode
 */

int DLL_DECL db_mode(unsigned int interval) {

	/* variables */
	database_t *db;
	struct     sqlca sqlca;
	char       err_msg[512];
	char       name[20];
	int        status;
	size_t     err_size;
	size_t     err_len;
	int        i;
	int        found;

	/* interval passed ? */
	if ((time(NULL) - last_mode) < interval) {
		return APP_SUCCESS;
	}
	last_mode = time(NULL);

        /* attempt to find a database connection which is currently connected and not in a busy state
         *   - if no connection can be found pick any connected connection
         */
        for (i = 0, found = 0; i < MAX_THREADS; i++) {
                if (dpool[i] == NULL)
                        continue;
                if (IsConnected(dpool[i]->mode) && !IsActive(dpool[i]->mode)) {
                        found = 1;
                        break;
                }
        }

        /* pick any ? */
        if (found != 1) {
                for (i = 0, found = 0; i < MAX_THREADS; i++) {
                        if (dpool[i] == NULL)
                                continue;
                        if (IsConnected(dpool[i]->mode)) {
                                found = 1;
                                break;
                        }
                }
        }
	db = dpool[i];

	if (found == 0) {
		log(LOG_ERR, "db_mode() : no database connections available\n");
		return APP_FAILURE;
	}

	/* set context and error handling */
	Cthread_mutex_lock(&db->mutex);

	SetActive(db->mode);
	EXEC SQL WHENEVER SQLERROR GOTO error;
	EXEC SQL CONTEXT USE :db->ctx;

	db->selects++;
	EXEC SQL DECLARE status1 CURSOR FOR
		SELECT name, enabled 
		FROM   dlf_mode;

	/* set error handling and open cursor */
	EXEC SQL WHENEVER NOT FOUND GOTO end_status1;
	db->cursors++;
	EXEC SQL OPEN status1;

	/* loop over cursor results */
	while (sqlca.sqlcode == 0) {
		EXEC SQL FETCH status1 INTO :name, :status;

		/* process the status */
		if (!strcasecmp(name, "queue_purge")) {
			if (status) SetServerPurge(server_mode);
			else ClrServerPurge(server_mode);
		} 
		if (!strcasecmp(name, "queue_suspend")) {
			if (status) SetSuspendedQueue(server_mode);
			else ClrSuspendedQueue(server_mode);
		} 
		if (!strcasecmp(name, "database_suspend")) {
			if (status) SetSuspendedDB(server_mode);
			else ClrSuspendedDB(server_mode);
		} 	
	}

end_status1:

	EXEC SQL CLOSE status1;

	ClrActive(db->mode);
	Cthread_mutex_unlock(&db->mutex);

	return APP_SUCCESS;
	
error:

	/* get error message (thread-safe) */
	err_size = sizeof(err_msg);
	sqlglmt(db->ctx, err_msg, &err_size, &err_len);

	EXEC SQL WHENEVER SQLERROR CONTINUE;

	strip_newline(err_msg, err_len);
	log(LOG_ERR, "db_mode() : %.*s\n", err_len, err_msg);

	if ((sqlca.sqlcode == -12571) || (sqlca.sqlcode == -1012) || 
	    (sqlca.sqlcode == -1089)  || (sqlca.sqlcode == -3114) ||
	    (sqlca.sqlcode == -2131)  || (sqlca.sqlcode == -3113) ||
	    (sqlca.sqlcode == -12170) || (sqlca.sqlcode == -12541) ||
	    (sqlca.sqlcode == -1003)) {
		ClrConnected(db->mode);
	}

	/* close cursor */
	EXEC SQL CLOSE status1;

	db->errors++;
	ClrActive(db->mode);

	Cthread_mutex_unlock(&db->mutex);
	return APP_FAILURE;
}


/** End-of-File **/

