/*
 * 
 * Copyright (C) 2003 by CERN/IT/ADC
 * All rights reserved
 *
 */

#ifndef lint
static char sccsid[] = "@(#)$RCSfile: dlf_oracle_ifce.pc,v $ $Revision: 1.17 $ $Date: 2006/01/16 14:55:21 $ CERN-IT $Author: motiakov $";
#endif /* not lint */

#include <errno.h>
#include <string.h>
#include <time.h>
#include <sys/types.h>
#include <stdlib.h>
#include <sqlca.h>
#ifndef USE_ORACLE
#define USE_ORACLE
#endif
#include "serrno.h"
#include "u64subr.h"
#include "dlf.h"
#include "dlf_server.h"
#include "dlf_api.h"
#include "Cuuid.h"

extern int num_THR;
extern int DLFBUFMESSAGES;
extern int DLFBUFPARAM;

/* related with "message_seq increment by" number in the dlf_oracle_tbl.sql script*/
#define DLF_MESSAGE_SEQ_INCREMENT 100

/* commit time in seconds */
#define DLF_TIME_TO_COMMIT 1
time_t commit_time=0;

sql_context *ctx;

dlf_init_dbpkg()
{
	int i;
	char *func = "dlf_init_dbpkg";

	if ((ctx = calloc(num_THR,sizeof(sql_context))) == NULL) {
		dlflogit (func, "calloc error (%s)\n", strerror(errno));
		return(-1);
	}
	EXEC SQL ENABLE THREADS;
	for (i = 0; i < num_THR; i++) {
		EXEC SQL CONTEXT ALLOCATE :ctx[i];
	}
        
	return (0);
}

EXEC SQL CONTEXT USE :ctx[dbfd->idx];

dlf_abort_tr(dbfd)
struct dlf_dbfd *dbfd;
{
	EXEC SQL ROLLBACK WORK;
	dbfd->tr_started = 0;
	return (0);
}

dlf_closedb(dbfd)
struct dlf_dbfd *dbfd;
{
	EXEC SQL CONTEXT FREE :ctx[dbfd->idx];
	return (0);
}

dlf_end_tr(dbfd)
struct dlf_dbfd *dbfd;
{
	EXEC SQL COMMIT WORK;
	dbfd->tr_started = 0;
	return (0);
}

dlf_end_tr_nocommit(dbfd)
struct dlf_dbfd *dbfd;
{
	
	dbfd->tr_started = 0;
	return (0);
}

dlf_opendb(db_srvr, db_user, db_pwd, dbfd)
char *db_srvr;
char *db_user;
char *db_pwd;
struct dlf_dbfd *dbfd;
{
	int c;
	char func[16];
	int ntries;
	struct sqlca sqlca;

	strcpy (func, "dlf_opendb");
	ntries = 0;
	while (1) {
		EXEC SQL CONNECT :db_user IDENTIFIED BY :db_pwd USING :db_srvr;
		if (sqlca.sqlcode == 0)
                   {
                   return(0);
                   }
		if (sqlca.sqlcode != -1014 && sqlca.sqlcode != -1033 &&
		    sqlca.sqlcode != -1034) break;
		if (ntries++ >= MAXRETRY) break;
		sleep (RETRYI);
	}
	dlflogit (func, "CONNECT error: %.*s\n", sqlca.sqlerrm.sqlerrml,
	    sqlca.sqlerrm.sqlerrmc);
	serrno = SEINTERNAL;
	return (-1);
}

dlf_start_tr(s, dbfd)
int s;
struct dlf_dbfd *dbfd;
{
	dbfd->tr_started = 1;
	return (0);
}

dlf_delete_facility_entry (dbfd, fac_name)
struct dlf_dbfd* dbfd;
const char* fac_name;
{
	char func[32];
	struct sqlca sqlca;
	
	strcpy (func, "dlf_delete_facility_entry");
	EXEC SQL DELETE FROM dlf_facilities WHERE fac_name = :fac_name;

        switch (sqlca.sqlcode) {
        case 0:
                return (0);
        case -2292:
                serrno =  EDLFREFEXIST;
                break;
	case 1403:
		serrno =  EDLFNOTFOUND;
		break;
        case -3113:
        case -3114:
        case -12571:
                serrno =  EDLFNOTCONNECTED;
                break;
	default:
		dlflogit ( func, "DELETE error: %.*s\n",
			 sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc);
		serrno = SEINTERNAL;
		break;
	}
	return (-1);
}

dlf_delete_text_entry (dbfd, fac_name, txt_no)
struct dlf_dbfd* dbfd;
const char* fac_name;
int txt_no;
{
	char func[25];
	struct sqlca sqlca;

	strcpy(func, "dlf_delete_text_entry");
	EXEC SQL DELETE FROM dlf_msg_texts WHERE fac_no =
		(SELECT fac_no FROM dlf_facilities WHERE fac_name = :fac_name)
		AND msg_no = :txt_no;	

        switch (sqlca.sqlcode) {
        case 0:
                return (0);
        case 1403:
                serrno =  EDLFNOTFOUND;
                break;
        case -3113:
        case -3114:
        case -12571:
                serrno =  EDLFNOTCONNECTED;
                break;        
        default:
		dlflogit ( func, "DELETE error: %.*s\n", sqlca.sqlerrm.sqlerrml,
			sqlca.sqlerrm.sqlerrmc);
		serrno = SEINTERNAL;
		break;
	}
	return (-1);
}

dlf_insert_facility_entry (dbfd, fac_no, fac_name)
struct dlf_dbfd* dbfd;
int fac_no;
const char* fac_name;
{
	char func[32];
	struct sqlca sqlca;

	strcpy(func, "dlf_insert_facility_entry");
	EXEC SQL INSERT INTO dlf_facilities
		(fac_no, fac_name) VALUES (:fac_no, :fac_name);
	switch (sqlca.sqlcode) {
	case 0:
		return (0);
	case -1:
		serrno = EEXIST;
		break;
	case -1631:
	case -1632:
	case -1654:
		serrno = ENOSPC;
		break;
        case -3113:
        case -3114:
        case -12571:
                serrno =  EDLFNOTCONNECTED;
                break;        
	default:
		dlflogit (func, "INSERT error: %.*s\n", sqlca.sqlerrm.sqlerrml,
			sqlca.sqlerrm.sqlerrmc);
		serrno = SEINTERNAL;
	}
	return (-1);
}

dlf_insert_text_entry (dbfd, fac_name, msg_no, msg_txt)
struct dlf_dbfd* dbfd;
const char* fac_name;
int msg_no;
const char* msg_txt;
{
	char func[32];
	struct sqlca sqlca;
	DBLISTPTR dblistptr;
	int fac_no;

	strcpy(func, "dlf_insert_text_entry");

	if (dlf_get_facility_no (dbfd, fac_name, &fac_no, &dblistptr) != 0)
		return (-1);

	EXEC SQL INSERT INTO dlf_msg_texts (fac_no, msg_no, msg_text)
		VALUES (:fac_no, :msg_no, :msg_txt);

	switch (sqlca.sqlcode) {
	case 0:
		return (0);
	case -1:
		serrno = EEXIST;
		break;
	case -1631:
	case -1632:
	case -1654:
		serrno = ENOSPC;
		break;
        case -3113:
        case -3114:
        case -12571:
                serrno =  EDLFNOTCONNECTED;
                break;        
	default:
		dlflogit (func, "INSERT error: %.*s\n", sqlca.sqlerrm.sqlerrml,
			sqlca.sqlerrm.sqlerrmc);
		serrno = SEINTERNAL;
	}
	return (-1);
}

dlf_get_facility_entry (dbfd, bol, fac_no, fac_name, endlist, dblistptr)
struct dlf_dbfd* dbfd;
int bol;
int* fac_no;
char* fac_name;
int endlist;
DBLISTPTR* dblistptr;
{

	char func[32];
	struct sqlca sqlca;
	char fname[DLF_MAXFACNAMELEN + 1];

	EXEC SQL DECLARE l_fac_cursor CURSOR FOR
		SELECT fac_no, fac_name
		FROM dlf_facilities
		ORDER BY fac_no;


	strcpy(func, "dlf_get_facility_entry");
	if (endlist) {
		return (1);
	}
	if (bol) {
		EXEC SQL OPEN l_fac_cursor;
		if (sqlca.sqlcode) {
			dlflogit (func, "OPEN CURSOR error: %.*s\n",
				sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc);
			serrno = SEINTERNAL;
			return (-1);
		}
	}
	EXEC SQL FETCH l_fac_cursor INTO
		:*fac_no, :fname;
	switch (sqlca.sqlcode) {
	case 0:
		strcpy (fac_name, fname);
		return(0);
	case 1403:
		return(1);
        case -3113:
        case -3114:
        case -12571:
                serrno =  EDLFNOTCONNECTED;
                return (-1);
	default:
		dlflogit(func, "FETCH error: %.*s\n", sqlca.sqlerrm.sqlerrml,
			sqlca.sqlerrm.sqlerrmc);
		serrno = SEINTERNAL;
		return(-1);
	}
}

dlf_get_text_entry (dbfd, bol, fac_no, msg_no, msg_text, endlist, dblistptr)
struct dlf_dbfd* dbfd;
int bol;
int fac_no;
int* msg_no;
char* msg_text;
int endlist;
DBLISTPTR* dblistptr;
{

	char func[23];
	struct sqlca sqlca;
	char mtext[DLF_MAXSTRVALLEN + 1];

	EXEC SQL DECLARE l_text_cursor CURSOR FOR
		SELECT msg_no, msg_text
		FROM dlf_msg_texts
		WHERE fac_no = :fac_no
		ORDER BY msg_no;
	strcpy(func, "dlf_get_text_entry");

	if (endlist) {
		return (1);
	}
	if (bol) {
		EXEC SQL OPEN l_text_cursor;
		if (sqlca.sqlcode) {
			dlflogit (func, "OPEN CURSOR error: %.*s\n",
				sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc);
			serrno = SEINTERNAL;
			return (-1);
		}
	}
	EXEC SQL FETCH l_text_cursor INTO
		:*msg_no, :mtext;
	switch (sqlca.sqlcode) {
	case 0:
		strcpy (msg_text, mtext);
		return(0);
	case 1403:
		return(1);
        case -3113:
        case -3114:
        case -12571:
                serrno =  EDLFNOTCONNECTED;
                return(-1);
	default:
		dlflogit(func, "FETCH error: %.*s\n", sqlca.sqlerrm.sqlerrml,
			sqlca.sqlerrm.sqlerrmc);
		serrno = SEINTERNAL;
		return(-1);
	}
}

dlf_modify_facility_entry (dbfd, fac_name, fac_no)
struct dlf_dbfd* dbfd;
const char* fac_name;
int fac_no;
{

	char func[32];
	struct sqlca sqlca;
	
	strcpy (func, "dlf_modify_facility_entry");
	EXEC SQL UPDATE dlf_facilities SET
		fac_name = :fac_name WHERE fac_no = :fac_no;
        switch (sqlca.sqlcode) {
        case 0:
                return (0);
        case -2292:
                serrno =  EDLFREFEXIST;
                break;
        case 1403:
                serrno =  EDLFNOTFOUND;
                break;
        case -3113:
        case -3114:
        case -12571:
                serrno =  EDLFNOTCONNECTED;
                break;
        default:
		dlflogit (func, "UPDATE error: %.*s\n", sqlca.sqlerrm.sqlerrml,
			sqlca.sqlerrm.sqlerrmc);
		serrno = SEINTERNAL;
		break;
	}
	return (-1);
}

dlf_modify_text_entry (dbfd, fac_name, msg_no, msg_txt)
struct dlf_dbfd* dbfd;
const char* fac_name;
int msg_no;
const char* msg_txt;
{

	char func[32];
	struct sqlca sqlca;

	strcpy(func, "dlf_modify_text_entry");
	EXEC SQL UPDATE dlf_msg_texts SET
		msg_text = :msg_txt WHERE fac_no = 
		(SELECT fac_no FROM dlf_facilities WHERE fac_name = :fac_name)
		AND msg_no = :msg_no;

	switch (sqlca.sqlcode) {
	case 0:
		return (0);
	case 1403:
		serrno =  EDLFNOTFOUND;
		break;
        case -3113:
        case -3114:
        case -12571:
                serrno =  EDLFNOTCONNECTED;
                break;        
	default:
		dlflogit (func, "UPDATE error: %.*s\n", sqlca.sqlerrm.sqlerrml,
			sqlca.sqlerrm.sqlerrmc);
		serrno = SEINTERNAL;
		break;
	}
	return (-1);
}

dlf_get_facility_no (dbfd, facname, fac_no, dblistptr)
struct dlf_dbfd* dbfd;
const char* facname;
int* fac_no;
DBLISTPTR* dblistptr;
{
	char func[23];
	struct sqlca sqlca;
	EXEC SQL DECLARE l_facno_cursor CURSOR FOR
		SELECT fac_no
		FROM dlf_facilities
		WHERE fac_name = :facname;

	strcpy(func, "dlf_get_facility_no");
	EXEC SQL OPEN l_facno_cursor;
	if (sqlca.sqlcode) {
		dlflogit (func, "OPEN CURSOR error: %.*s\n",
			sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc);
		serrno = SEINTERNAL;
		return (-1);
	}

	EXEC SQL FETCH l_facno_cursor INTO :*fac_no;
	switch (sqlca.sqlcode) {
	case 0:
		return(0);
	case 1403:
		serrno = EDLFNOFAC;
		return(1);
        case -3113:
        case -3114:
        case -12571:
                serrno =  EDLFNOTCONNECTED;
                break;        
	default:
		dlflogit(func, "FETCH error: %.*s\n", sqlca.sqlerrm.sqlerrml,
			sqlca.sqlerrm.sqlerrmc);
		serrno = SEINTERNAL;
		return(-1);
	}

}


char arr_get_host_id_hostname[DLFBUFHOSTID][64];
int arr_get_host_id_hostid[DLFBUFHOSTID];
int bufptr_get_host_id=0;

dlf_get_host_id (dbfd, hostname, host_id, dblistptr)
struct dlf_dbfd* dbfd;
const char* hostname;
int* host_id;
DBLISTPTR* dblistptr;
{
        int i;
	char func[23];
        struct sqlca sqlca;
/* buffering bug       
        for(i=0;i<DLFBUFHOSTID;i++)
           if(strcmp(arr_get_host_id_hostname[i],hostname)==0) {*host_id=arr_get_host_id_hostid[i];return (0);}
  */      
	strcpy(func, "dlf_get_host_id");
        
        EXEC SQL SELECT host_id INTO :*host_id FROM dlf_host_map WHERE host_name=:hostname;  
        
        switch (sqlca.sqlcode) 
           {
           case 0:
              /* buffering bug
              strcpy(arr_get_host_id_hostname[bufptr_get_host_id],hostname);
              arr_get_host_id_hostid[bufptr_get_host_id]=*host_id;
              if(bufptr_get_host_id==(DLFBUFHOSTID-1)) bufptr_get_host_id=0;
              else bufptr_get_host_id++; */
              return(0);
           case 1403:
              return(1);
           case -3113:
           case -3114:
           case -12571:
              serrno =  EDLFNOTCONNECTED;
              return(-1);        
           default:
             dlflogit(func, "FETCH error: %.*s\n", sqlca.sqlerrm.sqlerrml,sqlca.sqlerrm.sqlerrmc);
             serrno = SEINTERNAL;
             return(-1);
           }
    }


char arr_get_ns_host_id_hostname[DLFBUFNSHOSTID][64];
int arr_get_ns_host_id_hostid[DLFBUFNSHOSTID];
int bufptr_get_ns_host_id=0;


dlf_get_ns_host_id (dbfd, hostname, host_id, dblistptr)
struct dlf_dbfd* dbfd;
const char* hostname;
int* host_id;
DBLISTPTR* dblistptr;
{
        int i;
	char func[23];
        struct sqlca sqlca;
/* buffering bug
        for(i=0;i<DLFBUFNSHOSTID;i++)
           if(strcmp(arr_get_ns_host_id_hostname[i],hostname)==0) {*host_id=arr_get_ns_host_id_hostid[i];return (0);}
        */
	strcpy(func, "dlf_get_ns_host_id");

        EXEC SQL SELECT ns_host_id INTO :*host_id FROM dlf_ns_host_map WHERE ns_host_name=:hostname;
        
        switch (sqlca.sqlcode)
           {
           case 0:
          /* buffering bug
              strcpy(arr_get_ns_host_id_hostname[bufptr_get_ns_host_id],hostname);
              arr_get_ns_host_id_hostid[bufptr_get_ns_host_id]=*host_id;
              if(bufptr_get_ns_host_id==(DLFBUFNSHOSTID-1)) bufptr_get_ns_host_id=0;
              else bufptr_get_ns_host_id++; */
              return(0);
           case 1403:
              return(1);
           case -3113:
           case -3114:
           case -12571:
              serrno =  EDLFNOTCONNECTED;
              return(-1);        
           default:
              dlflogit(func, "FETCH error: %.*s\n", sqlca.sqlerrm.sqlerrml,sqlca.sqlerrm.sqlerrmc);
              serrno = SEINTERNAL;
              return(-1);
           }
}

dlf_get_curr_host_sequence(dbfd, seq_no)
struct dlf_dbfd *dbfd;
int *seq_no;
{
        char func[32];
        struct sqlca sqlca;
       
        strcpy(func, "dlf_get_curr_host_sequence");
        EXEC SQL SELECT host_seq.currval INTO :*seq_no FROM dual;
        switch (sqlca.sqlcode) {
        case 0:
                return(0);
        case 1403:
                return(1);
        case -3113:
        case -3114:
        case -12571:
                serrno =  EDLFNOTCONNECTED;
                return(-1);        
        default:
                dlflogit(func, "FETCH error: %.*s\n", sqlca.sqlerrm.sqlerrml,
                        sqlca.sqlerrm.sqlerrmc);
                serrno = SEINTERNAL;
                return(-1);
        }
}

dlf_get_curr_ns_host_sequence(dbfd, seq_no)
struct dlf_dbfd *dbfd;
int *seq_no;
{
        char func[32];
        struct sqlca sqlca;

        strcpy(func, "dlf_get_curr_ns_host_sequence");
        EXEC SQL SELECT ns_host_seq.currval INTO :*seq_no FROM dual;
        switch (sqlca.sqlcode) {
        case 0:
                return(0);
        case 1403:
                return(1);
        case -3113:
        case -3114:
        case -12571:
                serrno =  EDLFNOTCONNECTED;
                return(-1);        
        default:
                dlflogit(func, "FETCH error: %.*s\n", sqlca.sqlerrm.sqlerrml,
                        sqlca.sqlerrm.sqlerrmc);
                serrno = SEINTERNAL;
                return(-1);
        }
}

dlf_insert_message_entry(thread_info, log_message)
struct dlf_srv_thread_info *thread_info;
dlf_log_message_t *log_message;
{
        
        unsigned long tmpnummsg;
        struct dlf_dbfd *dbfd;
   
	int rv;
	int host_id;
	int ns_host_id;
	char func[32];
	char rq_id_str[CUUID_STRING_LEN+1];
	char subrq_id_str[CUUID_STRING_LEN+1];
	int resuuid;
	dlf_msg_param_t *param;
	DBLISTPTR dblistptr;
	int sev;
	int fac;
	int msn;
	char nsi_str[24];
	char par_str[24];
	struct tm tmres;
	char time_str[32];
	int n;
	struct sqlca sqlca;
        
        strcpy (func, "dlf_insert_message_entry");
        dbfd=&thread_info->dbfd;
        /* Try to obtain the host id from the database */
	rv =  dlf_get_host_id (dbfd, log_message->hostname, &host_id, &dblistptr);

	if (rv < 0)  return (-1);
	if (rv == 1)
           { /* Not found in the table */

	    /* Try to insert new host in the table */

	    EXEC SQL LOCK dlf_host_map IN EXCLUSIVE MODE;
	    EXEC SQL INSERT INTO dlf_host_map (host_id, host_name)
                VALUES (host_seq.nextval, :log_message->hostname);
	    serrno = 0;
	    if (sqlca.sqlcode)
               {
	       switch (sqlca.sqlcode)
	          {
	    	    case -1:
			serrno = EEXIST;
			break;
		    case -1631:
		    case -1632:
		    case -1654:
			serrno = ENOSPC;
			break;
                    case -3113:
                    case -3114:
                    case -12571:
                        serrno = EDLFNOTCONNECTED;
                        break;    
	    	    default:
			dlflogit (func, "INSERT host error: %.*s\n", sqlca.sqlerrm.sqlerrml,
			sqlca.sqlerrm.sqlerrmc);
			serrno = SEINTERNAL;
	    	   }
	    	if (serrno != EEXIST) return (-1);
	       }
	    /* Obtain host id */
	    if (serrno == EEXIST) { rv =  dlf_get_host_id (dbfd, log_message->hostname, &host_id, &dblistptr);  }
	    else { rv = dlf_get_curr_host_sequence(dbfd, &host_id);  }
 	    if (rv != 0) 
               {
	       dlflogit (func, "Get HOST ID Error.\n");
	       return (-1);
	       }
	   }
	/* Try to obtain the name server host id from the database */
	rv =  dlf_get_ns_host_id (dbfd, log_message->ns_fileid.server, &ns_host_id, &dblistptr);

	if (rv < 0)
	  return (-1);
	if (rv == 1) { /* Not found in the table */

	    /* Try to insert new host in the table */

	    EXEC SQL LOCK dlf_ns_host_map IN EXCLUSIVE MODE;
	    EXEC SQL INSERT INTO dlf_ns_host_map (ns_host_id, ns_host_name)
                VALUES (ns_host_seq.nextval, :log_message->ns_fileid.server);
	    serrno = 0;
	    if (sqlca.sqlcode) {
		switch (sqlca.sqlcode)
		{
	    	    case -1:
			serrno = EEXIST;
			break;
		    case -1631:
		    case -1632:
		    case -1654:
			serrno = ENOSPC;
			break;
                    case -3113:
                    case -3114:
                    case -12571:
                        serrno =  EDLFNOTCONNECTED;
                        break;
	    	    default:
			dlflogit (func, "INSERT name server host error: %.*s\n", sqlca.sqlerrm.sqlerrml,
			sqlca.sqlerrm.sqlerrmc);
			serrno = SEINTERNAL;
	    	}
	    	if (serrno != EEXIST) return (-1);
	    }
	    /* Obtain host id */
	    if (serrno == EEXIST) {
		rv =  dlf_get_ns_host_id (dbfd, log_message->ns_fileid.server, &ns_host_id, &dblistptr);
	    }
	    else {
	        rv = dlf_get_curr_ns_host_sequence(dbfd, &ns_host_id);
	    }
 	    if (rv != 0) {
		dlflogit (func, "Get NS HOST ID Error.\n");
		return (-1);
	    }
	}

	/* Convert uuid to hex string */
	resuuid = Cuuid2string(rq_id_str, sizeof(rq_id_str), &log_message->request_id);
	if (resuuid < 0) {
	    serrno = SEINTERNAL;
	    return (-1);
	}
	/* Insert message into database */

	msn = log_message->message_no;
	fac = log_message->facility_no;
	sev = log_message->severity;
	(void) u64tostr (log_message->ns_fileid.fileid, nsi_str, -1);

        strcpy(thread_info->arr_time[thread_info->nummsg],log_message->time);
        thread_info->arr_time_usec[thread_info->nummsg]=log_message->time_usec;
        strcpy(thread_info->arr_req_id[thread_info->nummsg],rq_id_str);
        thread_info->arr_host_id[thread_info->nummsg]=host_id;
        thread_info->arr_ns_host_id[thread_info->nummsg]=ns_host_id;
        thread_info->arr_facility[thread_info->nummsg]=fac;
        thread_info->arr_severity[thread_info->nummsg]=sev;
        thread_info->arr_msg_no[thread_info->nummsg]=msn;
        thread_info->arr_pid[thread_info->nummsg]=log_message->pid;
        thread_info->arr_thread_id[thread_info->nummsg]=log_message->cid;
        strcpy(thread_info->arr_ns_file_id[thread_info->nummsg],nsi_str);
        
        if(thread_info->seq_pos>=DLF_MESSAGE_SEQ_INCREMENT)
           {          
           EXEC SQL SELECT message_seq.nextval INTO :thread_info->seq_num FROM dual;
           thread_info->seq_pos=0;
           }
        
        thread_info->arr_msgseq_no[thread_info->nummsg]=thread_info->seq_num+thread_info->seq_pos;
        thread_info->seq_pos++;
        tmpnummsg=thread_info->nummsg;
        
	/* Insert parameters into the database */
	for (param = log_message->param_list.head; param != NULL; param = param->next) 
           {
	   switch (param->type) 
              {
	      case DLF_MSG_PARAM_STR:
                 thread_info->arr_msg_seq_num_str_param[thread_info->numparamstr]=thread_info->arr_msgseq_no[tmpnummsg]; 
                 strncpy(thread_info->arr_param_str_par_name[thread_info->numparamstr],param->name,20);
                 thread_info->arr_param_str_par_name[thread_info->numparamstr][20]='\0';
                 strncpy(thread_info->arr_param_str_val[thread_info->numparamstr],param->strval,255);
                 thread_info->arr_param_str_val[thread_info->numparamstr][255]='\0';
                 thread_info->numparamstr++;
                 if((DLFBUFPARAM-20)<thread_info->numparamstr) thread_info->param_tag=1;
                 if(thread_info->numparamstr>=DLFBUFPARAM)
                    {
                    serrno = SEINTERNAL;
		    return (-1);
                    }
		 break;
	      case DLF_MSG_PARAM_TPVID:
                 thread_info->arr_msg_seq_num_tpvid[thread_info->numtpvid]=thread_info->arr_msgseq_no[tmpnummsg];
                 strcpy(thread_info->arr_tpvid_val[thread_info->numtpvid],param->strval); 
                 thread_info->numtpvid++;
                 if((DLFBUFPARAM-20)<thread_info->numtpvid) thread_info->param_tag=1;
                 if(thread_info->numtpvid>=DLFBUFPARAM)
                    {
                    serrno = SEINTERNAL;
		    return (-1);
                    }
		 break;

              case DLF_MSG_PARAM_INT64:
		 (void) i64tostr (param->numval, thread_info->arr_param_int64_par_val[thread_info->paramint64], -1);
                 thread_info->arr_msg_seq_num_param_int64[thread_info->paramint64]=thread_info->arr_msgseq_no[tmpnummsg];
                 strcpy(thread_info->arr_param_int64_par_name[thread_info->paramint64],param->name); 
                 thread_info->paramint64++;
                 if((DLFBUFPARAM-20)<thread_info->paramint64) thread_info->param_tag=1;
                 if(thread_info->paramint64>=DLFBUFPARAM)
                    {
                    serrno = SEINTERNAL;
		    return (-1);
                    }
		 break;
                
	      case DLF_MSG_PARAM_DOUBLE:
		 thread_info->arr_msg_seq_num_param_double[thread_info->paramdouble]=thread_info->arr_msgseq_no[tmpnummsg];
                 strncpy(thread_info->arr_param_duble_par_name[thread_info->paramdouble],param->name,20);
                 thread_info->arr_param_duble_par_name[thread_info->paramdouble][20]='\0';
                 
                 strncpy(thread_info->arr_param_double_val[thread_info->paramdouble],param->strval,24);
                 thread_info->arr_param_double_val[thread_info->paramdouble][24]='\0';
                 thread_info->paramdouble++;
                 if((DLFBUFPARAM-20)<thread_info->paramdouble) thread_info->param_tag=1;
                 if(thread_info->paramdouble>=DLFBUFPARAM)
                    {
                    serrno = SEINTERNAL;
		    return (-1);
                    }
		 break;
                
	      case DLF_MSG_PARAM_UUID:
		 resuuid = Cuuid2string( subrq_id_str, sizeof(subrq_id_str), ((Cuuid_t*)param->strval));
		 if (resuuid < 0) 
                   {
		   serrno = SEINTERNAL;
		   return (-1);
		   }
                
                thread_info->arr_msg_seq_num_rq_ids_map[thread_info->rqids]=thread_info->arr_msgseq_no[tmpnummsg];
                strcpy(thread_info->arr_rq_id_str[thread_info->rqids],rq_id_str);
                strcpy(thread_info->arr_subrq_id_str[thread_info->rqids],subrq_id_str);
                thread_info->rqids++;
                if((DLFBUFPARAM-20)<thread_info->rqids) thread_info->param_tag=1;
                if(thread_info->rqids>=DLFBUFPARAM)
                    {
                    serrno = SEINTERNAL;
		    return (-1);
                    }
		break;
                
	      default:
	 	 dlflogit (func, "%s\n", "INSERT error: unrecognized parameter type");
		 serrno = SEINTERNAL;
		 return (-1);
	      }
	  }
        thread_info->nummsg++;  
        if(thread_info->nummsg==(DLFBUFMESSAGES) || thread_info->param_tag==1) 
           {
           thread_info->param_tag=1;
           if(dlf_flush_buffers(thread_info)<0)
              {
              return (-1);
              }
           thread_info->param_tag=0;
           }
             
	return (0);
}


int dlf_flush_buffers(thread_info)
struct dlf_srv_thread_info* thread_info;
   {
   char func[32];
   struct dlf_dbfd *dbfd;
   int i;
   
   for(i=0;i<DLFBUFHOSTID;i++) arr_get_host_id_hostname[i][0]='Z';
   for(i=0;i<DLFBUFNSHOSTID;i++) arr_get_ns_host_id_hostname[i][0]='Z';
   
   strcpy (func, "dlf_flush_buffers");
   dbfd=&thread_info->dbfd;
   
   if(thread_info->nummsg>0) 
      {
      EXEC SQL FOR :thread_info->nummsg
         INSERT INTO dlf_messages
          (msg_seq_no, time, time_usec, req_id, host_id, ns_host_id, facility,
          severity, msg_no, pid, thread_id, ns_file_id)
         VALUES (:thread_info->arr_msgseq_no, TO_DATE(:thread_info->arr_time,'YYYYMMDDHH24MISS'),
              :thread_info->arr_time_usec,:thread_info->arr_req_id,:thread_info->arr_host_id,
              :thread_info->arr_ns_host_id,:thread_info->arr_facility,:thread_info->arr_severity,
              :thread_info->arr_msg_no,:thread_info->arr_pid,:thread_info->arr_thread_id,
              TO_NUMBER(:thread_info->arr_ns_file_id));
       thread_info->nummsg=0;   
       if (sqlca.sqlcode) 
          {
          switch (sqlca.sqlcode)
           {
           case -1:
              serrno = EEXIST;
              break;
           case -1631:
           case -1632:
           case -1654:
              serrno = ENOSPC;
              break;
           case -3113:
           case -3114:
           case -12571:
              serrno = EDLFNOTCONNECTED;
              break;    
           default:
              dlflogit (func, "INSERT message error: %.*s\n", sqlca.sqlerrm.sqlerrml,
                 sqlca.sqlerrm.sqlerrmc);
              serrno = SEINTERNAL;
           }
          return (-1);
          }
      }
    
    if(thread_info->numparamstr>0)
        {
        EXEC SQL FOR :thread_info->numparamstr
                INSERT INTO dlf_str_param_values
                   (msg_seq_no, par_name, value)
                VALUES  (:thread_info->arr_msg_seq_num_str_param,
                        :thread_info->arr_param_str_par_name, :thread_info->arr_param_str_val);
        thread_info->numparamstr=0;        
        if (sqlca.sqlcode) 
           {
           switch (sqlca.sqlcode)
              {
              case -1:
                 serrno = EEXIST;
                 break;
              case -1631:
              case -1632:
              case -1654:
                 serrno = ENOSPC;
                 break;
              case -3113:
              case -3114:
              case -12571:
                 serrno = EDLFNOTCONNECTED;
                 break;    
              default:
                 dlflogit (func, "INSERT dlf_str_param_values parameter error: %.*s\n",
		           sqlca.sqlerrm.sqlerrml,
                           sqlca.sqlerrm.sqlerrmc);
                 serrno = SEINTERNAL;
              }
            return (-1);
            }
        }
     
     if(thread_info->numtpvid>0)
        {
        EXEC SQL FOR :thread_info->numtpvid
               INSERT INTO dlf_tape_ids
	           (msg_seq_no, tape_vid)
               VALUES  (:thread_info->arr_msg_seq_num_tpvid, :thread_info->arr_tpvid_val);
        thread_info->numtpvid=0;       
        if (sqlca.sqlcode) 
           {
           switch (sqlca.sqlcode)
              {
              case -1:
                 serrno = EEXIST;
                 break;
              case -1631:
              case -1632:
              case -1654:
                 serrno = ENOSPC;
                 break;
              case -3113:
              case -3114:
              case -12571:
                 serrno = EDLFNOTCONNECTED;
                 break;    
              default:
                 dlflogit (func, "INSERT dlf_tape_ids parameter error: %.*s\n",
		           sqlca.sqlerrm.sqlerrml,
                           sqlca.sqlerrm.sqlerrmc);
                 serrno = SEINTERNAL;
              }
            return (-1);
            }
        }
     
     if(thread_info->paramint64>0)
        {
        EXEC SQL FOR :thread_info->paramint64
               INSERT INTO dlf_num_param_values
	           (msg_seq_no, par_name, value)
               VALUES  (:thread_info->arr_msg_seq_num_param_int64,
                       :thread_info->arr_param_int64_par_name,
                       TO_NUMBER(:thread_info->arr_param_int64_par_val));
        thread_info->paramint64=0;       
        if (sqlca.sqlcode) 
           {
           switch (sqlca.sqlcode)
              {
              case -1:
                 serrno = EEXIST;
                 break;
              case -1631:
              case -1632:
              case -1654:
                 serrno = ENOSPC;
                 break;
              case -3113:
              case -3114:
              case -12571:
                 serrno = EDLFNOTCONNECTED;
                 break;    
              default:
                 dlflogit (func, "INSERT dlf_num_param_values int64 parameter error: %.*s\n",
		           sqlca.sqlerrm.sqlerrml,
                           sqlca.sqlerrm.sqlerrmc);
                 serrno = SEINTERNAL;
              }
            return (-1);
            }
        }
     
     if(thread_info->paramdouble>0)
        {
	EXEC SQL FOR :thread_info->paramdouble
              INSERT INTO dlf_num_param_values
                    (msg_seq_no, par_name, value)
              VALUES (:thread_info->arr_msg_seq_num_param_double,
                      :thread_info->arr_param_duble_par_name,
                      TO_NUMBER(:thread_info->arr_param_double_val));
        thread_info->paramdouble=0;
        if (sqlca.sqlcode) 
           {
           switch (sqlca.sqlcode)
              {
              case -1:
                 serrno = EEXIST;
                 break;
              case -1631:
              case -1632:
              case -1654:
                 serrno = ENOSPC;
                 break;
              case -3113:
              case -3114:
              case -12571:
                 serrno = EDLFNOTCONNECTED;
                 break;    
              default:
                 dlflogit (func, "INSERT dlf_num_param_values double parameter error: %.*s\n",
		           sqlca.sqlerrm.sqlerrml,
                           sqlca.sqlerrm.sqlerrmc);
                 serrno = SEINTERNAL;
              }
            return (-1);
            }
        }
        
     if(thread_info->rqids>0)
        {
        EXEC SQL FOR :thread_info->rqids
              INSERT INTO dlf_rq_ids_map
                    (msg_seq_no, req_id, subreq_id)
              VALUES
                    (:thread_info->arr_msg_seq_num_rq_ids_map, :thread_info->arr_rq_id_str,
                    :thread_info->arr_subrq_id_str);
        thread_info->rqids=0;            
        if (sqlca.sqlcode) 
           {
           switch (sqlca.sqlcode)
              {
              case -1:
                 serrno = EEXIST;
                 break;
              case -1631:
              case -1632:
              case -1654:
                 serrno = ENOSPC;
                 break;
              case -3113:
              case -3114:
              case -12571:
                 serrno = EDLFNOTCONNECTED;
                 break;    
              default:
                 dlflogit (func, "INSERT dlf_rq_ids_map parameter error: %.*s\n",
		           sqlca.sqlerrm.sqlerrml,
                           sqlca.sqlerrm.sqlerrmc);
                 serrno = SEINTERNAL;
              }
            return (-1);
            }
                
        }
   thread_info->param_tag=0;
   if ((time(NULL)-commit_time)>=DLF_TIME_TO_COMMIT)
      {
      commit_time=time(NULL);   
      EXEC SQL COMMIT WORK;
      }
   
   return (0);
   }
   
