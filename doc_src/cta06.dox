/*!
\page Getting the prototype up and running

This chapter explains how to install the CTA prototype together with a local
EOS instance on a single local development box.

\subsection{Install a local EOS instance}

The CTA project requires xroot version 4 or higher.  EOS depends on xroot and
therefore the EOS version used must also be compatible with xroot version 4 or
higher.  An example combination of EOS and xroot versions compatible with the
CTA project are EOS version 4.0.4 Citrine together with xroot version 4.2.3-1.

\subsubsection{Configure yum to be able to find the correct EOS and xroot rpms}

For the EOS rpms create the \texttt{/etc/yum.repos.d/eos.repo} file with the
following contents.
\begin{verbatim}
  [eos-citrine]
  name=EOS 4.1 Version
  baseurl=http://dss-ci-repo.web.cern.ch/dss-ci-repo/eos/citrine/tag/el-7/x86_64/
  gpgcheck=0
  enabled=1

  [eos-citrine-depend]
  name=EOS 4.1 Version
  baseurl=http://dss-ci-repo.web.cern.ch/dss-ci-repo/eos/citrine-depend/el-7-x86_64/
  gpgcheck=0
  enabled=1
\end{verbatim}

For the xroot rpms create the \texttt{/etc/yum.repos.d/epel.repo} file with the
following contents or run \texttt{yum install epel-release}
\begin{verbatim}
  [epel]
  name=Extra Packages for Enterprise Linux 7 - $basearch
  baseurl=http://linuxsoft.cern.ch/epel/7/$basearch
  enabled=1
  gpgcheck=1
  gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-7
\end{verbatim}

\begin{verbatim}
  [epel-debuginfo]
  name=Extra Packages for Enterprise Linux 7 - $basearch - Debug
  baseurl=http://linuxsoft.cern.ch/epel/7/$basearch/debug
  enabled=1
  gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-7
  gpgcheck=1

\end{verbatim}

\begin{verbatim}
  [epel-source]
  name=Extra Packages for Enterprise Linux 7 - $basearch - Source
  baseurl=http://linuxsoft.cern.ch/epel/7/SRPMS
  enabled=0
  gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-7
  gpgcheck=1
\end{verbatim}

\subsubsection{Install the EOS and \texttt{xrootd} rpms}

Install the rpms using yum.
\begin{verbatim}
  sudo yum install eos-client eos-server xrootd-client xrootd-debuginfo xrootd-server
\end{verbatim}

Here is an example list of succesfully installed EOS and \texttt{xrootd} rpms.
\begin{verbatim}
  rpm -qa | egrep 'eos|xrootd' | sort
  eos-client-4.1.3-1.el7.x86_64
  eos-server-4.1.3-1.el7.x86_64
  libmicrohttpd-0.9.38-eos.wves.el7.cern.x86_64
  xrootd-4.4.0-1.el7.x86_64
  xrootd-client-4.4.0-1.el7.x86_64
  xrootd-client-devel-4.4.0-1.el7.x86_64
  xrootd-client-libs-4.4.0-1.el7.x86_64
  xrootd-debuginfo-4.4.0-1.el7.x86_64
  xrootd-devel-4.4.0-1.el7.x86_64
  xrootd-libs-4.4.0-1.el7.x86_64
  xrootd-private-devel-4.4.0-1.el7.noarch
  xrootd-selinux-4.4.0-1.el7.noarch
  xrootd-server-4.4.0-1.el7.x86_64
  xrootd-server-devel-4.4.0-1.el7.x86_64
  xrootd-server-libs-4.4.0-1.el7.x86_64
\end{verbatim}

\subsubsection{Setup the EOS \texttt{sysconfig} file}

Create the \texttt{/etc/syconfig/eos} file based on the example installed by the
.\texttt{eos-server} rpm:
\begin{verbatim}
  sudo cp /etc/sysconfig/eos.example /etc/sysconfig/eos
\end{verbatim}

Reduce the \texttt{xrootd} daemon roles to the bare minimum of just \texttt{mq},
\texttt{mgm} and \texttt{fst}.  This means there will be a total of three
\texttt{xrootd} daemons running for EOS on the local development box.
\begin{verbatim}
XRD_ROLES="mq mgm fst"
\end{verbatim}

Set the name of the EOS instance, for example.
\begin{verbatim}
export EOS_INSTANCE_NAME=eoscta
\end{verbatim}

Replace all of the hostnames with the fully qualified hostname of the local
development box.  The resulting hostname entries should look something like
the following, where \texttt{devbox.cern.ch} should be replaced with the fully
qualified name of the development box where EOS is being installed.
\begin{verbatim}
export EOS_INSTANCE_NAME=eoscta
export EOS_BROKER_URL=root://devbox.cern.ch:1097//eos/
export EOS_MGM_MASTER1=devbox.cern.ch
export EOS_MGM_MASTER2=devbox.cern.ch
export EOS_MGM_ALIAS=devbox.cern.ch
export EOS_FUSE_MGM_ALIAS=devbox.cern.ch
export EOS_FED_MANAGER=devbox.cern.ch:1094
export EOS_TEST_REDIRECTOR=devbox.cern.ch
# export EOS_VST_BROKER_URL=root://devbox.cern.ch:1099//eos/
# export EOS_VST_TRUSTED_HOST=devbox.cern.ch
\end{verbatim}

\subsubsection{Create a simple shared secret \texttt{keytab} file}
In order to internally authenticate the \texttt{mgm} and \texttt{fst} nodes
using the simple shared secret mechanism, create a simple shared secret
\texttt{keytab} file. 
\begin{verbatim}
  xrdsssadmin -k eoscta -u daemon -g daemon add /etc/eos.keytab
\end{verbatim}

\subsubsection{Create a kerberos \texttt{keytab} file readable by the EOS \texttt{xrootd} daemons}
Create a system \texttt{/etc/krb5.keytab} file if one does not already exist,
for example install the \texttt{cern-get-keytab} rpm if the development box is
at CERN and runs a CERN supported version of linux.
\begin{verbatim}
  yum install cern-get-keytab
\end{verbatim}

In order for the EOS \texttt{mgm} to authenticate users using kerberos, create a
a new \texttt{eos} service principal in the \texttt{kdc}, and get the key installed in the keytab.
This will also recreate new version of every other key for this host. The key the eos principal
can then be extracted to a new keytab, which will be owned by user daemon so it becomes readable
by the \texttt{mgm}.
\begin{verbatim}
[root@devbox ~]# cern-get-keytab --service eostest -f
Waiting for password replication (0 seconds past)
Waiting for password replication (5 seconds past)
Waiting for password replication (10 seconds past)
Keytab file saved: /etc/krb5.keytab
[root@lxc2dev3d1 ~]# ktutil
ktutil:  rkt /etc/krb5.keytab
ktutil:  l
slot KVNO Principal
---- ---- ---------------------------------------------------------------------
   1   14                          devbox$@CERN.CH
   2   14                          devbox$@CERN.CH
   3   14                          devbox$@CERN.CH
   4   14               eoscta/devbox.cern.ch@CERN.CH
   5   14               eoscta/devbox.cern.ch@CERN.CH
   6   14               eoscta/devbox.cern.ch@CERN.CH
ktutil:  delent 1
ktutil:  delent 1
ktutil:  delent 1
ktutil:  l
slot KVNO Principal
---- ---- ---------------------------------------------------------------------
   1   14               eoscta/devbox.cern.ch@CERN.CH
   2   14               eoscta/devbox.cern.ch@CERN.CH
   3   14               eoscta/devbox.cern.ch@CERN.CH
ktutil:  wkt /etc/krb5.keytab.eos
ktutil:  q
[root@devbox ~]# chown daemon.daemon /etc/krb5.keytab.eos
\end{verbatim}

This operation will re-generate all the keys of the host. It might require the client users to 
\texttt{kdestroy} their corresponding tickets in caches.

\subsubsection{Setup the \texttt{/etc/xrd.cf.mgm} configuration file}

Backup the original \texttt{/etc/xrd.cf.mgm} file installed by the
\texttt{eos-server} rpm.
\begin{verbatim}
  sudo cp /etc/xrd.cf.mgm /etc/xrd.cf.mgm_ORGINIAL
\end{verbatim}

Disable the unix based authentication mechanism of xroot.
\begin{verbatim}
  sudo sed -i 's/^sec.protocol unix.*/# &/' /etc/xrd.cf.mgm
\end{verbatim}

Disable the gsi based authentication mechanism of xroot.
\begin{verbatim}
  sudo sed -i 's/^sec.protocol gsi.*/# &/' /etc/xrd.cf.mgm
\end{verbatim}

Configure the kerberos athentication mechanism of xroot to read the EOS
specific kerberos \texttt{keytab} file.
\begin{verbatim}
  sudo sed -i 's/^sec.protocol krb5.*/sec.protocol 
    krb5 \/etc\/krb5.keytab.eos eos\/<host>@CERN.CH/' /etc/xrd.cf.mgm
\end{verbatim}

Set the order of authentication mechanisms to be used to kerberos followed by
simple shared secret.
\begin{verbatim}
  sudo sed -i 's/^sec.protbind.*/# &/' /etc/xrd.cf.mgm
  sudo sed -i 's/^# sec.protbind \*.*/sec.protbind * only krb5 sss/'
\end{verbatim}

The protocol configuration lines in the newly created \texttt{xrd.cf.mgm} file
should look something like the following.
\begin{verbatim}
#sec.protocol unix
sec.protocol krb5 /etc/krb5.keytab.eos host/<host>@CERN.CH
#sec.protocol gsi -crl:0 -cert:/etc/grid-security/daemon/hostcert.pem 
  -key:/etc/grid-security/daemon/hostkey.pem -gridmap:/etc/grid-security/gri
sec.protbind * only krb5 sss
mgmofs.broker root://devbox.cern.ch:1097//eos/
\end{verbatim}

Make sure the following entry exists so that the EOS namespace plugin will be
loaded in.
\begin{verbatim}
#-------------------------------------------------------------------------------
# Set the namespace plugin implementation
#-------------------------------------------------------------------------------
mgmofs.nslib /usr/lib64/libEosNsInMemory.so
\end{verbatim}
Make sure to fix \texttt{mgmofs.instance name}
\begin{verbatim}
  mgmofs.instance eoscta
\end{verbatim}

\subsubsection{Setup the /etc/xrd.cf.fst configuration file}

Backup the original \texttt{/etc/xrd.cf.fst} file installed by the
\texttt{eos-server} rpm.
\begin{verbatim}
  sudo cp /etc/xrd.cf.fst /etc/xrd.cf.fst_ORGINIAL
\end{verbatim}

Replace all of the hostnames with the fully qualified hostname of the local
development box.  The hostname entries in the newly created \texttt{xrd.cd.fst}
file should look something like the following, where \texttt{devbox.cern.ch}
should be replaced with the fully qualified name of the development box where
EOS is being installed.
\begin{verbatim}
all.manager devbox.cern.ch 2131
fstofs.broker root://devbox.cern.ch:1097//eos/
\end{verbatim}

\subsubsection{Set both the EOS \texttt{mgm} and the EOS \texttt{mq} to be masters}
\begin{verbatim}
  sudo service eos master mgm
  sudo service eos master mq
\end{verbatim}

\subsubsection{Create a local directory to be used to store files by the EOS \texttt{fst}}
\begin{verbatim}
  sudo mkdir -p /fst
  sudo chown daemon:daemon /fst/
\end{verbatim}

\subsubsection{Start the xrootd daemons that will run the EOS \texttt{mgm}, \texttt{mq} and \texttt{fst} plugins}
\begin{verbatim}
  sudo service eos start
\end{verbatim}

\subsubsection{Enable the kerberos and simple shared secret authentication mechanisms within EOS as opposed to xroot}
\begin{verbatim}
  sudo eos vid enable sss
  sudo eos vid enable krb5
\end{verbatim}

\subsubsection{Register the local /fst directory with the default EOS space}
\begin{verbatim}
  sudo EOS_MGM_URL="root://devbox.cern.ch" eosfstregister -r /fst default:1
\end{verbatim}

\subsubsection{Put the EOS fst node on-line}
\begin{verbatim}
  sudo eos node set devbox.cern.ch on
\end{verbatim}

\subsubsection{Enable the default EOS space}
\begin{verbatim}
  sudo eos space set default on
\end{verbatim}

\subsubsection{Create the EOS namespace}
Create the \texttt{/eos} directory within the EOS namespace, map it to the EOS
\texttt{default} space and then set the number of replicas to 1.
\begin{verbatim}
  sudo eos attr -r set default=replica /eos
  sudo eos attr -r set sys.forced.nstripes=1 /eos
  sudo eos mkdir /eos/cta
  sudo eos chmod 777 /eos/cta
\end{verbatim}

\subsubsection{Test the EOS installation}
\begin{verbatim}
  sudo eos -b node ls
  xrdcp  /etc/group root://devbox.cern.ch//eos/cta/
\end{verbatim}

\subsection{Compile CTA}
Make sure \texttt{yum} is configured to see the repositories that will provide
the packages required to build CTA.  If CTA is to be compiled on SLC6 then only
the CTA command-line tool will be built and this will only require the following
epel repository configuration:
\begin{verbatim}
cat /etc/yum.repos.d/epel.repo
[epel]
name=UNSUPPORTED: Extra Packages for Enterprise Linux add-ons, no formal support from CERN
baseurl=http://linuxsoft.cern.ch/epel/6/$basearch/
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-6
gpgcheck=1
enabled=1
protect=0

[epel-debug]
name=UNSUPPORTED: Extra Packages for Enterprise Linux add-ons, no formal support from CERN - debug RPMs
baseurl=http://linuxsoft.cern.ch/epel/6/$basearch/debug/
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-6
gpgcheck=1
enabled=0
protect=0

[epel-source]
name=UNSUPPORTED: Extra Packages for Enterprise Linux add-ons, no formal support from CERN - source RPMs
baseurl=http://linuxsoft.cern.ch/epel/6/SRPMS/
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-6
gpgcheck=1
enabled=0
protect=0

[epel-testing]
name=UNSUPPORTED: Extra Packages for Enterprise Linux add-ons, no formal support from CERN - testing
baseurl=http://linuxsoft.cern.ch/epel/testing/6/$basearch/
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-6
gpgcheck=1
enabled=0
protect=0

[epel-testing-debug]
name=UNSUPPORTED: Extra Packages for Enterprise Linux add-ons, no formal support from CERN - testing debug RPMs
baseurl=http://linuxsoft.cern.ch/epel/testing/6/$basearch/debug/
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-6
gpgcheck=1
enabled=0
protect=0

[epel-testing-source]
name=UNSUPPORTED: Extra Packages for Enterprise Linux add-ons, no formal support from CERN - testing source RPMs
baseurl=http://linuxsoft.cern.ch/epel/testing/6/SRPMS/
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-6
gpgcheck=1
enabled=0
protect=0
\end{verbatim}

If CTA is to be built on CC7 then it will require the following \texttt{epel}
and \texttt{ceph} repository configurations:
\begin{verbatim}
cat /etc/yum.repos.d/epel.repo 
[epel]
name=Extra Packages for Enterprise Linux 7 - $basearch
baseurl=http://linuxsoft.cern.ch/epel/7/$basearch
enabled=1
gpgcheck=1
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-7

[epel-debuginfo]
name=Extra Packages for Enterprise Linux 7 - $basearch - Debug
baseurl=http://linuxsoft.cern.ch/epel/7/$basearch/debug
enabled=0
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-7
gpgcheck=1

[epel-source]
name=Extra Packages for Enterprise Linux 7 - $basearch - Source
baseurl=http://linuxsoft.cern.ch/epel/7/SRPMS
enabled=0
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-7
gpgcheck=1
\end{verbatim}

\begin{verbatim}
cat /etc/yum.repos.d/ceph-cc7.repo 
[cc7-ceph]
name=cc7-ceph
baseurl=http://linuxsoft.cern.ch/mirror/download.ceph.com/rpm-infernalis/el7/x86_64
gpgcheck=0
enabled=1
protect=0
priority=4
\end{verbatim}

In addition you will need to make sure the \texttt{cernonly} repository is enabled:
\begin{verbatim}
egrep -A3 '\[cernonly\]' /etc/yum.repos.d/CentOS-CERN.repo 
[cernonly]
name=CentOS-$releasever - CERN Only
baseurl=http://linuxsoft.cern.ch/cern/centos/$releasever/cernonly/$basearch/
gpgcheck=1
\end{verbatim}

Install \texttt{cmake} if it is not already installed:
\begin{verbatim}
  sudo yum install cmake
\end{verbatim}

Obtain the URL of the CTA source-code repository by going to the following CERN
gitlab web page:
\begin{verbatim}
https://gitlab.cern.ch/cta/CTA
\end{verbatim} 
You should copy the URL from this web page, however at the time this document
was written the 3 possible URLS were:
\begin{verbatim}
HTTPS: https://gitlab.cern.ch/cta/CTA.git
KRB5: https://:@gitlab.cern.ch:8443/cta/CTA.git
SSH: ssh://git@gitlab.cern.ch:7999/cta/CTA.git
\end{verbatim}

Clone the \texttt{CTA} git repository (this example uses the KRB5 URL):
\begin{verbatim}
git clone https://:@gitlab.cern.ch:8443/cta/CTA.git
\end{verbatim}
This will create a directory called \texttt{CTA}.

Create a build directory at the same level as the \texttt{CTA} directory or
anywhere accept inside of the \texttt{CTA} directory:
\begin{verbatim}
mkdir CTA_build
\end{verbatim}

Enter the build directory and run the following \texttt{cmake} and \texttt{make}
commands in order to produce the source RPM of the CTA project:
\begin{verbatim}
cd CTA_build
cmake -DPackageOnly:Bool=true ../CTA
make cta_srpm
\end{verbatim}

Use \texttt{yum-builddep} to install all of the packages required to build the
rest of CTA:
\begin{verbatim}
sudo yum-builddep RPM/SRPMS/cta-0-0.src.rpm
\end{verbatim}

Delete and then re-create the \texttt{CTA\_build} directory:
\begin{verbatim}
cd ..
rm -rf CTA_build
mkdir CTA_build
\end{verbatim}
Go into the newly re-created \texttt{CTA\_build} directory and run \texttt{cmake}
to prepare to make all of the CTA project and not just the source rpm:
\begin{verbatim}
cd CTA_build
cmake ../CTA
\end{verbatim}

Build CTA by running \texttt{make} twice in the \texttt{CTA\_build} directory.
\begin{verbatim}
make
make
\end{verbatim}

\subsection{Set up the objectstore VFS backend}
First we create the new objectstore VFS backend using a simple executable:
\begin{verbatim}
  $ <cta_build_dir>/objectstore/cta-objectstore-initialize
\end{verbatim}
This command will return the newly created path to the VFS backend. Now we give it full permissions:
\begin{verbatim}
  $ chmod -R 0777 <result_dir_of_previous_cmd>
\end{verbatim}
Now we need to add it as a configuration parameter in the \texttt{castor.conf}, as in the following example:
\begin{verbatim}
  TapeServer ObjectStoreBackendPath /tmp/jobStoreVFSOKJCjW
\end{verbatim}

\subsection{Setting up the environment}
\subsubsection{Virtual tape library}
The virtual tape library \texttt{mhvtl} will be used to simulate a tape drive. I can be installed like follows (from the same CASTOR{\_}SLC6 repository):
\begin{verbatim}
yum install mhvtl-utils kmod-mhvtl
\end{verbatim}

The configuration files for mhvtl are:
\begin{itemize}
\item \texttt{/etc/mhvtl/mhvtl.conf}:
\item[{}]
\begin{boxedverbatim}
# Home directory for config file(s)
MHVTL_CONFIG_PATH=/etc/mhvtl

# Default media capacity (1 G)
CAPACITY=1000

# Set default verbosity [0|1|2|3]
VERBOSE=1

# Set kernel module debuging [0|1]
VTL_DEBUG=0
\end{boxedverbatim}

\item \texttt{/etc/mhvtl/device.conf}:
\item [{}]
\begin{boxedverbatim}
VERSION: 5

Library: 10 CHANNEL: 00 TARGET: 00 LUN: 00
 Vendor identification: STK
 Product identification: VLSTK
 Unit serial number: VLSTK
 NAA: 30:22:33:44:ab:00:08:00

Drive: 11 CHANNEL: 00 TARGET: 1 LUN: 00
 Library ID: 10 Slot: 1
 Vendor identification: STK
 Product identification: T10000B
 Unit serial number: VDSTK1
 NAA: 30:22:33:44:ab:00:09:00
 Compression: factor 1 enabled 1
 Compression type: zlib

Drive: 12 CHANNEL: 00 TARGET: 2 LUN: 00
 Library ID: 10 Slot: 2
 Vendor identification: STK
 Product identification: T10000B
 Unit serial number: VDSTK2
 NAA: 30:22:33:44:ab:00:09:00
 Compression: factor 1 enabled 1
 Compression type: zlib
\end{boxedverbatim}
\item \texttt{/etc/mhvtl/library{\_}contents.10}:
\item [{}]
\begin{boxedverbatim}
Drive 1:
Drive 2:

Picker 1:

MAP 1:

Slot 1: V31001TA
Slot 2: V31002TA
Slot 3: V31003TA
Slot 4: V31004TA
Slot 5: V31005TA
Slot 6:
Slot 7:
Slot 8:
\end{boxedverbatim}
\end{itemize}

After starting the mhvtl daemon, the files for the virtual tapes will be created automatically:


\begin{boxedverbatim}
# ls -lR /opt/mhvtl
/opt/mhvtl:
total 4
drwxrws---. 7 vtl vtl 4096 Oct 16 18:16 10

/opt/mhvtl/10:
total 20
drwxrws---. 2 vtl vtl 4096 Oct 16 18:16 V31001TA
drwxrws---. 2 vtl vtl 4096 Oct 16 18:16 V31002TA
drwxrws---. 2 vtl vtl 4096 Oct 16 18:16 V31003TA
drwxrws---. 2 vtl vtl 4096 Oct 16 18:16 V31004TA
drwxrws---. 2 vtl vtl 4096 Oct 16 18:16 V31005TA

/opt/mhvtl/10/V31001TA:
total 4
-rw-rw----. 1 vtl vtl    0 Oct 16 18:16 data
-rw-rw----. 1 vtl vtl    0 Oct 16 18:16 indx
-rw-rw----. 1 vtl vtl 1536 Oct 16 18:16 meta

/opt/mhvtl/10/V31002TA:
total 4
-rw-rw----. 1 vtl vtl    0 Oct 16 18:16 data
-rw-rw----. 1 vtl vtl    0 Oct 16 18:16 indx
-rw-rw----. 1 vtl vtl 1536 Oct 16 18:16 meta

/opt/mhvtl/10/V31003TA:
total 4
-rw-rw----. 1 vtl vtl    0 Oct 16 18:16 data
-rw-rw----. 1 vtl vtl    0 Oct 16 18:16 indx
-rw-rw----. 1 vtl vtl 1536 Oct 16 18:16 meta

/opt/mhvtl/10/V31004TA:
total 4
-rw-rw----. 1 vtl vtl    0 Oct 16 18:16 data
-rw-rw----. 1 vtl vtl    0 Oct 16 18:16 indx
-rw-rw----. 1 vtl vtl 1536 Oct 16 18:16 meta

/opt/mhvtl/10/V31005TA:
total 4
-rw-rw----. 1 vtl vtl    0 Oct 16 18:16 data
-rw-rw----. 1 vtl vtl    0 Oct 16 18:16 indx
-rw-rw----. 1 vtl vtl 1536 Oct 16 18:16 meta
\end{boxedverbatim}

A link to the SCSI media changer device is created automatically by this udev rule (\texttt{/etc/udev/rules.d/00-castor-tape.rules}):
\begin{boxedverbatim}
KERNEL=="sg*",  BUS=="scsi",  SYSFS{type}=="8", SYMLINK:="smc"
KERNEL=="sg*",  MODE:="0666", GROUP:="disk"
\end{boxedverbatim}

The permission are also set for the \texttt{st} group (created automatically by the castor rpms) in \texttt{/etc/udev/rules.d/99-tape.rules}:
\begin{boxedverbatim}
# Udev rules setting the permissions on the tape device files for CASTOR's
# tapeserverd operations.

KERNEL=="nst*", GROUP="st"
\end{boxedverbatim}

The utilities to validate the virtual tape drives (\texttt{mt} and \texttt{mtx}) can be installed as follows:

\begin{boxedverbatim}
# yum install mtx mt-st
\end{boxedverbatim}

The virtual library can then be validated:

\begin{boxedverbatim}
# mtx -f /dev/smc inquiry
Product Type: Medium Changer
Vendor ID: 'STK     '
Product ID: 'VLSTK           '
Revision: '0105'
Attached Changer API: No
# mtx -f /dev/smc status
  Storage Changer /dev/smc:2 Drives, 9 Slots ( 1 Import/Export )
Data Transfer Element 0:Empty
Data Transfer Element 1:Empty
      Storage Element 1:Full :VolumeTag=V31001TA
      Storage Element 2:Full :VolumeTag=V31002TA
      Storage Element 3:Full :VolumeTag=V31003TA
      Storage Element 4:Full :VolumeTag=V31004TA
      Storage Element 5:Full :VolumeTag=V31005TA
      Storage Element 6:Empty
      Storage Element 7:Empty
      Storage Element 8:Empty
      Storage Element 9 IMPORT/EXPORT:Empty

\end{boxedverbatim}

Then we start the CASTOR daemon needed by the tape server: \textbf{rmcd}. \textbf{rmcd} is installed by the \texttt{castor-rmc-server} package. This is a standard (unmodified) CASTOR daemon. This daemon needs to know where the device file for accessing the tape mount robot is located. This is indicated in \texttt{/etc/sysconfig/rmcd}:
\begin{verbatim}

\end{verbatim}

\subsubsection{Rmcd configuration}
The file \texttt{/etc/sysconfig/rmcd} contains the following parameters:

\begin{boxedverbatim}
DAEMON_COREFILE_LIMIT=unlimited
RUN_RMCD=yes
RMCD_OPTIONS=/dev/smc
\end{boxedverbatim}

\subsection{Starting up the xroot server with the CTA plugin}
Before starting the xroot server we need to change the VFS backend permissions again (because new files have been created with the \texttt{stage:st} user by the tapeserver daemon). Example:

\begin{verbatim}
  $ chmod -R 0777 /tmp/jobStoreVFSOKJCjW
\end{verbatim}

We now create some useful soft links to simplify the xrootd configuration:

\begin{verbatim}
  $ ln -s <CTA build directory>/xroot_plugins/libXrdCtaOfs.so /usr/lib64/libXrdCtaOfs.so
  $ ln -s <CTA src directory>/xroot_plugins/xrd.cf.cta /etc/xrd.cf.cta
\end{verbatim}

The CTA Command Line Interface needs to speak to a \emph{xroot} server which uses the CTA plugin to interpret and execute the commands sent by the user. All the information needed by the \emph{xroot} server is contained within a configuration file which is currently called \texttt{xrd.cf.cta}. Its contents is the following:

\begin{verbatim}
  # Load the plugin XrdCtaOfs
  xrootd.fslib /usr/lib64/libXrdCtaOfs.so

  # Use the Kerberos 5 security module
  xrootd.seclib libXrdSec.so

  # The xroot server process needs to be able to read the keytab file
  sec.protocol krb5 /etc/krb5.keytab.cta host/<host>@CERN.CH

  # Only Kerberos 5 is allowed
  sec.protbind * only krb5

  # Allow copying from absolute paths
  all.export /

  # Turn off asynchronous i/o
  xrootd.async off
\end{verbatim}

All this will work fine provided that you have a file called \texttt{/etc/krb5.keytab.cta} which is a copy of your keytab file (\texttt{/etc/krb5.keytab}). \texttt{/etc/krb5.keytab.cta} must be owned by the user.group that will run the \emph{xroot} server process. If you don't have a keytab file you may get one using \texttt{cern-get-keytab} (for CERN supported Linux systems) or \texttt{msktutil} (for other systems), as explained in:

\begin{verbatim}
  http://linux.web.cern.ch/linux/docs/kerberos-access.shtml
\end{verbatim}

The \emph{xroot} server then can be launched with the following command:

\begin{verbatim}
  $ xrootd -n cta -c /etc/xrd.cf.cta -I v4
\end{verbatim}

Where the first parameter is the name of the xroot instance, the second one is the configuration file above and the third one basically instructs \emph{xroot} to use IPv4. The result of the command is typically something like:

\begin{verbatim}
  151009 15:59:19 18239 Starting on Linux 2.6.32-573.3.1.el6.x86_64
  Copr.  2004-2012 Stanford University, xrd version v4.2.3
  ++++++ xrootd anon@dkruse.cern.ch initialization started.
  Config using configuration file /home/dkruse/CTA/CTA/xroot_plugins/xrd.cf.cta
  =====> xrd.port 10955
  Config maximum number of connections restricted to 4096
  Copr.  2012 Stanford University, xrootd protocol 3.0.0 version v4.2.3
  ++++++ xrootd protocol initialization started.
  =====> xrootd.fslib /home/dkruse/CTA/build/xroot_plugins/libXrdCtaOfs.so
  =====> xrootd.seclib libXrdSec.so
  =====> all.export /
  =====> xrootd.async off
  Config exporting /
  Plugin loaded 
  ++++++ Authentication system initialization started.
  Plugin loaded 
  Template for exports not set
  =====> sec.protocol krb5 /etc/krb5.keytab.cta host/<host>@CERN.CH
  =====> sec.protbind * only krb5
  Config 2 authentication directives processed in 
    /home/dkruse/CTA/CTA/xroot_plugins/xrd.cf.cta
  ------ Authentication system initialization completed.
  Config Routing for dkruse.cern.ch: local pub4 prv4 
  Config Route all4: dkruse.cern.ch Dest=[::137.138.33.124]:10955
  Plugin No such file or directory 
    loading fslib /home/dkruse/CTA/build/xroot_plugins/libXrdCtaOfs-4.so
  Config Falling back to using /home/dkruse/CTA/build/xroot_plugins/libXrdCtaOfs.so
  Plugin loaded 
  [WARNING] Could not create the admin user and admin host. CTA exception caught:
    In RootEntry::addAdminUser: entry already exists
  Config warning: asynchronous I/O has been disabled!
  Config warning: 'xrootd.prepare logdir' not specified; prepare tracking disabled.
  ------ xrootd protocol initialization completed.
  ------ xrootd anon@dkruse.cern.ch:10955 initialization completed.
\end{verbatim}

The \emph{xroot} server can be stopped by pressing \texttt{Ctrl+c}. Once the server is running, the CTA CLI will be able to send commands and receive results.

\subsection{Trying out some commands}
Now CTA should be up and running and we can try out some commands from the \texttt{cmdline} directory:
\begin{verbatim}
  $ <cta_build_dir>/cmdline/cta ll add -n IBMJD3 -m "IBM lib 3"
  $ <cta_build_dir>/cmdline/cta tp add -n cms_raw_08 -p 15 -m "CMS raw"
  $ <cta_build_dir>/cmdline/cta ta add -v G12345 -l IBMJD3 -t cms_raw_08 -c 10000 -m "Tape"
  $ <cta_build_dir>/cmdline/cta sc add -n single -i 2 -c 1 -m "A single copy class"
  $ <cta_build_dir>/cmdline/cta ar add -s single -c 1 -t cms_raw_08 -m "Route to cms"
  $ <cta_build_dir>/cmdline/cta mkdir /cta
  $ <cta_build_dir>/cmdline/cta ssc /cta single
  $ <cta_build_dir>/cmdline/cta csc /cta
  $ <cta_build_dir>/cmdline/cta ssc /cta single
  $ <cta_build_dir>/cmdline/cta ls /
  $ <cta_build_dir>/cmdline/cta a "eos://eos/passwd" /cta/file5
\end{verbatim}
For a complete reference of the user commands see the next chapter.

\subsection{Running \texttt{tapeserverd}}

\subsubsection{Tapeserverd configuration}

The tape drives can now be indicated to tapeserverd through the \texttt{/etc/castor/TPCONFIG} file:

\begin{boxedverbatim}
VDSTK1 VLSTK /dev/nst0 smc0
VDSTK2 VLSTK /dev/nst1 smc1
\end{boxedverbatim}

The memory blocks size and number shall also be added in \texttt{/etc/castor/castor.conf}:

\begin{boxedverbatim}
TapeServer BufSize 5242880
TapeServer NbBufs 200
\end{boxedverbatim}



Finally we start the CTA version of \textbf{tapeserverd}:

\begin{boxedverbatim}
# service rmcd start
Starting rmcd:                                             [  OK  ]
# <Build directory>/tapeserver/castor/tape/tapeserver/daemon/tapeserverd
# tpstat
userid     jid  dgn        stat dvn                 rl  vsn    vid
                VLSTK      down VDSTK1@devbox
                VLSTK      down VDSTK2@devbox
\end{boxedverbatim}

Using \texttt{tpstat} and \texttt{tpconfig}, one can put the drive up and see it attempt to schedule itself 
in the logs (either \texttt{/var/log/messages} or \texttt{/var/log/castor/tapeserverd.log} depending on the 
installation and leftovers from previous castor tape server.

The log typically look like (simplified) in a loop:

\begin{boxedverbatim}
MSG="ProcessForker handling a ProcessForker message" type="ForkDataTransfer" len="47"
MSG="ProcessForker handling ForkDataTransfer message" unitName="VDSTK1"
MSG="ProcessForker forked data-transfer session" pid="32453"
MSG="Closed command receiver socket" cmdSocket="7"
MSG="Data-transfer child-process started" unitName="VDSTK1"
MSG="Got process ID of the data-transfer session from the ProcessForker" pid="32453"
MSG="Child of ProcessForker instantiated a ZMQ context" contextAddr="0x17494b0"
MSG="ProcessForker child process terminated" terminatedPid="32453" WEXITSTATUS="0" WCOREDUMP="false" WIFCONTINUED="false"
MSG="ProcessForker notifying TapeDaemon of process exit" pid="32453" exitCode="0" payloadLen="6"
MSG="ProcessForkerConnectionHandler handling a message" type="ProcessExited" payloadLen="6"
MSG="ProcessForkerConnectionHandler handling ProcessExited message" pid="32453" exitCode="0"
MSG="Tape session finished"
\end{boxedverbatim}

\subsubsection{Tape labelling}

Tapes can be labelled with the following commands (depends on the tape library and the tape drive types):

\begin{verbatim}
  
  $ echo "VOL1V31001                           CASTOR                                    3">label.file
  $ mtx -f /dev/smc load 1 0
  $ dd if=label.file of=/dev/nst0 bs=80 count=1
  $ mt -f /dev/nst0 rewind
  $ mtx -f /dev/smc unload 1 0

\end{verbatim}

\subsubsection{Preparing the CTA environment for migrations}
The library and tapes need to be registered for the migrations (use appropriate names for your setup):

\begin{verbatim}
# create library
  $ cta logicallibrary add --name VLSTK --comment "ctasystest"
# create tape pool
  $ cta tapepool add --name ctasystest --partialtapesnumber 5 --encrypted false --comment "ctasystest"  
# add tape to the tapepool and library
  $ cta tape add --logicallibrary VLSTK --tapepool ctasystest --capacity 1000000000 \
  --comment "ctasystest" --vid V31001 --disabled false --full false --encryptionkey test
# create storage class
  $ cta storageclass add --instance root --name ctaStorageClass --copynb 1 --comment "ctasystest"
# create archive route
  $ cta archiveroute add --instance root --storageclass ctaStorageClass --copynb 1 \
  --tapepool ctasystest --comment "ctasystest" 
# create mount policy
  $ cta mountpolicy add --name root --archivepriority 1 --minarchiverequestage 1 \
  --retrievepriority 1 --minretrieverequestage 1 --maxdrivesallowed 1 --comment "ctasystest"  
# create requester mount rule
  $ cta requestermountrule  add --instance root --name root --mountpolicy ctasystest \
  --comment "ctasystest" 	
\end{verbatim}

\subsubsection{Preparing the EOS workflows }
The closew,retrive and deletearchive EOS workflows need to be registered to work with CTA. The following EOS command have to be applied for CTA directory:

\begin{boxedverbatim}
  attr set "sys.workflow.closew.default=bash:shell:cta
   '/opt/src/build/cmdline/cta archive
   --user <eos::wfe::rusername>
   --group <eos::wfe::rgroupname>
   --diskid <eos::wfe::fid>
   --instance eoscta
   --srcurl root://devbox.cern.ch/<eos::wfe::path>
   --size <eos::wfe::size>
   --checksumtype <eos::wfe::checksumtype>
   --checksumvalue <eos::wfe::checksum>
   --storageclass <eos::wfe::cxattr:CTA_StorageClass>
   --diskfilepath <eos::wfe::path>
   --diskfileowner <eos::wfe::username>
   --diskfilegroup <eos::wfe::groupname>
   --recoveryblob:base64 <eos::wfe::base64:metadata>
   --diskpool default --throughput 10000 1>&2'" .
	
  attr set "sys.workflow.prepare.default=bash:shell:cta '/opt/src/build/cmdline/cta retrieve
  --user <eos::wfe::rusername>
  --group <eos::wfe::rgroupname>
  --id <eos::wfe::fxattr:sys.archiveFileId>
  --dsturl <eos::wfe::turl>
  --diskfilepath <eos::wfe::path>
  --diskfileowner <eos::wfe::username>
  --diskfilegroup <eos::wfe::groupname>
  --recoveryblob:base64 <eos::wfe::base64:metadata>
  --diskpool default --throughput 10000 1>&2'" .
	
  attr set "sys.workflow.delete.default=bash:shell:cta '/opt/src/build/cmdline/cta deletearchive
  --user <eos::wfe::rusername>
  --group <eos::wfe::rgroupname>
  --id <eos::wfe::fxattr:sys.archiveFileId> 1>&2'" .
\end{boxedverbatim}

\begin{verbatim}
Switch on and make sure that EOS workflow engine is switched on:
  eos space config default space.wfe=on
  eos space status default
\end{verbatim}

\subsubsection{Testing EOS with CTA }
To trigger manually EOS workflows just use the following eos commands:
\begin{verbatim}
  file workflow <filename> default closew
  file workflow <filename> default prepare
  file workflow <filename> default delete
\end{verbatim}
*/
