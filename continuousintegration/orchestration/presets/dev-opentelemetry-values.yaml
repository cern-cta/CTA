image:
  repository: registry.cern.ch/ghcr.io/open-telemetry/opentelemetry-collector-releases/opentelemetry-collector-contrib
  tag: 0.129.1

mode: deployment

presets:
  kubernetesAttributes:
    enabled: true

config:
  receivers:
    otlp:
      protocols:
        http:
          endpoint: 0.0.0.0:4318

  processors:
    k8sattributes:
      auth_type: serviceAccount
      extract:
        metadata:
          - k8s.pod.name
          - k8s.namespace.name
          - k8s.container.name
          - k8s.node.name
      pod_association:
        - sources:
            - from: resource_attribute
              name: k8s.pod.uid
        - sources:
            - from: connection

    batch:
      timeout: 5s


    # Ensure datapoints have sufficient identifying info so that we can reduce cardinality
    # later on by dropping the service.instance.id
    transform/add_identifying_labels:
      error_mode: ignore
      metric_statements:
        - set(datapoint.attributes["k8s.pod.name"], resource.attributes["k8s.pod.name"])
        - set(datapoint.attributes["process.name"], resource.attributes["process.name"])


    # Aggregate all CTA metrics using the stable identity
    metricstransform/aggregate:
      transforms:
        - include: "cta.*"
          match_type: regexp
          action: update
          operations:
            - action: aggregate_labels
              aggregation_type: sum
              label_set: ["service.instance.id", "transfer.type", "event.type", "lock.type", "scheduler.backend_name"]

    # Drop some unwantend labels
    transform/strip_labels:
      error_mode: ignore
      metric_statements:
        - delete_key(datapoint.attributes, "service.instance.id")

    # The namespace will add as the ci run id
    transform/add_ci_run_id:
      error_mode: ignore
      metric_statements:
        - set(datapoint.attributes["ci.run.id"], resource.attributes["k8s.namespace.name"])
          where resource.attributes["k8s.namespace.name"] != nil

  exporters:
    prometheus:
      endpoint: ${env:MY_POD_IP}:8889
      resource_to_telemetry_conversion:
        enabled: true
    debug:
      verbosity: detailed

  # TODO: do the remote write in the prometheus with recording rules
  service:
    pipelines:
      metrics:
        receivers:
          - otlp
        processors:
          # - k8sattributes
          - batch
          # - transform/add_identifying_labels
          # - metricstransform/aggregate
          # - transform/strip_labels
          # - transform/add_ci_run_id
        exporters:
          - prometheus
          - debug

    telemetry:
      logs:
        level: "info"

ports:
  metrics:
    enabled: true
    containerPort: 8889
    servicePort: 8889
    protocol: TCP
