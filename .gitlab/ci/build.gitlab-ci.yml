# SPDX-FileCopyrightText: 2025 CERN
# SPDX-License-Identifier: GPL-3.0-or-later

build-cta-rpms:
  stage: build
  needs:
    - job: modify-project-json
      optional: true
  rules:
    - if: $PIPELINE_TYPE == "SYSTEM_TEST_ONLY"
      when: never
    - if: $PIPELINE_TYPE == "REGR_AGAINST_CTA_VERSION"
      when: never
    - if: $PIPELINE_TYPE == "IMAGE_FROM_CTA_VERSION"
      when: never
    # These rules serve to prevent the rest of the pipeline from triggering when only trivial files such as the CHANGELOG have been modified
    # GitLab only allows a whitelist and not a blacklist, so we have to list all file changes that should trigger the build job
    - changes:
        - .dockerignore
        - .gitlab-ci.yml
        - CMakeLists.txt
        - cta.spec.in
        - project.json
        - version.hpp.in
        - xrootd-ssi-protobuf-interface
        # To be safe, all files in all sub-directories
        # Once we have a src/ directory, we can be a bit more specific without having to specify a long list here
        - '*/**/*'
      when: on_success
    # If only "trivial" changes were done and we are in a MR, set this job to manual
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      when: manual
      allow_failure: true  # Ensures the pipeline counts as "passed" instead of "blocked"
    # Ensure we cover any other cases that might trigger this
    - when: on_success
  image: $IMAGE_BUILD
  variables:
    BUILD_PATH: "build_rpm/RPM/RPMS"
    XRD_SSI_PATH: "xrootd-ssi-protobuf-interface"
    BUILD_CACHE_POLICY: pull-push
    # Will only be used if ccache is enabled
    CCACHE_BASEDIR: $CI_PROJECT_DIR
    CCACHE_DIR: $CI_PROJECT_DIR/.ccache
    CCACHE_COMPILERCHECK: content
    CCACHE_MAXSIZE: "1G"
  before_script:
    - |
      if [[ -z "${CI_COMMIT_TAG}" ]]; then
        export VCS_VERSION=$CTA_BUILD_ID
        export CTA_VERSION=$BUILD_CTA_VERSION
      else
        export CTA_VERSION=$(echo ${CI_COMMIT_TAG} | awk -F '[v-]' '{print $2}')
        export VCS_VERSION=$(echo ${CI_COMMIT_TAG} | awk -F '-' '{if(NF>1) print $2; else print 0}')
      fi
    - echo "Building package CTA_VERSION=${CTA_VERSION} - CTA_RELEASE=${VCS_VERSION}"
    - export XRD_SSI_VERSION=$(git --git-dir=$XRD_SSI_PATH/.git --work-tree=$XRD_SSI_PATH describe --tags --abbrev=0)
    - |
      if [[ -z "$XRD_SSI_VERSION" ]]; then
        echo "Error: failed to find tag for submodule $XRD_SSI_PATH"
        exit 1
      fi
    - ccache --zero-stats
  script:
    # SRPMS
    - ./ci/build/build_srpm.sh --build-dir build_srpm
                               --build-generator "${BUILD_GENERATOR}"
                               --create-build-dir
                               --cta-version ${BUILD_CTA_VERSION}
                               --vcs-version ${CTA_BUILD_ID}
                               --scheduler-type ${SCHEDULER_TYPE}
                               --oracle-support ${ORACLE_SUPPORT}
                               --cmake-build-type "${CMAKE_BUILD_TYPE}"
                               --jobs $(nproc --ignore=1)
    # RPMS
    - BUILD_OPTIONS=""
    - |
      if [[ "$ENABLE_CCACHE" == "TRUE" ]]; then
        BUILD_OPTIONS+=" --enable-ccache"
      fi
    - |
      if [[ "$ENABLE_DEBUG_INFO" == "FALSE" ]]; then
        BUILD_OPTIONS+=" --skip-debug-packages"
      fi
    - |
      if [[ "$USE_INTERNAL_REPOS" == "TRUE" ]]; then
        BUILD_OPTIONS+=" --use-internal-repos"
      fi
    - |
      if [[ "$ENABLE_ADDRESS_SANITIZER" == "TRUE" ]]; then
        BUILD_OPTIONS+=" --enable-address-sanitizer"
      fi
    - ./ci/build/build_rpm.sh --build-dir build_rpm
                              --build-generator "${BUILD_GENERATOR}"
                              --create-build-dir
                              --srpm-dir build_srpm/RPM/SRPMS
                              --cta-version ${CTA_VERSION}
                              --vcs-version ${VCS_VERSION}
                              --xrootd-ssi-version ${XRD_SSI_VERSION}
                              --scheduler-type ${SCHEDULER_TYPE}
                              --oracle-support ${ORACLE_SUPPORT}
                              --cmake-build-type "${CMAKE_BUILD_TYPE}"
                              --jobs $(nproc --ignore=1)
                              --install-srpms
                              --platform ${PLATFORM}
                              --skip-unit-tests
                              ${BUILD_OPTIONS}
  after_script:
    - ccache --show-stats
  artifacts:
    expire_in: 30 days
    paths:
      - ${BUILD_PATH}
  cache:
    - key: "ccache:${CI_PROJECT_ID}:${CI_JOB_IMAGE}:${CI_COMMIT_BRANCH}"
      fallback_keys:
        - "ccache:${CI_PROJECT_ID}:main"
      policy: $BUILD_CACHE_POLICY
      paths: [.ccache/]


# Specifically to build CTA without ccache and with debug packages enabled
build-cta-rpms-no-cache:
  extends:
    - build-cta-rpms
  rules:
    - if: $CI_PIPELINE_SOURCE != "merge_request_event"
      when: never
    - !reference [.build-image, rules]
  variables:
    ENABLE_CCACHE: "FALSE"
    ENABLE_DEBUG_INFO: "FALSE"
  cache: [] # Explicitly disable the cache


# This is not (and ideally should not) be used further down the pipeline; this is just a compilation check
build-cta-rpms-pgsched:
  extends:
    - build-cta-rpms
  variables:
    # We don't have a way of separating what the user entered and what the actual value is,
    # so this will always run, even if the pipeline type was already postgres
    SCHEDULER_TYPE: "pgsched"
    SKIP_UNIT_TESTS: "TRUE"
    ENABLE_CCACHE: "FALSE"
  cache: [] # Explicitly disable the cache

reset-ccache:
  allow_failure: true
  stage: build
  needs:
    - job: build-cta-rpms
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
      when: manual
    - when: never
  image: $IMAGE_BUILD
  variables:
    GIT_STRATEGY: none  # We don't need the repo clone here
    BUILD_CACHE_POLICY: push
  script:
    - rm -rf .ccache
    - mkdir -p .ccache
    # upload an empty cache
    - touch .ccache/.keep
  cache:
    - !reference [build-cta-rpms, cache]

# Documentation export
export-docs:
  stage: build
  needs: []
  rules:
    - if: $CI_PIPELINE_SOURCE == "schedule"
  script:
    - echo "Exporting man pages (Markdown)"
    - mkdir docs
    - /usr/bin/find . -path ./docs -prune -o -name '*cta.md' -exec cp {} docs/ \;
  artifacts:
    when: always
    expire_in: 30 days
    paths:
      - docs/
