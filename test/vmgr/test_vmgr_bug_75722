#!/bin/perl -w

use strict;
use DBI;
use POSIX;

sub runCmdAs {
  my ($userName, $cmd) = (shift, shift);

  my $now            = "";
  my $status         = 0;
  my $pid            = 0;
  my $cmdOutputFile;
  my $cmdOutputStr   = "";

  $now = `date '+\%a \%b \%H:\%M:\%S'`;
  chomp($now);
  print("$now : \"$cmd\"\n");
  open($cmdOutputFile, "runuser $userName -c \"$cmd\" |")
    or die "Failed to run \"$cmd\": $!\n";

  while(<$cmdOutputFile>) {
    $cmdOutputStr = $cmdOutputStr . $_;
  }

  close($cmdOutputFile);

  return $cmdOutputStr;
}

# Returns the database connection string stored in /etc/castor/VMGRCONFIG
sub getVmgrDbConnectionString {
  my $dbConnectionString = `cat /etc/castor/VMGRCONFIG`;
  chomp($dbConnectionString);
  return($dbConnectionString);
}

sub testRunCmdAsOutput {
  my ($userName, $cmd, $expectedOutput) = (shift, shift, shift);

  my $actualOutput = "";
  my $now          = "";

  $now = `date '+\%a \%b \%H:\%M:\%S'`;
  chomp($now);
  $actualOutput = &runCmdAs($userName, $cmd);
  chomp($actualOutput);
  die "$now : \"$cmd\" failed: Unexpected output:" .
      " expected=\"$expectedOutput\"" .
      " actual=\"$actualOutput\"\n"
    unless $actualOutput eq $expectedOutput;
  print("$actualOutput\n");
}

# Returns true if the daemon with specfied name is running else false.
#
# @param  daemonName The name of the daemon.
# @return            True if the daemon is running, else false.
sub daemonIsRunning {
  my $daemonName = $_[0];

  my $psResult = `ps -e | grep $daemonName | awk '{print \$NF;}'`;
  chomp($psResult);

  return($psResult eq $daemonName);
}

sub dropVmgrDatabaseSchema {
  my ($dbConnectionString, $originalDropSchema) = (shift, shift);

  my $tmpDropSchema = &runCmdAs("root", "mktemp");
  print("tmpDropSchema=$tmpDropSchema\n");
  chomp($tmpDropSchema);
  `echo "WHENEVER SQLERROR EXIT FAILURE;" >> $tmpDropSchema`;
  `echo "CONNECT $dbConnectionString" >> $tmpDropSchema`;
  `echo >> $tmpDropSchema`;
  `cat $originalDropSchema >> $tmpDropSchema`;
  `echo >> $tmpDropSchema`;
  `echo "EXIT;" >> $tmpDropSchema`;

  &runCmdAs("root", "'sqlplus' /NOLOG \@$tmpDropSchema");
  &runCmdAs("root", "rm $tmpDropSchema");
}

sub createVmgrDatabaseSchema {
  my ($dbConnectionString, $originalDbSchema) = (shift, shift);

  my $tmpCreateSchema = &runCmdAs("root", "mktemp");
  chomp($tmpCreateSchema);
  print("tmpCreateSchema=$tmpCreateSchema\n");
  `echo "WHENEVER SQLERROR EXIT FAILURE;" >> $tmpCreateSchema`;
  `echo "CONNECT $dbConnectionString" >> $tmpCreateSchema`;
  `echo >> $tmpCreateSchema`;
  `cat $originalDbSchema >> $tmpCreateSchema`;
  `echo >> $tmpCreateSchema`;
  `echo "EXIT;" >> $tmpCreateSchema`;

  &runCmdAs("root", "'sqlplus' /NOLOG \@$tmpCreateSchema");
  &runCmdAs("root", "rm $tmpCreateSchema");
}

sub dieIfNoExecutable {
  my $executablePath = (shift);

  print ("Testing \"$executablePath\" exists and is executable\n");

  die("ABORT: $executablePath does not exist\n")
    unless -e $executablePath;
  die("ABORT: $executablePath is not a plain file\n")
    unless -f $executablePath;
  die("ABORT: $executablePath is not executable\n")
    unless -x $executablePath;
}

###############################################################################
# MAIN PROGRAM STARTS HERE
###############################################################################

my $testVmgrHost    = "lxcastordev04";
my $nonRootUserName = "murrayc3";
my $productionHost  = "lxadm";
my $nsDir           = "/castor/cern.ch/dev/m/murrayc3/vmgr_bug_75722";
my %tapes = (
  I02023 => {
    mo  => "3592",
    ml  => "J",
    li  => "IBMLIB1B",
    d   => "1000GC",
    l   => "aul",
    po  => "stager_dev04",
    dgn => "359B1B"
  },
  I10486 => {
    mo  => "3592",
    ml  => "J",
    li  => "IBMLIB3B",
    d   => "1000GC",
    l   => "aul",
    po  => "stager_dev04",
    dgn => "359B3B"
  },
  I12035 => {
    mo  => "3592",
    ml  => "J",
    li  => "IBMLIB3B",
    d   => "1000GC",
    l   => "aul",
    po  => "stager_dev04",
    dgn => "359B3B"
  },
  I12038 => {
    mo  => "3592",
    ml  => "J",
    li  => "IBMLIB3B",
    d   => "1000GC",
    l   => "aul",
    po  => "stager_dev04",
    dgn => "359B3B"
  },
  I12438 => {
    mo  => "3592",
    ml  => "J",
    li  => "IBMLIB3B",
    d   => "1000GC",
    l   => "aul",
    po  => "stager_dev04",
    dgn => "359B3B"
  }
);
my $castor_src                         = "";
my $originalDbSchema                   = "";
my $originalDropSchema                 = "";
my $vid                                = "";
my $tapePool                           = "";
my $tapeStatus                         = "";
my $freeSpaceStr                       = "";
my $status                             = 0;
my $uid                                = POSIX::getuid;
my $gid                                = POSIX::getgid;
my $cmdResultStr                       = "";
my $i                                  = 0;
my $vmgrquerytape_path                 = "";
my $vmgrquerytape_trunk_r21843_path    = "";
my $vmgrenterdenmap_trunk_r21843_path  = "";
my $vmgrlistdenmap_trunk_r21843_path   = "";
my $vmgrentermodel_trunk_r21843_path   = "";
my $vmgrlistmodel_trunk_r21843_path    = "";
my $vmgrenterlibrary_trunk_r21843_path = "";
my $vmgrlistlibrary_trunk_r21843_path  = "";
my $vmgrenterdgnmap_trunk_r21843_path  = "";
my $vmgrlistdgnmap_trunk_r21843_path   = "";
my $vmgrenterpool_trunk_r21843_path    = "";
my $vmgrlistpool_trunk_r21843_path     = "";
my $vmgrmodifypool_trunk_r21843_path   = "";
my $vmgrentertape_trunk_r21843_path    = "";
my $vmgrlisttape_trunk_r21843_path     = "";
my $vmgrmodifytape_trunk_r21843_path   = "";
my @vids                               = sort keys %tapes;
my $expectedOutput                     = "";

# Abort if the user is not root
die("ABORT: This script must be ran as root\n") if ($uid != 0 || $gid !=0);

# Abort if the environment variable CASTOR_SRC is not set
die("ABORT: CASTOR_SRC not defined\n") if(! defined($ENV{'CASTOR_SRC'}));

$castor_src = $ENV{'CASTOR_SRC'};
print("Using CASTOR_SRC=$castor_src\n");

$vmgrquerytape_path = "$castor_src/test/vmgr/vmgrquerytape";
&dieIfNoExecutable($vmgrquerytape_path);

$vmgrquerytape_trunk_r21843_path =
  "$castor_src/test/vmgr/vmgrquerytape_trunk_r21843";
&dieIfNoExecutable($vmgrquerytape_trunk_r21843_path);

$vmgrenterdenmap_trunk_r21843_path =
  "$castor_src/test/vmgr/vmgrenterdenmap_trunk_r21843";
&dieIfNoExecutable($vmgrenterdenmap_trunk_r21843_path);

$vmgrlistdenmap_trunk_r21843_path =
  "$castor_src/test/vmgr/vmgrlistdenmap_trunk_r21843";
&dieIfNoExecutable($vmgrlistdenmap_trunk_r21843_path);

$vmgrentermodel_trunk_r21843_path =
  "$castor_src/test/vmgr/vmgrentermodel_trunk_r21843";
&dieIfNoExecutable($vmgrentermodel_trunk_r21843_path);

$vmgrlistmodel_trunk_r21843_path =
  "$castor_src/test/vmgr/vmgrlistmodel_trunk_r21843";
&dieIfNoExecutable($vmgrlistmodel_trunk_r21843_path);

$vmgrenterlibrary_trunk_r21843_path =
  "$castor_src/test/vmgr/vmgrenterlibrary_trunk_r21843";
&dieIfNoExecutable($vmgrenterlibrary_trunk_r21843_path);

$vmgrlistlibrary_trunk_r21843_path =
  "$castor_src/test/vmgr/vmgrlistlibrary_trunk_r21843";
&dieIfNoExecutable($vmgrlistlibrary_trunk_r21843_path);

$vmgrenterdgnmap_trunk_r21843_path =
  "$castor_src/test/vmgr/vmgrenterdgnmap_trunk_r21843";
&dieIfNoExecutable($vmgrenterdgnmap_trunk_r21843_path);

$vmgrlistdgnmap_trunk_r21843_path =
  "$castor_src/test/vmgr/vmgrlistdgnmap_trunk_r21843";
&dieIfNoExecutable($vmgrlistdgnmap_trunk_r21843_path);

$vmgrenterpool_trunk_r21843_path =
  "$castor_src/test/vmgr/vmgrenterpool_trunk_r21843";
&dieIfNoExecutable($vmgrenterpool_trunk_r21843_path);

$vmgrlistpool_trunk_r21843_path =
  "$castor_src/test/vmgr/vmgrlistpool_trunk_r21843";
&dieIfNoExecutable($vmgrlistpool_trunk_r21843_path);

$vmgrmodifypool_trunk_r21843_path =
  "$castor_src/test/vmgr/vmgrmodifypool_trunk_r21843";
&dieIfNoExecutable($vmgrmodifypool_trunk_r21843_path);

$vmgrentertape_trunk_r21843_path =
  "$castor_src/test/vmgr/vmgrentertape_trunk_r21843";
&dieIfNoExecutable($vmgrentertape_trunk_r21843_path);

$vmgrlisttape_trunk_r21843_path =
  "$castor_src/test/vmgr/vmgrlisttape_trunk_r21843";
&dieIfNoExecutable($vmgrlisttape_trunk_r21843_path);

$vmgrmodifytape_trunk_r21843_path =
  "$castor_src/test/vmgr/vmgrmodifytape_trunk_r21843";
&dieIfNoExecutable($vmgrmodifytape_trunk_r21843_path);

# Determine the location of the database scripts to drop the vmgr and recreate
# the vmgr database
$originalDbSchema   = "$castor_src/vmgr/vmgr_oracle_create.sql";
$originalDropSchema = "$castor_src/castor/db/drop_oracle_schema.sql";

die "ABORT: $originalDbSchema does not exist\n"
  if ! -e $originalDbSchema;

die "ABORT: $originalDropSchema does not exist\n"
  if ! -e $originalDropSchema;

my $dbConnectionString = &getVmgrDbConnectionString();
my $dbUser   = "UNKNOWN";
my $dbPasswd = "UNKNOWN";
my $dbTNS    = "UNKNOWN";

if($dbConnectionString =~ m/^([^\/]+)\/([^\@]+)\@(.*)$/) {
  $dbUser   = $1;
  $dbPasswd = $2;
  $dbTNS    = $3;
} else {
  die("ABORT: Failed to extract database username from connection string\n");
}

die "Abort: Failed to tnsping database with TNS=$dbTNS\n"
  unless system("tnsping $dbTNS") == 0;

die("ABORT: Database user $dbUser is not vmgr_dev04\n")
  if($dbUser ne "vmgr_dev04");

# Abort if the test tapes are not in the tape_dev tape-pool and not DISABLED in
# the production vmgr
print("\n");
print("CHECKING TEST TAPES ARE IN TAPE_DEV AND DISABLED IN PRODUCTION\n");
for $vid (sort keys %tapes) {
  $cmdResultStr = &runCmdAs("root",
    "ssh $nonRootUserName\@$productionHost vmgrlisttape -V $vid");
  chomp($cmdResultStr);
  print("cmdResultStr=$cmdResultStr\n");
  $tapePool   = "UNKNOWN";
  $tapeStatus = "UNKNOWN";
  if($cmdResultStr =~
    m/$vid +$vid +\w+ +\w+ +$tapes{$vid}{l} +(\w+) +[^ ]+ +\w+ +(\w+)$/) {
    $tapePool   = $1;
    $tapeStatus = $2;
  }
  print("tapePool   = $tapePool\n");
  print("tapeStatus = $tapeStatus\n");
  die "$vid is not in tape_dev in production" unless $tapePool eq "tape_dev";
  die "$vid is not DISABLED in production" unless $tapeStatus eq "DISABLED";
}

# Abort if the test tapes have production files on them
print("\n");
print("CHECKING TEST_TAPES CONTAIN NO PRODUCTION FILES\n");
for $vid (sort keys %tapes) {
  $cmdResultStr = &runCmdAs("root",
    "2>&1 ssh $nonRootUserName\@$productionHost nslisttape -V $vid");
  chomp($cmdResultStr);
  print("cmdResultStr=\"$cmdResultStr\"\n");
  die "$vid contains production files"
    unless $cmdResultStr eq "$vid: No such volume or no files found";
}

# Abort if the new vmgr clients do not get refused by the old production vmgr
print("\n");
print("CHECKING OLD VMGR REFUSES NEW CLIENTS\n");
&testRunCmdAsOutput("root",
  "2>&1 VMGR_HOST=lxcastorsrv102 vmgrenterdenmap" .
  " -d 9999GC --ml J --mo 3592 --nc 1T",
  "VMG03 - illegal function 40\nvmgrenterdenmap 3592: Internal error");
&testRunCmdAsOutput("root",  "2>&1 VMGR_HOST=lxcastorsrv102 vmgrlistdenmap",
  "VMG03 - illegal function 41\n" .
  "send2vmgr: VMG02 - send error : Internal error");
&testRunCmdAsOutput("root",
  "2>&1 VMGR_HOST=lxcastorsrv102 vmgrlisttape -V $vids[0]",
  "VMG03 - illegal function 42\nvmgrlisttape: Internal error");
&testRunCmdAsOutput("root",
  "2>&1 VMGR_HOST=lxcastorsrv102 $vmgrquerytape_path $vids[0]",
  "VMG03 - illegal function 39\n" .
  "vmgr_querytape_byte_u64 failed: vid=\"$vids[0]\": Internal error");

if(&daemonIsRunning("vmgrd")) {
  print("\n");
  print("STOPPING THE VMGR\n");
  &runCmdAs("root", "/etc/init.d/vmgrd stop");
}

print("\n");
print("DROPPING DATABASE SCHEMA\n");
&dropVmgrDatabaseSchema($dbConnectionString, $originalDropSchema);

print("\n");
print("CREATING DATABASE SCHEMA\n");
&createVmgrDatabaseSchema($dbConnectionString, $originalDbSchema);

print("\n");
print("STARTING THE VMGR\n");
&runCmdAs("root", "/etc/init.d/vmgrd start");
die "Abort: vmgrd is not running\n" unless daemonIsRunning("vmgrd");
sleep(1); # Give the vmgrd a chance to get up and running

print("\n");
print("ENTERING META-DATA INTO VMGR USING NEW CLIENTS\n");

&runCmdAs("root", "vmgrentermodel --mo 3592 --ml J --mc 250");
&testRunCmdAsOutput("root", "vmgrlistmodel", "3592   J  250");

&runCmdAs("root", "vmgrenterdenmap -d 1000GC --ml J --mo 3592 --nc 1T");
&testRunCmdAsOutput("root", "vmgrlistdenmap", "3592   J  1000GC      1.00Ti");

&runCmdAs("root", "vmgrenterlibrary --name IBMLIB1B --capacity 6600");
&testRunCmdAsOutput("root", "vmgrlistlibrary",
  "IBMLIB1B CAPACITY 6600 FREE 6600 (100.0%) ONLINE");
# vmgrlistlibrary uses a different protocol with the --name option than without
&testRunCmdAsOutput("root", "vmgrlistlibrary --name IBMLIB1B",
  "IBMLIB1B CAPACITY 6600 FREE 6600 (100.0%) ONLINE");

&runCmdAs("root", "vmgrenterlibrary --name IBMLIB3B --capacity 6600");
&testRunCmdAsOutput("root", "vmgrlistlibrary",
  "IBMLIB1B CAPACITY 6600 FREE 6600 (100.0%) ONLINE\n" .
  "IBMLIB3B CAPACITY 6600 FREE 6600 (100.0%) ONLINE");

&runCmdAs("root", "vmgrenterdgnmap -g 359B1B --mo 3592 --library IBMLIB1B");
&testRunCmdAsOutput("root", "vmgrlistdgnmap", "359B1B 3592   IBMLIB1B");

&runCmdAs("root", "vmgrenterdgnmap -g 359B3B --mo 3592 --library IBMLIB3B");
&testRunCmdAsOutput("root", "vmgrlistdgnmap",
  "359B1B 3592   IBMLIB1B\n" .
  "359B3B 3592   IBMLIB3B");

&runCmdAs("root", "vmgrenterpool --group st --name stager_dev04 --user stage");
&testRunCmdAsOutput("root", "vmgrlistpool",
"stager_dev04    stage    st     CAPACITY         0B FREE         0B (  0.0%)");
# vmgrlistpool uses a different protocol with the -P option than without
&testRunCmdAsOutput("root", "vmgrlistpool -P stager_dev04",
"stager_dev04    stage    st     CAPACITY         0B FREE         0B (  0.0%)");

&runCmdAs("root",
  "vmgrmodifypool --name stager_dev04 --user root --group root");
&testRunCmdAsOutput("root", "vmgrlistpool",
"stager_dev04    -        -      CAPACITY         0B FREE         0B (  0.0%)");

&runCmdAs("root", "vmgrmodifypool --name stager_dev04 --user stage --group st");
&testRunCmdAsOutput("root", "vmgrlistpool",
"stager_dev04    stage    st     CAPACITY         0B FREE         0B (  0.0%)");

# Enter the test tapes into the test vmgr
$expectedOutput = "";
$i = 1;
for $vid (sort keys %tapes) {
  &runCmdAs("root",
    "vmgrentertape -V $vid" .
    " --mo $tapes{$vid}{mo}" .
    " --ml $tapes{$vid}{ml}" .
    " --li $tapes{$vid}{li}" .
    " -d   $tapes{$vid}{ d}" .
    " -l   $tapes{$vid}{ l}" .
    " --po $tapes{$vid}{po}");

  if($expectedOutput ne "") {
    $expectedOutput = $expectedOutput . "\n";
  }
  $expectedOutput = $expectedOutput .
    "$vid   $vid $tapes{$vid}{li} $tapes{$vid}{ d}   $tapes{$vid}{ l} $tapes{$vid}{po}       1.00TiB 00000000 ";
  &testRunCmdAsOutput("root", "vmgrlisttape", $expectedOutput);

  &testRunCmdAsOutput("root", "vmgrlistpool",
"stager_dev04    stage    st     CAPACITY    $i.00TiB FREE    $i.00TiB (100.0%)"
    );
  # vmgrlistpool has uses a different protocol with the -P option than without
  &testRunCmdAsOutput("root", "vmgrlistpool -P stager_dev04",
"stager_dev04    stage    st     CAPACITY    $i.00TiB FREE    $i.00TiB (100.0%)"
    );

  $i = $i + 1;
}

$i = 1;
for $vid (@vids) {

  if($i == 1) {
    &runCmdAs("root", "vmgrmodifytape -V $vid --st ''");
    &testRunCmdAsOutput("root", "vmgrlisttape -V $vid",
      "$vid   $vid $tapes{$vid}{li} $tapes{$vid}{ d}   $tapes{$vid}{ l} $tapes{$vid}{po}       1.00TiB 00000000 ");
  } else {
    &runCmdAs("root", "vmgrmodifytape -V $vid --st DISABLED");
    &testRunCmdAsOutput("root", "vmgrlisttape -V $vid",
      "$vid   $vid $tapes{$vid}{li} $tapes{$vid}{ d}   $tapes{$vid}{ l} $tapes{$vid}{po}       1.00TiB 00000000 DISABLED");
  }

  $i = $i + 1;
} 

if(&daemonIsRunning("vmgrd")) {
  print("\n");
  print("STOPPING THE VMGR\n");
  &runCmdAs("root", "/etc/init.d/vmgrd stop");
}

print("\n");
print("DROPPING DATABASE SCHEMA\n");
&dropVmgrDatabaseSchema($dbConnectionString, $originalDropSchema);

print("\n");
print("CREATING DATABASE SCHEMA\n");
&createVmgrDatabaseSchema($dbConnectionString, $originalDbSchema);

print("\n");
print("STARTING THE VMGR\n");
&runCmdAs("root", "/etc/init.d/vmgrd start");
die "Abort: vmgrd is not running\n" unless daemonIsRunning("vmgrd");
sleep(1); # Give the vmgrd a chance to get up and running

print("\n");
print("ENTERING META-DATA INTO VMGR USING OLD CLIENTS\n");
&runCmdAs("root",
  "$vmgrentermodel_trunk_r21843_path --mo 3592 --ml J --mc 250");
&testRunCmdAsOutput("root",
  "$vmgrlistmodel_trunk_r21843_path", "3592   J  250");

&runCmdAs("root",
  "$vmgrenterdenmap_trunk_r21843_path -d 1000GC --ml J --mo 3592 --nc 1T");
&testRunCmdAsOutput("root", "$vmgrlistdenmap_trunk_r21843_path",
  "3592   J  1000GC      1.00Ti");

&runCmdAs("root",
  "$vmgrenterlibrary_trunk_r21843_path --name IBMLIB1B --capacity 6600");
&testRunCmdAsOutput("root", "$vmgrlistlibrary_trunk_r21843_path",
  "IBMLIB1B CAPACITY 6600 FREE 6600 (100.0%) ONLINE");
# vmgrlistlibrary uses a different protocol with the --name option than without
&testRunCmdAsOutput("root",
  "$vmgrlistlibrary_trunk_r21843_path --name IBMLIB1B",
  "IBMLIB1B CAPACITY 6600 FREE 6600 (100.0%) ONLINE");

&runCmdAs("root",
  "$vmgrenterlibrary_trunk_r21843_path --name IBMLIB3B --capacity 6600");
&testRunCmdAsOutput("root", "$vmgrlistlibrary_trunk_r21843_path",
  "IBMLIB1B CAPACITY 6600 FREE 6600 (100.0%) ONLINE\n" .
  "IBMLIB3B CAPACITY 6600 FREE 6600 (100.0%) ONLINE");

&runCmdAs("root",
  "$vmgrenterdgnmap_trunk_r21843_path -g 359B1B --mo 3592 --library IBMLIB1B");
&testRunCmdAsOutput("root", "$vmgrlistdgnmap_trunk_r21843_path",
  "359B1B 3592   IBMLIB1B");

&runCmdAs("root",
  "$vmgrenterdgnmap_trunk_r21843_path -g 359B3B --mo 3592 --library IBMLIB3B");
&testRunCmdAsOutput("root", "$vmgrlistdgnmap_trunk_r21843_path",
  "359B1B 3592   IBMLIB1B\n" .
  "359B3B 3592   IBMLIB3B");

&runCmdAs("root",
"$vmgrenterpool_trunk_r21843_path --group st --name stager_dev04 --user stage");
&testRunCmdAsOutput("root", "$vmgrlistpool_trunk_r21843_path",
"stager_dev04    stage    st     CAPACITY         0B FREE         0B (  0.0%)");
# vmgrlistpool uses a different protocol with the -P option than without
&testRunCmdAsOutput("root", "$vmgrlistpool_trunk_r21843_path -P stager_dev04",
"stager_dev04    stage    st     CAPACITY         0B FREE         0B (  0.0%)");

&runCmdAs("root",
  "$vmgrmodifypool_trunk_r21843_path --name stager_dev04 --user root --group root");
&testRunCmdAsOutput("root", "$vmgrlistpool_trunk_r21843_path",
"stager_dev04    -        -      CAPACITY         0B FREE         0B (  0.0%)");

&runCmdAs("root",
  "$vmgrmodifypool_trunk_r21843_path --name stager_dev04 --user stage --group st");
&testRunCmdAsOutput("root", "$vmgrlistpool_trunk_r21843_path",
"stager_dev04    stage    st     CAPACITY         0B FREE         0B (  0.0%)");

# Enter the test tapes into the test vmgr
$expectedOutput = "";
$i = 1;
for $vid (sort keys %tapes) {
  &runCmdAs("root",
    "$vmgrentertape_trunk_r21843_path -V $vid" .
    " --mo $tapes{$vid}{mo}" .
    " --ml $tapes{$vid}{ml}" .
    " --li $tapes{$vid}{li}" .
    " -d   $tapes{$vid}{ d}" .
    " -l   $tapes{$vid}{ l}" .
    " --po $tapes{$vid}{po}");

  if($expectedOutput ne "") {
    $expectedOutput = $expectedOutput . "\n";
  }
  $expectedOutput = $expectedOutput .
    "$vid   $vid $tapes{$vid}{li} $tapes{$vid}{ d}   $tapes{$vid}{ l} $tapes{$vid}{po}       1.00TiB 00000000 ";
  &testRunCmdAsOutput("root", "$vmgrlisttape_trunk_r21843_path",
    $expectedOutput);

  &testRunCmdAsOutput("root", "$vmgrlistpool_trunk_r21843_path",
"stager_dev04    stage    st     CAPACITY    $i.00TiB FREE    $i.00TiB (100.0%)"
    );
  # vmgrlistpool has uses a different protocol with the -P option than without
  &testRunCmdAsOutput("root", "$vmgrlistpool_trunk_r21843_path -P stager_dev04",
"stager_dev04    stage    st     CAPACITY    $i.00TiB FREE    $i.00TiB (100.0%)"
    );

  $i = $i + 1;
}

$i = 1;
for $vid (@vids) {

  if($i == 1) {
    &runCmdAs("root", "$vmgrmodifytape_trunk_r21843_path -V $vid --st ''");
    &testRunCmdAsOutput("root", "$vmgrlisttape_trunk_r21843_path -V $vid",
      "$vid   $vid $tapes{$vid}{li} $tapes{$vid}{ d}   $tapes{$vid}{ l} $tapes{$vid}{po}       1.00TiB 00000000 ");
  } else {
    &runCmdAs("root",
      "$vmgrmodifytape_trunk_r21843_path -V $vid --st DISABLED");
    &testRunCmdAsOutput("root", "$vmgrlisttape_trunk_r21843_path -V $vid",
      "$vid   $vid $tapes{$vid}{li} $tapes{$vid}{ d}   $tapes{$vid}{ l} $tapes{$vid}{po}       1.00TiB 00000000 DISABLED");
  }

  $i = $i + 1;
} 

# Abort if the old vmgr_checktape function does not work with the new vmgr
print("\n");
print("CHECKING OLD VMGR_CHECKTAPE FUNCTION WORKS WITH NEW VMGR\n");
&testRunCmdAsOutput("root",
  "2>&1 $vmgrquerytape_trunk_r21843_path $vids[0]",
  "vmgr_querytape succeeded: vid=\"$vids[0]\" dgn=\"$tapes{$vids[0]}{dgn}\"");

# Abort if the old vmgr_enterdenmap function does not work with the new vmgr
print("\n");
print("CHECKING OLD VMGR_ENTERDENMAP FUNCTION WORKS WITH NEW VMGR\n");
&testRunCmdAsOutput("root",
  "2>&1 $vmgrenterdenmap_trunk_r21843_path -d 10GC --ml J --mo 3592 --nc 10G", "");
&testRunCmdAsOutput("root",
  "2>&1 vmgrlistdenmap | grep 10GC", "3592   J  10GC       10.00Gi");

# Abort if the new vmgr_checktape function does not work with the new vmgr
print("\n");
print("CHECKING NEW VMGR_CHECKTAPE FUNCTION WORKS WITH NEW VMGR\n");
&testRunCmdAsOutput("root",
  "2>&1 $vmgrquerytape_path $vids[0]",
  "vmgr_querytape_byte_u64 succeeded: vid=\"$vids[0]\" dgn=\"$tapes{$vids[0]}{dgn}\"");

# Abort if the old vmgr_listdenmap function does not work with the new vmgr
print("\n");
print("CHECKING OLD VMGR_LISTDENMAP FUNCTION WORKS WITH NEW VMGR\n");
&testRunCmdAsOutput("root",
  "2>&1 $vmgrlistdenmap_trunk_r21843_path",
  "3592   J  10GC       10.00Gi\n" .
  "3592   J  1000GC   1024.00Gi");

# Abort if the old vmgr_listtape function does not work with the new vmgr
print("\n");
print("CHECKING OLD VMGR_LISTTAPE FUNCTION WORKS WITH NEW VMGR\n");
&testRunCmdAsOutput("root",
  "2>&1 $vmgrlisttape_trunk_r21843_path",
  "I02023   I02023 IBMLIB1B 1000GC   aul stager_dev04    1024.00GiB 00000000 \n" .
  "I10486   I10486 IBMLIB3B 1000GC   aul stager_dev04    1024.00GiB 00000000 DISABLED\n" .
  "I12035   I12035 IBMLIB3B 1000GC   aul stager_dev04    1024.00GiB 00000000 DISABLED\n" .
  "I12038   I12038 IBMLIB3B 1000GC   aul stager_dev04    1024.00GiB 00000000 DISABLED\n" .
  "I12438   I12438 IBMLIB3B 1000GC   aul stager_dev04    1024.00GiB 00000000 DISABLED");

# Abort if the production clients do not work correctly with the new vmgr
print("\n");
print("CHECKING PRODUCTION CLIENTS WORK WITH NEW VMGR\n");
for $vid (sort keys %tapes) {
  $cmdResultStr = &runCmdAs("root",
    "ssh $nonRootUserName\@$productionHost VMGR_HOST=$testVmgrHost vmgrlisttape -V $vid");
  chomp($cmdResultStr);
  print("cmdResultStr=\"$cmdResultStr\"\n");
  $tapePool     = "UNKNOWN";
  $freeSpaceStr = "UNKNOWN";
  $tapeStatus   = "UNKNOWN";
  #if($cmdResultStr =~ m/$vid +$vid +$tapes{$vid}{li} +$tapes{$vid}{d} +$tapes{$vid}{l} +(\w+) +(\w+) +(\w+) $/) {
  if($cmdResultStr =~ m/$vid +$vid +$tapes{$vid}{li} +$tapes{$vid}{d} +$tapes{$vid}{l} +(\w+) +([^ ]+) +\d+ (.*)$/) {
    $tapePool     = $1;
    $freeSpaceStr = $2;
    $tapeStatus   = $3;
    $tapeStatus   =~ s/ //g;
  } else {
    die "vmgrlisttape -V $vid failed with production vmgr:" .
      " Failed to match output\n";
  }
  print("tapePool     = \"$tapePool\"\n");
  print("freeSpaceStr = \"$freeSpaceStr\"\n");
  print("tapeStatus   = \"$tapeStatus\"\n");
  die "vmgrlisttape -V $vid failed with production vmgr:" .
    " Incorrect tape-pool: expected=\"tape_dev\", actual=\"$tapePool\"\n"
    unless $tapePool eq $tapes{$vid}{po};
  die "vmgrlisttape -V $vid failed with production vmgr:" .
    " Incorrect free-space: expected=\"1.00TiB\", actual=\"$freeSpaceStr\"\n"
    unless $freeSpaceStr eq "1024.00GiB";
  if($vid eq $vids[0]) {
    die "vmgrlisttape -V $vid failed with production vmgr:" .
      " Incorrect status: expected=\"DISABLED\", actual=\"$tapeStatus\"\n"
      unless $tapeStatus eq "";
  } else {
    die "vmgrlisttape -V $vid failed with production vmgr:" .
      " Incorrect status: expected=\"DISABLED\", actual=\"$tapeStatus\"\n"
      unless $tapeStatus eq "DISABLED";
  }
}

exit(0);

# Create a seed file for migrations
my $tmpSeedFilename = `runuser murrayc3 -c mktemp`;
chomp($tmpSeedFilename);
print("tmpSeedFilename=$tmpSeedFilename\n");
print("dd if=/dev/urandom of=$tmpSeedFilename bs=1M count=100\n");
$status = system("runuser murrayc3 -c \"dd if=/dev/urandom of=$tmpSeedFilename bs=10M count=10\"");
die "dd failed: status=$status" unless $status == 0;

print("nsrm -rf $nsDir\n");
$status = system("runuser murrayc3 -c \"nsrm -rf $nsDir\"");
die "nsrm -rf $nsDir failed: status=$status" unless $status == 0;
print("nsmkdir $nsDir\n");
$status = system("runuser murrayc3 -c \"nsmkdir $nsDir\"");
die "nsmkdir -rf $nsDir failed: status=$status" unless $status == 0;

my $nsFilename       = "";
my $tmpLocalFilename = "";
for($i=1; $i<=1; $i++) {
  # Create the name-server filename
  $nsFilename = "$nsDir/test_100M_$i";
  print("nsFilename=$nsFilename\n");

  # Create a local temporary file from the temporary seed-file
  $tmpLocalFilename = `runuser murrayc3 -c mktemp`;
  chomp($tmpLocalFilename);
  print("tmpLocalFilename=$tmpLocalFilename\n");
  `runuser murrayc3 -c \"echo $nsFilename >> $tmpLocalFilename\"`;
  `runuser murrayc3 -c \"cat $tmpSeedFilename >> $tmpLocalFilename\"`;

  # Copy the temporary local file to castor
  print("rfcp $tmpLocalFilename $nsFilename\n");
  $status =
    system("runuser murrayc3 -c \"rfcp $tmpLocalFilename $nsFilename\"");
  die "rfcp failed: status=$status" unless $status == 0;

  # Delete the temporary local file
  `runuser murrayc3 -c \"rm $tmpLocalFilename\"`;
}

# Delete the seed file
print("rm $tmpSeedFilename\n");
`runuser murrayc3 -c \"rm $tmpSeedFilename\"`;
