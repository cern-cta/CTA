Lifecycles notes
================

Creation and transistions of tapecopies, status by status (hopefully not missing any due to hardcoded state values).

=> poke
<= peek
VV Validation

=============== T A P E C O P Y ====================================================================

-   TAPECOPY_CREATED      CONSTANT PLS_INTEGER := 0;
=> In orastager.sql: internalPutDoneFunc creates it, only references castorfile.
=> In oracleTape.sql: fileRecalled creates it with a copynb = 0 for remigration of missing tapecopies. (Yuck!) Same as previous otherwise.
=> In oracleTapeGateway.sql: tg_setFileRecalled, ditto.
=> In rtcopy/tapeerrorhandler: static int doMigrationRetry(struct Cstager_Segment_t *segment,
                            struct Cstager_TapeCopy_t *tapeCopy): [...]     Cstager_TapeCopy_setStatus(tapeCopy,TAPECOPY_CREATED);
<= In oracleTape.sql: inputForMigrationPolicy find them (in bulk) and moves them to TAPECOPY_WAITPOLICY with immediate commit.

- TAPECOPY_TOBEMIGRATED CONSTANT PLS_INTEGER := 1;
=> In oracleTape.sql: rtcpclientdCleanUp moves all tapecopies from TAPECOPY_SELECTED to TAPECOPY_TOBEMIGRATED
=> In oracleTape.sql: migHunterCleanUp moves all tapecopies from svcClass to TAPECOPY_TOBEMIGRATED from TAPECOPY_WAITPOLICY
<= In oracleTape.sql: inputForMigrationPolicy find them (in bulk) and moves them to TAPECOPY_WAITPOLICY with immediate commit.
=> In oracleTape.sql: attachTCRtcp resets status to TAPECOPY_TOBEMIGRATED from TAPECOPY_WAITSTREAM or TAPECOPY_WAITPOLICY in case of problem attaching to streams. Suspect algorithm there.
=> In oracleTape.sql: attachTCGateway resets status to TAPECOPY_TOBEMIGRATED from TAPECOPY_WAITSTREAM or TAPECOPY_WAITPOLICY in case of problem attaching to streams. Algo looks better.
=> In oracleTape.sql: resurrectCandidates resets status to TAPECOPY_TOBEMIGRATED from TAPECOPY_WAITPOLICY from a list.
=> In oracleTapeGateway.sql: tg_endTapeSession failed tape copies are resurrected to TAPECOPY_TOBEMIGRATED if found with no error ("lost").
=> In oracleTapeGateway.sql: tg_setMigRetryResult. Status set to TAPECOPY_TOBEMIGRATED (straightforward case)
=> In oracleTapeGateway.sql: tg_deleteStream. Status reset to TAPECOPY_TOBEMIGRATED for copies orphaned by a stream deletion.

- TAPECOPY_WAITSTREAM   CONSTANT PLS_INTEGER := 2;
<= In oracleTape.sql: anyTapeCopyForStream checks the presence of any tapecopy in status TAPECOPY_WAITSTREAM (+other criterias) in a given stream
<= In oracleTape.sql: defaultMigrSelPolicy selects a tapecopy for migration and returns the id.
<= In oracleTape.sql: drainDiskMigrSelPolicy similar behaviour.
<= In oracleTape.sql: repackMigrSelPolicy similar behaviour.
=> In oracleTape.sql: attachTCRtcp sets status to TAPECOPY_WAITSTREAM after attaching it to streams.
=> In oracleTape.sql: attachTCGateway sets status to TAPECOPY_WAITSTREAM in a similar fashion.
<= In oracleTapeGateway.sql: tg_defaultMigrSelPolicy selects a tapecopy for migration and returns the id.
<= In oracleTapeGateway.sql: tg_drainDiskMigrSelPolicy similar behaviour.
<= In oracleTapeGateway.sql: tg_repackMigrSelPolicy similar behaviour.

- TAPECOPY_SELECTED     CONSTANT PLS_INTEGER := 3;
<= In oracleJob.sql: firstByteWrittenProc used as a check before overwriting a file. (select count (*)).
<= In oracleStager.sql: recreateCastorFile used as a check before recreating a castorfile. (select count (*)).
<= In oracleStager.sql: stageRelease used as a check before recreating a castorfile. (select count (*)).
VV In oracleTape.sql: TR_TapeCopy_VID used to check transitions.
=> In oracleTape.sql: defaultMigrSelPolicy set status on selection.
=> In oracleTape.sql: drainDiskMigrSelPolicy set status on selection.
=> In oracleTape.sql: repackMigrSelPolicy set status on selection.
<= In oracleTape.sql: rtcpclientdCleanUp moves all tapecopies from TAPECOPY_SELECTED to TAPECOPY_TOBEMIGRATED
<= In oracleTapeGateway.sql: tg_endTapeSession failed tape copies are resurrected to TAPECOPY_TOBEMIGRATED if found with no error ("lost"). TAPECOPY_SELECTED is used as a marker at this point only.
<= In oracleTapeGateway.sql: tg_defaultMigrSelPolicy (x2) used with TAPECOPY_STAGED as a marked for sibling with a decided destination (multi-tapecopies on different tapes)
<= In oracleTapeGateway.sql: tg_drainDiskMigrSelPolicy (x3) used with TAPECOPY_STAGED as a marked for sibling with a decided destination (multi-tapecopies on different tapes)
<= In oracleTapeGateway.sql: tg_repackMigrSelPolicy (x1) used with TAPECOPY_STAGED as a marked for sibling with a decided destination (multi-tapecopies on different tapes)
=> In oracleTapeGateway.sql: tg_getFileToMigrate sets the status when a TC is selected and detached from streams.

- TAPECOPY_TOBERECALLED CONSTANT PLS_INTEGER := 4;
=> In OraStageSvc.cpp: castor::db::ora::OraStagerSvc::createTapeCopySegmentsForRecall: Created (for recall).
=> In OracleTapeGateway: tg_setRecRetryResult: Status set to TAPECOPY_TOBERECALLED (from id list on input)

Note: no peek as the recalls are segment driven (see segment lifecycle).

- TAPECOPY_STAGED       CONSTANT PLS_INTEGER := 5;
VV In oracleTape.sql: TR_TapeCopy_VID used to check transitions.
<= In oracleTapeGateway.sql: tg_defaultMigrSelPolicy (x2) used with TAPECOPY_SELECTED as a marked for sibling with a decided destination (multi-tapecopies on different tapes)
<= In oracleTapeGateway.sql: tg_drainDiskMigrSelPolicy (x3) used with TAPECOPY_SELECTED as a marked for sibling with a decided destination (multi-tapecopies on different tapes)
<= In oracleTapeGateway.sql: tg_repackMigrSelPolicy (x1) used with TAPECOPY_SELECTED as a marked for sibling with a decided destination (multi-tapecopies on different tapes)
=> and <= In oracleTapeGateway.sql: TG_SetFileMigrated: After migration, tapecopy is marked as TAPECOPY_STAGED. When all TCs are STAGED for a given castorfile, they get destroyed.

- TAPECOPY_FAILED       CONSTANT PLS_INTEGER := 6;
VV In oracleTape.sql: TR_TapeCopy_VID used to check transitions.
=> In oracleTape.sql: invalidateTapeCopies set the status of tapecopies (in bulk, from input list) when they are in TAPECOPY_WAITPOLICY.
<= In oracleTapeGateway.sql: tg_getFileToMigrate used to rule out tapecopies in conflict check
=> In oracleTapeGateway.sql: tg_setMigRetryResult set the status of retry policy, in bulk

- TAPECOPY_WAITPOLICY   CONSTANT PLS_INTEGER := 7;
<= In oracleTape.sql: migHunterCleanUp clean up tapecopies, WAITPOLICY reset into TOBEMIGRATED
=> In oracleTape.sql: inputForMigrationPolicy bulk set to WAITPOLICY from tconst.TAPECOPY_CREATED, tconst.TAPECOPY_TOBEMIGRATED (batches of 10000)
<=> In oracleTape.sql: attachTCRtcp set status to TAPECOPY_WAITSTREAM from TAPECOPY_WAITPOLICY (and potentially back to TAPECOPY_WAITPOLICY from TAPECOPY_WAITSTREAM in case of problem.
<=> In oracleTape.sql: attachTCGateway similar to attachTCRtcp


- TAPECOPY_REC_RETRY    CONSTANT PLS_INTEGER := 8;
=> In oracleTapeGateway: tg_endTapeSession. Set in case of error (from list of ids)
=> In oracleTapeGateway: tg_failFileTransfer Set TC status in case of a recall
<= In oracleTapeGateway: tg_getFailedRecalls: bulk selection of failed recall tapecopies. (batches of 1000)
(<=) In oracleTapeGateway: tg_getFileToMigrate, explicitely left out.

  TAPECOPY_MIG_RETRY    CONSTANT PLS_INTEGER := 9;
VV In oracleTape.sql: TR_TapeCopy_VID used to check transitions.
=> In oracleTapeGateway.sql: tg_endTapeSession. Set in case of error (from list of ids)
=> In oracleTapeGateway.sql: tg_failFileTransfer Set TC status in case of a migration
<= In oracleTapeGateway.sql: tg_getFailedMigrations: bulk selection of failed recall tapecopies. (batches of 1000)
(<=) In oracleTapeGateway.sql: tg_getFileToMigrate, explicitely left out.

====================== S T R E A M =====================================================================================

- STREAM_PENDING    CONSTANT PLS_INTEGER := 0;
<= In oracleTape.sql: streamsToDo: Finds all PENDING streams with workable tapecopy/discopy couples
=> In oracleTape.sql: rtcpclientdCleanUp: mostly reset all stream to pending (from NOT IN (tconst.STREAM_PENDING, tconst.STREAM_CREATED, tconst.STREAM_STOPPED, tconst.STREAM_WAITPOLICY))
=> In oracleTape.sql: startChosenStreams: status set, from list.
<= In oracleTapeGateway.sql: tg_getStreamsWithoutTapes bulk collects of id and other info (cursor)
=> In rtcpcltdCatalogueInterface: Cstager_Stream_setStatus(streamArray[i],STREAM_PENDING); in some error cases.


- STREAM_WAITDRIVE  CONSTANT PLS_INTEGER := 1;
=> In oracleTape.sql: streamsToDo Bulk setting of status before reporting the list. (From pending)
=> In oracleTapeGateway.sql: tg_attachDriveReqToTape: status set indirectly from tape request id.
<= In oracleTapeGateway.sql: tg_getTapesWithDriveReqs: bull collection of streams in tconst.STREAM_WAITDRIVE, tconst.STREAM_WAITMOUNT, tconst.STREAM_RUNNING


- STREAM_WAITMOUNT  CONSTANT PLS_INTEGER := 2;
=> In OraTapeSvc.cpp: castor::db::ora::OraTapeSvc::anyTapeCopyForStream: if a tapecopy is found for this stream (input) from SQL anyTapeCopyForStream, changes its status to STREAM_WAITMOUNT
<= In oracleTape.sql: defaultMigrSelPolicy updates the status of the current stream from tconst.STREAM_WAITMOUNT,tconst.STREAM_RUNNING after selecting a tapecopy. [ No check upfront at beginning of function, could be a good idea ]
<= In oracleTape.sql: drainDiskMigrSelPolicy same.
<= In oracleTape.sql: repackMigrSelPolicy same.
<= In oracleTapeGateway.sql: tg_getTapesWithDriveReqs lists tapes (reads and write) by VDQM ping time and reports on the list. Just locks the streams.

- STREAM_RUNNING    CONSTANT PLS_INTEGER := 3;
=> In oracleTape.sql: defaultMigrSelPolicy sets the given stream to RUNNING when a tapecopy has been found.
=> In oracleTape.sql: drainDiskMigrSelPolicy same.
=> In oracleTape.sql: repackMigrSelPolicy same.
<= In oracleTape.sql: inputForStreamPolicy (dead code: not called (it seems)) return a count of the running streams as part of imput for policy.
<= In oracleTapeGateway.sql: tg_getTapesWithDriveReqs lists tapes (reads and write) by VDQM ping time and reports on the list. Just locks the streams.
=> In oracleTapeGateway.sql: sets the status of stream to RUNNING (and tape to MOUNTED)
<= In oraMigHunterSvc.cpp: s_tapePoolsForStreamPolicyStatementString (hardcoded SQL statement for castor::tape::mighunter::ora::OraMigHunterSvc::tapePoolsForStreamPolicy) looking for running streams of a given service class.
 
- STREAM_WAITSPACE  CONSTANT PLS_INTEGER := 4; [ Probably dead state ]
<= In oracleTape.sql: inputForStreamPolicy (dead code: not called (it seems)) finds stream IN (tconst.STREAM_WAITSPACE, tconst.STREAM_CREATED, tconst.STREAM_STOPPED) for a service class
<= In oracleTape.sql: streamsForStreamPolicy finds stream IN (tconst.STREAM_WAITSPACE, tconst.STREAM_CREATED, tconst.STREAM_STOPPED) for a service class
  
- STREAM_CREATED    CONSTANT PLS_INTEGER := 5;
(<=) In oracleTape.sql: rtcpclientdCleanUp reset some statues to pending but not from the one. (anti peek).
=> In oracleTape.sql: migHunterCleanUp: reset to STREAM_CREATED from tconst.STREAM_WAITPOLICY
<= In oracleTape.sql: inputForStreamPolicy (dead code: not called (it seems)) finds stream IN (tconst.STREAM_WAITSPACE, tconst.STREAM_CREATED, tconst.STREAM_STOPPED) for a service class
<= In oracleTape.sql: streamsForStreamPolicy finds stream IN (tconst.STREAM_WAITSPACE, tconst.STREAM_CREATED, tconst.STREAM_STOPPED) for a service class
=> In oracleTape.sql: createOrUpdateStream: Actual creation.

- STREAM_STOPPED    CONSTANT PLS_INTEGER := 6;
=> In oracleTape.sql: deleteOrStopStream stops the stream if deletion  fails. A bit brutal (exception driven).
(<=) In oracleTape.sql: rtcpclientdCleanUp reset some statues to pending but not from the one. (anti peek).
<= In oracleTape.sql: inputForStreamPolicy (dead code: not called (it seems)) finds stream IN (tconst.STREAM_WAITSPACE, tconst.STREAM_CREATED, tconst.STREAM_STOPPED) for a service class
<= In oracleTape.sql: streamsForStreamPolicy finds stream IN (tconst.STREAM_WAITSPACE, tconst.STREAM_CREATED, tconst.STREAM_STOPPED) for a service class

- STREAM_WAITPOLICY CONSTANT PLS_INTEGER := 7;
(<=) In oracleTape.sql: rtcpclientdCleanUp reset some statues to pending but not from the one. (anti peek).
<= In oracleTape.sql: migHunterCleanUp: reset to STREAM_CREATED from tconst.STREAM_WAITPOLICY
=> In oracleTape.sql: inputForStreamPolicy (dead code: not called (it seems)): set selected stream to STREAM_WAITPOLICY
=> In oracleTape.sql: streamsForStreamPolicy: finds stream IN (tconst.STREAM_WAITSPACE, tconst.STREAM_CREATED, tconst.STREAM_STOPPED) for a service class and sets them to STREAM_WAITPOLICY
<= In oracleTape.sql: startChosenStreams: moves chosen streams (by policy) to tconst.STREAM_PENDING.

- STREAM_TO_BE_SENT_TO_VDQM CONSTANT PLS_INTEGER := 8;
=> In oracleTapeGateway.sql: tg_attachTapesToStreams: status set to STREAM_TO_BE_SENT_TO_VDQM when tapes get attached to it.
<= In oracleTapeGateway.sql: tg_getTapeWithoutDriveReq: find one stream in STREAM_TO_BE_SENT_TO_VDQM.

====================== S E G M E N T =====================================================================================

- SEGMENT_UNPROCESSED CONSTANT PLS_INTEGER := 0;
<= In oracleTape.sql: segmentsForTape: bulk collects all segments in SEGMENT_UNPROCESSED for a given tape, sets tape to tconst.TAPE_MOUNTED and segs to tconst.SEGMENT_SELECTED [ suspition of high inefficiency as a cursor's result gets copied in memory ]
<= In oracleTape.sql: anySegmentsForTape: sets tape status to tconst.TAPE_WAITMOUNT if any UNPROCESSED segment lives on it.
=> In oracleTape.sql: rtcpclientdCleanUp: ressurects all SELECTED segments to UNPROCESSED (also kicks the corresponding tapes to WAITPOLICY
<= In oracleTape.sql: inputForRecallPolicy (dead code, wrapper in rechancler, but not called): returns summaries of segments in SEGMENT_UNPROCESSED state for tapes.
<= In oracleTape.sql: tapesAndMountsForRecallPolicy (used by rechandler, wrapper exists, is called) very similar to inputForRecallPolicy
<=> In oracleTape.sql: restartStuckRecalls: resets segments and tapes based on various criterias. (This is called continuously by a scheduled job (every 60 seconds!))
<=> In oracleTapeGateway.sql: tg_endTapeSession: some "lost" segments resurected into UNPROCESSED. Then immediately peeked to give a kick to the tape.
<= In oracleTapeGateway.sql: tg_getFileToRecall: finds a segment to recall from a given tape and sets it to SELECCTED
=> In oracleTapeGateway.sql: tg_setRecRetryResult: resets the segments from a given tapecopy to UNPROCESSED from tapecopy list.
=> In rtcopy/rtcpcltdCatalogueInterface.c: rtcpcld_restoreSelectedSegments: used to reset failed segments at the end of a tape session (see comment at the beginning of the function).
=> In rtcopy/TapeErrorHandler.c: doRecallRetry: sets a segments to retried and clones it into UNPROCESSED.

- SEGMENT_FILECOPIED  CONSTANT PLS_INTEGER := 5;
=> In rtcopy/rtcpcldCatalogueInterface.c: rtcpcld_updcFileRecalled: some segments set to SEGMENT_FILECOPIED
<= In rtcopy/TapeErrorHandler.c: checkRecallRetry used in some (quite intricate) error handling algorithm.
  
- SEGMENT_FAILED      CONSTANT PLS_INTEGER := 6;
<= In oracleTape.sql: failedSegments lists all FAILED segments
=> In oracleTapeGateway.sql: tg_endTapeSession: sets the segments to failed for all the tapecopies passed as a list to the procedure.
=> In oracleTapeGateway.sql: tg_failFileTransfer: sets a segment as failed by tape/fseq id (so just one).
=> In rtcopy/rtcpcldCatalogueInterface.c: rtcpcld_updcMigrFailed: "Catalogue update after failed migration"
=> In rtcopy/rtcpcldCatalogueInterface.c: rtcpcld_updcRecallFailed: "Catalogue update after failed recall"
<= In rtcopy/rtcpcldCatalogueInterface.c: rtcpcld_putFailed will move segments from SEGMENT_FAILED to SEGMENT_RETRIED
<= In rtcopy/rtcpcldCatalogueInterface.c: rtcpcld_restoreSelectedSegments counts the SEGMENT_FAILED for the tape being processed (one tape, passed as an argument)

- SEGMENT_SELECTED    CONSTANT PLS_INTEGER := 7;
=> In oracleTape.sql: segmentsForTape: bulk collects all segments in SEGMENT_UNPROCESSED for a given tape, sets tape to tconst.TAPE_MOUNTED and segs to tconst.SEGMENT_SELECTED [ suspition of high inefficiency as a cursor's result gets copied in memory ]
<= In oracleTape.sql: restartStuckRecalls: resets segments and tapes based on various criterias. (This is called continuously by a scheduled job (every 60 seconds!))
<= In oracleTapeGateway.sql: tg_endTapeSession: resurrect lost segments from UNPROCESSED to SELECTED. ( fishy... )
=> In oracleTapeGateway.sql: tg_getFileToRecall: set to tconst.SEGMENT_SELECTED from tconst.SEGMENT_UNPROCESSED  for the selected tapecopy of a recall.
<= In rtcopy/rtcpcltdCatalogueInterface.c: tcpcld_restoreSelectedSegments: restores SELECTED segments to UNPROCESSED (from an input list).

- SEGMENT_RETRIED     CONSTANT PLS_INTEGER := 8;
<= In rtcopy/rtcpcltdCatalogueInterface.c: rtcpcld_updcFileRecalled: complext logic with if not status != SEGMENT_RETRIED. Boils down to a peek (in conjunction with SEGMENT_FILECOPIED)
=> In rtcopy/rtcpcltdCatalogueInterface.c: rtcpcld_putFailed: Flag failed segment retried so that it won't be selected for retry (from SEGMENT_FAILED)
=> In rtcopy/TapeErrorHandler.c: doRecallRetry sets status of the segment to RETRIED
d=> In rtcopy/TapeErrorHandler.c: oMigrationRetry  sets status of the segment to RETRIED



