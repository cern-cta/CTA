#!/usr/bin/python

"""
This script creates links to tape and medium changer devices.
The association between tape and smc device is made based on
the serial numbers stored in the TOMS DB.
"""

import re
import os
import sys
import socket 
import pprint
import urllib2
import optparse
import cookielib
import subprocess 
pp = pprint.PrettyPrinter(width=200)

#------------------------------------------------------------
def mklink(dev, sn, drivename, type):
    if not options.noaction and drivename is not None:
        link = '/dev/' + type + '_' + drivename
        subprocess.Popen(['/bin/ln', '-f',  '-s', dev, link]).wait()
        print 'Created link', link
    else:
        print 'Cannot create link to ' + dev
        print 'Drivename for serial number ' + sn + ' not found'

#------------------------------------------------------------
def fix_mismatch(mm_tape_dev, toms_drives, hostname):
    #this fucntions assumes that there is only one mismatch,
    #i.e. only one tape device with S/N not found in TOMS
    #and only one drives in TOSM with S/N not found in the server.
    l = []
    cj = cookielib.CookieJar()
    opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(cj))
    for d in toms_drives:
        if d['match'] == 0:
            #assigning drivename to the mismatched tape device 
            mm_tape_dev['drivename'] = d['drivename']
            #fixing the S/N in TOMS
            tomsurl = 'http://castortapeweb.cern.ch/cgi-bin/serial-nr-update.cgi?tapedrive=' + d['drivename'] + '&tapeserver=' + hostname + '&serialnumber=' + mm_tape_dev['sn']
            if options.debug: print 'Opening', tomsurl
            try:
                urlfh = opener.open(tomsurl)
            except:
                print 'Cannot open ' + tomsurl
                
            
#------------------------------------------------------------
#main
#------------------------------------------------------------

# options ---------------------------------------------------
usage = "usage: %prog [options]"
parser = optparse.OptionParser(usage)
parser.add_option("-d", "--debug", action="store_true", dest="debug", help="print debug messages")
parser.add_option("--noaction", action="store_true", dest="noaction", help="do nothing")
(options, args) = parser.parse_args()

tape_devices = []
smc_devices = []

# find tape and smc devices
if options.debug: print 'Searching tape devices'
try:
    p = subprocess.Popen(['/usr/bin/lsscsi', '-g'], stdout=subprocess.PIPE)
    p.wait()
except:
    print 'Cannot run lsscsi. Exit.'
    sys.exit(0)
    
for line in p.stdout:
    fields = line.split() 
    scsi_address = fields[0][1:-1]
    type = fields[1]
    scsi_generic = fields.pop()
    scsi_tape = fields.pop()
    if type == 'tape':
        tape_devices.append({'scsi_address' : scsi_address, 'scsi_generic' : scsi_generic, 'scsi_tape' : scsi_tape, 'sn' : None, 'drivename' : None})
    if type == 'mediumx':
        smc_devices.append({'scsi_address' : scsi_address, 'scsi_generic' : scsi_generic, 'scsi_tape' : scsi_tape, 'sn' : None, 'drivename' : None})

ntpdev=len(tape_devices)

if options.debug:
    print 'tape_devices:'
    pp.pprint(tape_devices)
    print 'smc_devices:'
    pp.pprint(smc_devices)

# associate tape and smc devices
if options.debug: print 'Coupling tape and smc devices (if any)'
pairs = []
for tapedev in tape_devices:
    for smcdev in smc_devices:
        if tapedev['scsi_address'][:-2] == smcdev['scsi_address'][:-2]:
            pairs.append([tapedev, smcdev])
if options.debug:
    print 'pairs:'
    pp.pprint(pairs)

if len(tape_devices)>len(smc_devices) and len(smc_devices)>0:
    print 'Number of control paths lower that number of drives'
    sys.exit(0)


# find the serial number of the tape device
# sg_inq will not work if the /dev/sgX device is not reachable
# sg_inq will not work if the /dev/nstY device is being used
# run sg_inq against the nst dev so that if it is already being used we exit
if options.debug: print 'Reading serial numbers from tape devices'

for tapedev in tape_devices:
    tapedn = '/dev/nst'+tapedev['scsi_tape'][-1]
    p = subprocess.Popen(['/usr/bin/sg_inq', tapedn], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    if p.wait() != 0:
        print 'Cannot run sg_inq on ' +  tapedn + '. Exit'
        sys.exit(0)
    else:
        for line in p.stdout:
            #reg = re.search('(?<=Unit serial number: )(\d+)', line)
            if re.search('Unit serial number', line):
                l = line.split(':')
                tapedev['sn'] = l[1][1:-1]

    if tapedev['sn'] is None:
        print 'Could not extract the serial number from the output of sg_inq ' + tapedn
        sys.exit(0)
                
if options.debug:
    print 'tape_devices:'
    pp.pprint(tape_devices)


# search the drive names in toms by serial number
toms_drives = []
if options.debug: print 'Looking into TOMS for drive names'
hostname = socket.gethostname().split('.')[0]
tomsurl =  'https://apex.cern.ch/pls/htmldb_castorns/f?p=toms_prod:250:::NO::P250_TAPESERVER:' + hostname
if options.debug: print 'Opening', tomsurl

cj = cookielib.CookieJar()
opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(cj))

try:
    urlfh = opener.open(tomsurl)
except:
    print 'Cannot open ' + tomsurl
    sys.exit(0)

for line in urlfh:

    if options.debug: print line

    if not re.search('TAPESERVER', line): continue

    drivename, serialnumber = '', ''

    l = line.split()
    for item in l:
        g = item.split('=')
        if g[0] == 'CURRENTSERIALNR': serialnumber =  g[1][1:-1]
        if g[0] == 'TAPEDRIVE': drivename =  g[1][1:-1]

    if drivename == '':
        print 'drive name for host ' + hostname + ' not found in TOMS'
        sys.exit(0)

    if serialnumber  == '':
        print 'Serial number for drive', drivename, 'not found in TOMS'
        #here we don't exit, in case of a signle mismatch we update the s/n

    toms_drives.append({'drivename' : drivename, 'sn': serialnumber, 'match' : 0})
        
    for tapedev in tape_devices:
        if tapedev['sn'] == serialnumber:
            tapedev['drivename'] = drivename
            for d in toms_drives:
                if d['drivename'] == drivename: d['match'] = 1

if options.debug:
    print 'tape_devices:'
    pp.pprint(tape_devices)
    print 'toms_drives:'
    pp.pprint(toms_drives)


#Check how many S/N are missing.
#1. If there is only one assume that the drive has been replaced and update the S/N in TOMS.
#2. If there are more than one the script does nothing (new or changed drives/devices
#   will not be configured (link not created).

devs_mm_sn = 0
mm_tape_dev = None
for t in tape_devices:
    if t['drivename'] is None:
        devs_mm_sn += 1
        mm_tape_dev = t

if devs_mm_sn == 1:
    print 'One S/N mismatch. Going to fix S/N in TOMS'
    fix_mismatch(mm_tape_dev, toms_drives, hostname)
elif devs_mm_sn == 0:
    if options.debug: print 'No S/N mismatches'
else:
    if options.debug: print 'Too many S/N mismatches'
    

# created links
if pairs == []:
    # this is a SUN tape server
    for tapedev in tape_devices:
        tapedn = '/dev/nst'+tapedev['scsi_tape'][-1]
        mklink(tapedn, tapedev['sn'], tapedev['drivename'], 'tape')
else:
    #this is a IBM tape server
    for pair in pairs:
        tapedev = pair[0]
        tapedn = '/dev/nst'+tapedev['scsi_tape'][-1]
        mklink(tapedn, tapedev['sn'], tapedev['drivename'], 'tape')
        smcdev = pair[1]
        mklink(smcdev['scsi_generic'], tapedev['sn'], tapedev['drivename'], 'smc')



