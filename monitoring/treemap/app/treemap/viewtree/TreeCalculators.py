'''
Created on May 25, 2010
This class contains the slicing algorithm, which is central to TreeMaps.
It receives the ObjectTree (with TreeNodes) and generates a ViewTree (with ViewNodes).
ViewNodes can have properties attached, describing how to view the node.

calculate returns a ViewTree where each ViewNode is created and extended with following properties:

treenode - original TreeNode object from data tree generated by TreeBuilder
spacesize - space to neighbour rectangles, in px
headersize - height of the rectangle header, in px
width - rectangle width
height - rectangle height
x - rectangle x pos in the image
y - rectangle y pos in the image
nbchildren - number of children the node has (for potential use)

@author: kblaszcz
'''
from app.treemap.viewtree.ViewTree import ViewTree
import math
from app.treemap.viewtree.ViewNode import ViewNode
from app.treemap.defaultproperties.TreeMapProperties import BasicViewTreeProps, ViewTreeCalculationProps, ViewTreeDesignProps

class SquaredTreemapCalculator(object):
    '''
    classdocs
    '''
    def __init__(self, otree, basic_properties = None, calc_properties = None):
        '''
        Constructor
        '''
        self.otree = otree
        
        assert(basic_properties is None or isinstance(basic_properties, BasicViewTreeProps)), "basic_properties wrong"
        self.basic_properties = basic_properties
        
        assert(calc_properties is None or isinstance(calc_properties, ViewTreeCalculationProps)), "calc_properties wrong"
        self.calc_properties = calc_properties
        
    def calculate(self, optimizefortxt = False, sorted = True, bigdifftreshold = 1.5, squareoverflowdecision = False):
        
        if self.basic_properties is None:
            self.basic_properties = BasicViewTreeProps()
        if self.calc_properties is None:
            self.calc_properties = ViewTreeCalculationProps(basic_properties = self.basic_properties)
            
        self.spacesize = self.calc_properties.getProperty('spacesize')
        self.minspacesize = self.calc_properties.getProperty('minspacesize')
        self.headersize = self.calc_properties.getProperty('headersize')

        width = self.basic_properties.getProperty('width')
        height = self.basic_properties.getProperty('height')
        self.otree.traveseToRoot()
        root = self.otree.getCurrentObject()
        
        viewtree = ViewTree(basic_properties = self.basic_properties, calc_properties = self.calc_properties)
        self.basic_properties.setProperty('viewtree',viewtree)
        self.calc_properties.setProperty('objecttree',self.otree)
        
        vnode = ViewNode()
        vnode.setProperty('treenode', root)
        vnode.setProperty('headersize', self.headersize)
        vnode.setProperty('spacesize', self.spacesize)
        vnode.setProperty('x', 0)
        vnode.setProperty('y', 0)
        vnode.setProperty('width', width)
        vnode.setProperty('height', height)
        vnode.setProperty('level', self.otree.getCurrentObject().getDepth())
        vnode.setProperty('nbchildren', self.otree.countChildren())
        
        viewtree.setRoot(vnode)
        viewtree.traverseInto(vnode)
        
        x = self.spacesize
        y = self.spacesize + self.headersize
        width = width - 2*self.spacesize
        height = height - 2*self.spacesize-self.headersize
        
        if self.spacesize > self.minspacesize: self.spacesize = self.spacesize - 1
        
        self.calculateRecursion.__dict__['notextcount'] = 0
        self.calculateRecursion.__dict__["ratiocount"] = 0
        self.calculateRecursion.__dict__["ratiosum"] = 0.0
        
        self.calculateRecursion(x, y, width ,height , viewtree, self.spacesize, self.minspacesize, self.headersize, optimizefortxt, sorted, bigdifftreshold, squareoverflowdecision)
        
        print "notextcount: ", self.calculateRecursion.__dict__['notextcount']
        if self.calculateRecursion.__dict__["ratiocount"] > 0: print "AVERAGE RATIO: ", self.calculateRecursion.__dict__["ratiosum"]/self.calculateRecursion.__dict__["ratiocount"]
        return viewtree
        
    #line: The items are ordered graphically in lines of equally tall squares
    #it is like a line of text but with rectangles instead of letters
    def calculateRecursion(self, startx, starty, width ,height, viewtree, spacesize, minspacesize, headersize, optimizefortxt, sorted, bigdifftreshold, squareoverflowdecision):

        #calculate the area in square pixels
        pixels = float(height * width)
        
        #exclude everyhing that would be smaller than 1 pixel
        if pixels < (1.0+spacesize)*(1.0+spacesize): return
        startxold = startx
        startyold = starty
        nblines = 0 #counts how many lines are completed before the cleanup code starts
        
        #go deeper only if parent had a header
        parenthsize = viewtree.getCurrentObject().getProperty('headersize')
        if parenthsize <= 0.0:
            return
        
        #children at the current position, ordered from the biggest to smallest, the algorithm works only if children[i] <= children[i+1]
        if sorted:
            children = self.otree.getSortedChildren()
        else:
            children = self.otree.getChildren()
        if len(children) <= 0: return
        
        #collect all nodes that can be displayed
        totalchildnodes = [] #for recursive traversal in the ObjectTree
        totalviewnodes = [] #to determine the size of each node
        
        linesum = 0.0 #accumulate line length sum of the rectangles until you go over parents rectangle border
        areasum = 0.0 #sum of the rectangle areas for one line
        percentagesum = 0.0 #needed to calculate how many percent of the parent area are 100% of the line area
        
#        class L(list): pass #removing read only properties from built-in type list to extend dynamically with attributes 
#        line_collection = L() #Nodes collected for current line
#        line_collection.sum = 0 #sum of raw values
        line_collection = []
        
        VERTICAL, HORIZONTAL = range(2)
        if width > height:
            direction = VERTICAL
            linelen = height
        else:
            direction = HORIZONTAL
            linelen = width
        
        #variable needed in the for loop. It stores if the previous value already exceeded linelen if slicing was vertically
        includeoverflowold = False
        #sqwidthold to decect big differences between values 
        sqwidthold = 0;
        
        avgratio = 0.0
        
        for child in children:
            
            percentage = child.evaluate() # evaluation must be percentage of the parent area
            
            if percentage <= 0: #if child invisible
                continue
            
            area = percentage*pixels #needed area for that child in square pixels
            sqwidth = math.sqrt(area) #in best case you wish to have a square, so calculate the dimension of the ideal square
            
            if squareoverflowdecision:
                #if slicing of the stripe is vertical, don't add the overflow value to the next line_collection, but to the current one
                #in that way there will be higher probability for width > height, which enables to display more horizontal text
                #vertical text is considered less user friendly and is therefore not implemented
                #includetrigger can be true only once per strip because of the "includeoverflowold = includeoverflow" below:
                #in the iteration after includetrigger is true, both variables will be true and therefore includetrigger will be false
                includeoverflow = (direction == VERTICAL) and ((linesum + sqwidth) > linelen)
                includetrigger = (includeoverflowold == False) and (includeoverflow == True) and optimizefortxt
                
                #optimize by detecting big size differences if the incoming values are sorted
                bigdifftrigger = sqwidthold/sqwidth > 1.5
                if sorted == False: bigdifftrigger = False 
                stopdecision = (((linesum + sqwidth) > linelen) and not includetrigger) or bigdifftrigger
            else:
                
                avgratioahead = self.calcAvgRatio(line_collection, percentagesum, pixels, linelen, child)
                
                if avgratio >= 1.0 or avgratioahead >= 1.0:
                    stopdecision = True
                    if (math.fabs(1-avgratio)>math.fabs(1-avgratioahead)):
                        stopdecision = False
                    elif (avgratio <= 1.0 and avgratioahead >= 1.0) and optimizefortxt and direction == VERTICAL:
                        stopdecision = False
                        
                else:
                    stopdecision = False
                
                includeoverflow = False
                
            #if collecting items for current line is completed, because the next addition would go over the border
            #add all items to TreeView except of the current overflow one
            if stopdecision:
                #save the coordinates where the line starts
                xbeginning = startx
                ybeginning = starty
                #they all together have to be squeezed to same height and parent's size
                line_height = areasum/linelen 
                x,y,chheight,chwidth = 0.0, 0.0, 0.0, 0.0
         
                for ch in line_collection: #calculate the witdth of each child
                    percentage_of_line = ch.evaluate()/percentagesum #normalize percantage values relative to line
                    child_area = percentage_of_line * areasum #area in square pixels which the child will take in that line
                    child_width = child_area/line_height #height and area are known, now you can calculate width of the child
                    
                    #calculate final values
                    x = startx + spacesize
                    y = starty + spacesize
                    
                    if(direction == HORIZONTAL):
                        chwidth = child_width 
                        chheight = line_height
                    else:
                        chheight = child_width
                        chwidth = line_height
                           
                    self.calculateRecursion.__dict__["ratiocount"] = self.calculateRecursion.__dict__["ratiocount"] + 1
                    self.calculateRecursion.__dict__["ratiosum"] = self.calculateRecursion.__dict__["ratiosum"] + (chheight/chwidth)
                    
                    #store the calculated values
                    vn = ViewNode()
                    if 2*headersize > (chheight-2.0):
                        vn.setProperty('headersize', 0.0)
                    else:
                        vn.setProperty('headersize', headersize)
                        
                    vn.setProperty('treenode', ch)
                    vn.setProperty('spacesize', spacesize)
                    vn.setProperty('x', x)
                    vn.setProperty('y', y)
                    vn.setProperty('width', chwidth - 2.0 * spacesize)
                    vn.setProperty('height', chheight - 2.0 * spacesize)
                    vn.setProperty('level', self.otree.getCurrentObject().getDepth() + 1)
                    
                    currently_inscope = self.otree.getCurrentObject()
                    self.otree.traverseInto(child)
                    vn.setProperty('nbchildren', self.otree.countChildren())
                    self.otree.traverseInto(currently_inscope)
                    
                    totalchildnodes.append(ch)
                    totalviewnodes.append(vn)
                    viewtree.addChild(vn)
                    
                    #fix start position for next child
                    if(direction == HORIZONTAL):
                        startx = startx + child_width
                    else:
                        starty = starty + child_width
                
                #see what the ratio of the remaining area is
                remaining_ratio = 1.0        
                if(direction == HORIZONTAL):
                    remaining_ratio = (height-(starty-startyold)-chheight)/(width-(xbeginning - startxold))
                else:
                    remaining_ratio = (height-(ybeginning - startyold))/(width-(startx-startxold)-chwidth)
        
                #calculate start coordinates and direction for the next line
                if (direction == HORIZONTAL):
                    if remaining_ratio < 1.0:
                        direction = VERTICAL
                        linelen = height - (starty-startyold) -chheight 
                        startx = xbeginning
                        starty = starty + chheight
                    else:
                        starty = starty + chheight
                        startx = xbeginning
                        
                elif (direction == VERTICAL):
                    if remaining_ratio >= 1.0:
                        direction = HORIZONTAL
                        linelen = width - (startx-startxold) -chwidth
                        starty = ybeginning
                        startx = startx + chwidth
                    else:
                        starty = ybeginning
                        startx = startx + chwidth
                
                #take care of the remaining child which belongs to the next line
                linesum = sqwidth
                areasum = area
                percentagesum = percentage
                line_collection = [] #clear the children list for new line
                line_collection.append(child) #add the remaining child
                avgratio = self.calcAvgRatio(line_collection, percentagesum, pixels, linelen)
                
                nblines = nblines + 1 #counts the number of lines 
                
            else: #number of items not reached yet, accumulate values and append child to collection 
                linesum = linesum + sqwidth 
                areasum = areasum + area
                percentagesum = percentagesum + percentage
                line_collection.append(child)
                avgratio = avgratioahead
                
            #update includeoverflowold for the next iteration
            includeoverflowold = includeoverflow
            #save the square width to have value comparision for the next
            sqwidthold = sqwidth
        
        #cleanup code: In case of unprocessed items in line_collection
        if line_collection:
            #assuming line_collection, areasum, percentagesum have correct values from the previous loop
            xbeginning = startx
            ybeginning = starty
            
            line_height = areasum/linelen
            x,y = 0.0, 0.0
            
            for ch in line_collection:
                percentage_of_line = ch.evaluate()/percentagesum
                child_area = percentage_of_line * areasum
                child_width = child_area/line_height
                
                #calculate final values
                x = startx+spacesize
                y = starty+spacesize
                
                if(direction == HORIZONTAL):
                    chwidth = child_width
                    chheight = line_height
                else:
                    chheight = child_width
                    chwidth = line_height
                
                if (((chwidth-2.0*spacesize) <= 0) or ((chheight-2.0*spacesize) <= 0)):
                    continue
                    
                #store the calculated values
                vn = ViewNode()
                if 2.0 * headersize > (chheight-2.0):
                    vn.setProperty('headersize', 0.0)
                else:
                    vn.setProperty('headersize', headersize)
                    
                vn.setProperty('treenode', ch)
                vn.setProperty('spacesize', spacesize)
                vn.setProperty('x', x)
                vn.setProperty('y', y)
                vn.setProperty('width', chwidth-2.0*spacesize)
                vn.setProperty('height', chheight-2.0*spacesize)
                vn.setProperty('level', self.otree.getCurrentObject().getDepth() + 1)
                
                currently_inscope = self.otree.getCurrentObject()
                self.otree.traverseInto(child)
                vn.setProperty('nbchildren', self.otree.countChildren())
                self.otree.traverseInto(currently_inscope)
                    
                totalchildnodes.append(ch)
                totalviewnodes.append(vn)
                viewtree.addChild(vn)
                    
                #fix start position for next child
                if(direction == HORIZONTAL):
                    startx = startx + child_width
                else:
                    starty = starty + child_width
            
        #now that parent is ready, do recursion
        
        if spacesize > minspacesize: spacesize = spacesize - 1
        
        for i in range(len(totalchildnodes)):
            self.otree.traverseInto(totalchildnodes[i])
            viewtree.traverseInto(totalviewnodes[i])
            
            #see if it is big enough to have a header and do recursion
            hsize = totalviewnodes[i].getProperty('headersize')
            if hsize <= 0.0:
                self.calculateRecursion.__dict__['notextcount'] = self.calculateRecursion.__dict__['notextcount'] + 1
                self.calculateRecursion(totalviewnodes[i].getProperty('x') + 1, totalviewnodes[i].getProperty('y')+1, totalviewnodes[i].getProperty('width')-2 ,totalviewnodes[i].getProperty('height')-2, viewtree, spacesize, minspacesize, headersize, optimizefortxt, sorted, bigdifftreshold, squareoverflowdecision)
            else:
                self.calculateRecursion(totalviewnodes[i].getProperty('x') + 1, totalviewnodes[i].getProperty('y') + 1 + hsize, totalviewnodes[i].getProperty('width')-2 ,totalviewnodes[i].getProperty('height')-2 - hsize, viewtree, spacesize, minspacesize, hsize, optimizefortxt, sorted, bigdifftreshold, squareoverflowdecision)
                
            self.otree.traverseBack()
            viewtree.traverseBack()
        
    def calcAvgRatio(self, line_collection, thesum, pixels, linelen, child = None):
        if(child == None):
            avgsum = 0.0
            h = thesum*pixels/linelen
            if h != 0:
                width = 0.0
                for item in line_collection:
                    width = (item.evaluate()*pixels)/h
                    if width == 0.0: continue
                    avgsum = avgsum + h/width
            
            if len(line_collection) > 0:
                currentratio = avgsum/len(line_collection)
            else:
                currentratio = 0
            return currentratio
        else:
            avgsum = 0.0
            h = (thesum+child.evaluate())*pixels/linelen
            if h != 0:
                width = 0.0
                for item in line_collection:
                    width = (item.evaluate()*pixels)/h
                    if width == 0.0: continue
                    avgsum = avgsum + h/width
                
                width = (child.evaluate()*pixels)/h
                if width != 0.0:
                    avgsum = avgsum + h/width
                
            return avgsum/(len(line_collection)+1)

    
    
    
    