.\" $Id: stage_in_disk.man,v 1.2 2002/10/08 15:39:28 jdurand Exp $
.\"
.\" @(#)$RCSfile: stage_in_disk.man,v $ $Revision: 1.2 $ $Date: 2002/10/08 15:39:28 $ CERN IT-DS/HSM Jean-Damien Durand
.\" Copyright (C) 2002 by CERN/IT/DS/HSM
.\" All rights reserved
.\"
.TH STAGE_IN_DISK "3" "$Date: 2002/10/08 15:39:28 $" "CASTOR" "Stage Library Functions"
.SH NAME
stage_in_disk \- Asks for one or more disks files to be staged on disk
.SH SYNOPSIS
.BI "#include <" stage_api.h ">"
.sp
.BI "int stage_in_disk(u_signed64 " flags ,
.BI "int " openflag ,
.BI "char *" hostname ,
.BI "char *" pooluser ,
.BI "int " nstcp_input ,
.BI "struct stgcat_entry *" stcp_input ,
.BI "int *" nstcp_output ,
.BI "struct stgcat_entry **" stcp_output ,
.BI "int " nstpp_input ,
.BI "struct stgpath_entry *" stpp_input ");"

.SH DESCRIPTION
The \fBstage_in_disk\fP API method asks the stager for one or more DISK files to be staged on disk.
There are two ouputs: the default ttys (unless you use \fBstage_setlog\fP, see in the example below) and the output parameters, that are allocated on the fly (e.g. the user will have to free them if necessary/wanted).

.SH PARAMETERS
.TP 1.5i
.I flags
Can be zero or a logical or the following values:
.RS
.TP
.I STAGE_REQID
The member reqid of all 
.I stcp_input
structures given in input must match a known entry having exactly this request id. Otherwise, even it is set in the input structures, the reqid member will be ignored when processing the request.
.TP
.I STAGE_DEFERRED
If data is to be copied, allocation will be differed, e.g. done only when the copy of the file will begin.
.TP
.I STAGE_SILENT
Print nothing (the log callback will never be notified neither).
.TP
.I STAGE_NORETRY
Does not prevent stager daemon to decide to do a retry, neverthelessm, but prevents client to keep retrying in any case. Can be set with environment variable $STAGE_NORETRY to a non\-zero value.
.TP
.I STAGE_NOWAIT
If data is to be copied, this will be done in the background, and client will get an immediate return with ok status.
.RE
.TP
.I openflags
Not used here.
.TP
.I hostname
Gives explicitely the hostname where is the stager daemon. If it NULL, default value apply: either the environment variable $STAGE_HOST, an entry 'STG HOST' in /etc/shift.conf file, or the default "stagepublic".
.TP
.I pooluser
A file allocated in a pool will be stored in a subdirectory 
.I pooluser.
This may also be specified thru the environment variable $STAGE_USER. The default subdirectory name is "stage". 
.I pooluser
must be a valid user name and belong to the same group as the requestor.
.TP
.I nstcp_input
Number of stcp_input entries.
.TP
.I stcp_input
Entries describing the files you want to be staged. Only the member xfile of the structures is mandatory. Other members of interest are:
.RS
.TP
.I size
Gives how many bytes should be allocated rather than the default
.TP
.I poolname
Specify explicitely a disk pool
.LP
Others members should all be setted to zero in order to avoid your request to possibly misbehave. See example below.
.RE
.TP
.I nstcp_output
Filled with the number of staged entries at return.
.TP
.I stcp_output
Filled with the address of an array containg the staged entries at return. Up to the user to free it if necessary.
.TP
.I nstpp_input
Filled with the number of stpp_input entries. If this number is positive it must match the number of stcp_input entries. Otherwise it should be zero.
.TP
.I stpp_input
Array giving the list of link files that will be created each time one of the files described in stcp_input entries is staged on disk. Must be NULL or pointing to 
.I nstpp_input
entries.

.SH EXAMPLE
.ft CW
.nf
.sp
\s-2
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <signal.h>
#include "stage_api.h"
#include "serrno.h"

/* Usage: program_name diskfile diskfile ... */

void log_callback _PROTO((int, char *));
void cleanup _PROTO((int));
void record_callback _PROTO((struct stgcat_entry *, struct stgpath_entry *));

/* Here because of the cleanup */
int nstpp_input = 0;
struct stgpath_entry *stpp_input = NULL;
int cleanup_mode = 0;

int main(argc,argv)
	int argc;
	char **argv;
{
  u_signed64 flags = STAGE_DEFERRED;
  int nstcp_input;
  struct stgcat_entry *stcp_input;
  int nstcp_output;
  struct stgcat_entry *stcp_output = NULL; /* Important */
  int i;
  char *p;

  if (argc <= 1) {
	  fprintf(stderr,"Usage: %s diskfile1 [diskfile2 [...]]\\n", argv[0]);
	  exit(EXIT_FAILURE);
  }

  nstcp_input = argc-1;
  /* Create room the input structures */
  if ((stcp_input = calloc(nstcp_input,sizeof(struct stgcat_entry))) == NULL) {
	  perror("malloc");
	  exit(EXIT_FAILURE);
  }
  nstpp_input = nstcp_input;
  if ((stpp_input = calloc(nstpp_input,sizeof(struct stgpath_entry))) == NULL) {
	  perror("malloc");
	  free(stcp_input);
	  exit(EXIT_FAILURE);
  }

  /* Fill the stcp_input structures */
  for (i = 1; i <= nstcp_input; i++) {
	  if (strlen(argv[i]) > (CA_MAXHOSTNAMELEN+MAXPATH)) {
		  fprintf(stderr,"%s: too long\\n", argv[i+1]);
		  free(stcp_input);
		  free(stpp_input);
		  exit(EXIT_FAILURE);
	  }
	  /* Note: u1 is composed of unions - this is not a hasard that */
	  /* u1.h.xfile, u1.m.xfile and u1.d.xfile have the same address */
	  strcpy(stcp_input[i-1].u1.d.xfile, argv[i]);
  }

  /* Fill the stpp_input structures */
  for (i = 1; i <= nstpp_input; i++) {
	  if ((p = strrchr(argv[i],'/')) == NULL) p = argv[i];
	  if ((strlen(p) + strlen("/tmp/")) > (CA_MAXHOSTNAMELEN+MAXPATH)) {
		  fprintf(stderr,"%s: basename too long\\n", argv[i]);
		  free(stcp_input);
		  free(stpp_input);
		  exit(EXIT_FAILURE);
	  }
	  strcpy(stpp_input[i-1].upath, "/tmp");
	  strcat(stpp_input[i-1].upath, p);
  }

  /* In case we control-c, we have to implement the cleanup handler */
#if ! defined(_WIN32)
  signal (SIGHUP, cleanup);
  signal (SIGQUIT, cleanup);
#endif
  signal (SIGINT, cleanup);
  signal (SIGTERM, cleanup);

  /* Let's control totally the output */
  stage_setlog((void (*) _PROTO((int, char *))) &log_callback);

  /* And let's be waked up each time a record is available */
  if (stage_setcallback(&record_callback) != 0) {
	  fprintf(stderr,"stage_setcallback error: %s", sstrerror(serrno));
	  free(stcp_input);
	  free(stpp_input);
	  /* Utility function that converts stage serrno to a program exit code */
	  exit(rc_castor2shift(serrno));
  }

	/* Call the method */
  if (stage_in_disk(/* Preferred allocation mode - make sure it is u_signed64 on the stack */
				  flags,
				  /* No meaning here */
				  0,
				  /* Default stager hostname */
				  NULL,
				  /* pooluser - default is "stage" */
				  NULL,
				  /* Number of DISK files */
				  nstcp_input,
				  /* and the records giving the names */
				  stcp_input,
				  /* We are interested to have all records back */
				  /* with daemon modifications */
				  &nstcp_output,
				  &stcp_output,
				  /* And we ask for links */
				  nstpp_input,
				  /* described here */
				  stpp_input
	  ) != 0) {
	  fprintf(stderr,"stage_in_disk error: %s\\n", sstrerror(serrno));
	  /* Avoid unnecessary messaged from the stage_clr_Link */
	  cleanup_mode = 1;
	  /* Let's be kind and remove the links */
	  /* Stager will otherwise remind them for a long time */
	  for (i = 0; i < nstpp_input; i++) {
		  stage_clr_Link((u_signed64) 0, NULL, stpp_input[i].upath);
	  }
	  free(stcp_input);
	  free(stpp_input);
	  if (stcp_output != NULL) free(stcp_output); /* Should not be */
	  /* Utility function that converts stage serrno to a program exit code */
	  exit(rc_castor2shift(serrno));
  }

  /* Basically we have done prestaging */

  /* The recommend way to open the file is now rfio_open() on argv[] */
  
  /* We are done */
  /* Let's be kind and remove the links */
  /* Stager will otherwise remind them for a long time */
  for (i = 0; i < nstpp_input; i++) {
	  if (stage_clr_Link((u_signed64) 0, NULL, stpp_input[i].upath) != 0) {
		  fprintf(stderr,"stage_clr_Link error: %s\\n", sstrerror(serrno));
	  }
  }

  /* Okay */
  free(stcp_input);
  free(stpp_input);
  if (stcp_output != NULL) free(stcp_output); /* Should not be */
  exit(0);
}

void cleanup(sig)
	int sig;
{
	int i;

	/* Say to stager daemon we have been interrupted - the eventual */
	/* I/O process will then be signalled on the hostname where is */
	/* running the dameon */
	stage_kill(sig);
	/* Avoid unnecessary messaged from the stage_clr_Link */
	cleanup_mode = 1;
	/* Let's be kind and remove the links */
	/* Stager will otherwise remind them for a long time */
	for (i = 0; i < nstpp_input; i++) {
		stage_clr_Link((u_signed64) 0, NULL, stpp_input[i].upath);
	}
	exit(EXIT_FAILURE);
}

void log_callback(level,message)
	int level;
	char *message;
{
	if (cleanup_mode) return;

	if (level == MSG_ERR) {
		fprintf(stderr,"MSG_ERR ==> %s",message);
	} else {
		fprintf(stdout,"MSG_OUT ==> %s",message);
		fflush(stdout);
	}
}

void record_callback(stcp,stpp)
	struct stgcat_entry *stcp;
	struct stgpath_entry *stpp;
{
	/* Let's print a dump of the structures */
	if (stcp != NULL) print_stcp(stcp);
	if (stpp != NULL) print_stpp(stpp);
}
\s+2
.ft
.LP
.fi
A first pass would produce:
.ft CW
.nf
.sp
\s-2
[] ~ > a.out /tmp/shift.conf1 /tmp/shift.conf2
MSG_OUT ==> STG42 - stagein succeeded for file /tmp/shift.conf1, return code 0

-------------------------------------
Catalog entry - dump of reqid 366
-------------------------------------
reqid                   :                  366
blksize                 :                    0
filler                  :                     
charconv                :                    0 (hex) == <?>
keep                    :                     
lrecl                   :                    0
nread                   :                    0
poolname                :            castordev
recfm                   :                     
size                    :              1048576 (bytes)
ipath                   : castordev:/tmp/stage_castordev/c3/stage/shift.conf1.366
t_or_d                  :                    d
group                   :                   c3
user                    :              jdurand
uid                     :                27343
gid                     :                 1028
mask                    :                   22 (oct)
status                  :                   31 (hex) == STAGEIN|STAGED
actual_size             :                  665
c_time                  :           1033981028 (Oct  7 10:57:08)
a_time                  :           1033981028 (Oct  7 10:57:08)
nbaccesses              :                    1
u1.d.xfile              :     /tmp/shift.conf1
u1.d.Xparm              :                     
MSG_OUT ==> 665 bytes in 0 seconds through local (in) and local (out)
MSG_OUT ==> STG42 - stagein succeeded for file /tmp/shift.conf2, return code 0

-------------------------------------
Catalog entry - dump of reqid 367
-------------------------------------
reqid                   :                  367
blksize                 :                    0
filler                  :                     
charconv                :                    0 (hex) == <?>
keep                    :                     
lrecl                   :                    0
nread                   :                    0
poolname                :            castordev
recfm                   :                     
size                    :              1048576 (bytes)
ipath                   : castordev:/tmp/stage_castordev/c3/stage/shift.conf2.367
t_or_d                  :                    d
group                   :                   c3
user                    :              jdurand
uid                     :                27343
gid                     :                 1028
mask                    :                   22 (oct)
status                  :                   31 (hex) == STAGEIN|STAGED
actual_size             :                  665
c_time                  :           1033981028 (Oct  7 10:57:08)
a_time                  :           1033981028 (Oct  7 10:57:08)
nbaccesses              :                    1
u1.d.xfile              :     /tmp/shift.conf2
u1.d.Xparm              :                     
MSG_OUT ==> 665 bytes in 0 seconds through local (in) and local (out)
\s+2
.ft
.LP
.fi
A second pass would produce
.ft CW
.nf
.sp
\s-2
[] ~ > a.out /tmp/shift.conf1 /tmp/shift.conf2
MSG_OUT ==> STG96 - shift.conf1.366 already staged, size = 665 (0.0 MB), nbaccess = 2
-------------------------------------
Catalog entry - dump of reqid 366
-------------------------------------
reqid                   :                  366
blksize                 :                    0
filler                  :                     
charconv                :                    0 (hex) == <?>
keep                    :                     
lrecl                   :                    0
nread                   :                    0
poolname                :            castordev
recfm                   :                     
size                    :              1048576 (bytes)
ipath                   : castordev:/tmp/stage_castordev/c3/stage/shift.conf1.366
t_or_d                  :                    d
group                   :                   c3
user                    :              jdurand
uid                     :                27343
gid                     :                 1028
mask                    :                   22 (oct)
status                  :                   31 (hex) == STAGEIN|STAGED
actual_size             :                  665
c_time                  :           1033981028 (Oct  7 10:57:08)
a_time                  :           1033981166 (Oct  7 10:59:26)
nbaccesses              :                    2
u1.d.xfile              :     /tmp/shift.conf1
u1.d.Xparm              :                     
MSG_OUT ==> STG96 - shift.conf2.367 already staged, size = 665 (0.0 MB), nbaccess = 2
-------------------------------------
Catalog entry - dump of reqid 367
-------------------------------------
reqid                   :                  367
blksize                 :                    0
filler                  :                     
charconv                :                    0 (hex) == <?>
keep                    :                     
lrecl                   :                    0
nread                   :                    0
poolname                :            castordev
recfm                   :                     
size                    :              1048576 (bytes)
ipath                   : castordev:/tmp/stage_castordev/c3/stage/shift.conf2.367
t_or_d                  :                    d
group                   :                   c3
user                    :              jdurand
uid                     :                27343
gid                     :                 1028
mask                    :                   22 (oct)
status                  :                   31 (hex) == STAGEIN|STAGED
actual_size             :                  665
c_time                  :           1033981028 (Oct  7 10:57:08)
a_time                  :           1033981166 (Oct  7 10:59:26)
nbaccesses              :                    2
u1.d.xfile              :     /tmp/shift.conf2
u1.d.Xparm              :                     
\s+2
.ft
.LP
.fi

.SH RETURN VALUE
0 on success, -1 on failure.

.SH ERRORS
If failure, the serrno variable might contain one of the following error codes:
.TP 1.9i
.B SENOMAPFND
Can't open mapping database (Windows only)
.TP
.B EFAULT
Bad address
.TP
.B EINVAL
Invalid argument
.TP
.B ESTGROUP
Invalid group
.TP
.B SECONNDROP
Connection closed by remote end
.TP
.B SECOMERR
Communication error
.TP
.B SEINTERNAL
Internal error
.TP
.B SEUSERUNKN
User unknown
.TP
.B ESTLINKNAME
User link name processing error
.TP
.B SEOPNOTSUP
Operation not supported (should not happen)
.TP
.B ESTMEM
Request too big
.TP
.B ENOENT
No such file or directory
.TP
.B SESYSERR
System error
.TP
.B ESTCLEARED
Request cleared
.TP
.B ESTKILLED
Request killed
.TP
.B ENOSPC
No space left on device
.TP
.B ESTLNKNSUP
Symbolic link not supported
.TP
.B ESTNACT
Stager not active (if you specify the STAGE_NORETRY flag - default is to retry forever)
.TP
.B SENOSHOST
Host not known

.SH NOTES
A poolname other than the default can be specified either with environment variable $STAGE_POOL, or an entry 'STG POOL' in /etc/shift.conf

.SH SEE ALSO
\fBstagein\fP(1), \fBstage_limits\fP(3), \fBCastor_limits\fP(3), \fBstage_setlog\fP(3), \fBstage_setcallback\fP(3), \fBstage_clr_Link\fP(3), \fBrc_castor2shift\fP(3), \fBstage_kill\fP(3), \fBprint_stcp\fP(3), \fBprint_stpp\fP(3), \fBstage_struct\fP(3), \fBstage_macros\fP(3), \fBstage_constants\fP(3)

.SH AUTHOR
\fBCASTOR\fP Team <castor.support@cern.ch>

