.\" $Id: stage_struct.man,v 1.4 2002/09/14 06:19:07 jdurand Exp $
.\"
.\" @(#)$RCSfile: stage_struct.man,v $ $Revision: 1.4 $ $Date: 2002/09/14 06:19:07 $ CERN IT-DS/HSM Jean-Damien Durand
.\" Copyright (C) 2002 by CERN/IT/DS/HSM
.\" All rights reserved
.\"
.TH STAGE_STRUCT "3" "$Date: 2002/09/14 06:19:07 $" "CASTOR" "Stage Library Functions"
.SH NAME
stage structures \- Definition of the stager structures used by daemon and clients
.SH SYNOPSIS
.BI "#include <" stage_api.h ">"
.sp
struct stgcat_entry *stcp;
.br
struct stgpath_entry *stpp;

.SH DESCRIPTION
The \fBstage structures\fP are the the basis of stage information bookkeeping. They are used for everything, storing parameters of incoming requests, update of information, etc...

.SH PARAMETERS
.TP 2.0i
.BI stgcat_entry
is the main structure.
.TP
.BI stgpath_entry
describes user links, and is joined to stgcat_entry structures.

.SH DEFINITION
Below is the definition of
.BI stgcat_entry
structures. Each member of the structure is described below with a keyword that can be TAPE, DISK, CASTOR, HSM or ALL, refering to the type of data it is refering.
.ft CW
.nf
.sp
struct stgcat_entry {
       int	blksize;    /* TAPE   : maximum block size */
       char	filler[2];  /* <none> : Used for padding */
       char	charconv;   /* TAPE   : character conversion */
       char	keep;       /* ALL    : keep data on disk after successful migration */
       int	lrecl;      /* TAPE   : record length */
       int	nread;      /* TAPE   : number of blocks/records to be copied */
       char	poolname[CA_MAXPOOLNAMELEN+1]; /* ALL : pool where is internal path */
       char	recfm[CA_MAXRECFMLEN+1];       /* TAPE: record format */
       u_signed64 size; /* ALL    : size in bytes of data to be staged */
       char	ipath[(CA_MAXHOSTNAMELEN+MAXPATH)+1]; /* ALL: internal path */
       char	t_or_d;		/* ALL    : 't' for tape, 'd' for disk , 'm' for non-CASTOR HSM, 'h' for CASTOR HSM */
       char	group[CA_MAXGRPNAMELEN+1]; /* ALL: group name of owner on disk */
       char	user[CA_MAXUSRNAMELEN+1];  /* ALL: login name of owner on disk */
       uid_t uid;       /* ALL    : owner id */
       gid_t gid;       /* ALL    : group id */
       mode_t mask;     /* ALL    : masked used at creation */
       int reqid;       /* ALL    : request id */
       int status;      /* ALL    : current status */
       u_signed64 actual_size; /* ALL: current size */
       time_t c_time;   /* ALL    : creation time */
       time_t a_time;   /* ALL    : last access time from stage point of view */
       int	nbaccesses; /* ALL    : number of times it was accessed */
       union {
             struct {   /* TAPE   : tape specific information */
                    char den[CA_MAXDENLEN+1];	/* TAPE: density */
                    char dgn[CA_MAXDGNLEN+1];	/* TAPE: device group */
                    char fid[CA_MAXFIDLEN+1];	/* TAPE: file id */
                    char filstat;	            /* TAPE: file status: new = 'n', old = 'o' */
                    char fseq[CA_MAXFSEQLEN+1];	/* TAPE: file sequence number */
                    char lbl[CA_MAXLBLTYPLEN+1];/* TAPE: label type: al, nl, sl, blp or aul */
                    int  retentd;               /* TAPE: retention period in days */
                    int  side;	/* size (for deviced like DVD accessed as if it was a tape request) */
                    char tapesrvr[CA_MAXHOSTNAMELEN+1];	/* TAPE: tape server */
                    char E_Tflags; /* TAPE: SKIPBAD, KEEPFILE, NOTRLCHK */
                    char vid[MAXVSN][CA_MAXVIDLEN+1]; /* TAPE: volume Id */
                    char vsn[MAXVSN][CA_MAXVSNLEN+1]; /* TAPE: volume Serial Number */
                    } t;
             struct { /* DISK     : info for disk file stageing */
                    char xfile[(CA_MAXHOSTNAMELEN+MAXPATH)+1]; /* DISK: external name */
                    char Xparm[23]; /* DISK: rfcp parameters (not used) */
                    } d;
             struct { /* HSM      : non-CASTOR HSM files */
                    char xfile[STAGE_MAX_HSMLENGTH+1]; /* HSM: external name */
                    } m;
             struct { /* CASTOR   : CASTOR HSM files */
                    char xfile[STAGE_MAX_HSMLENGTH+1]; /* CASTOR: external name */
                    char server[CA_MAXHOSTNAMELEN+1];  /* CASTOR: name server */
                    u_signed64 fileid;                 /* CASTOR: unique Id */
                    short fileclass;                   /* CASTOR: file class */
                    char tppool[CA_MAXPOOLNAMELEN+1];  /* CASTOR: tape pool */
                    int  retenp_on_disk;               /* CASTOR: retention period */
                    int  mintime_beforemigr;           /* CASTOR: mintime before migration */
                    short flag;                        /* CASTOR: flags driving migration */
                    } h;
             } u1;
};
.ft
.LP
.fi

The
.BI stgpath_entry
structure is doing a join between stgcat_entry structures and the user links to disk files, using the
.BI reqid
request id.
.ft CW
.nf
.sp
struct stgpath_entry {
       int reqid;                                      /* Request ID, c.f. stgcat_entry */
       char upath[(CA_MAXHOSTNAMELEN+MAXPATH)+1];      /* User path */
};
.ft
.LP
.fi
The stgcat_entry structure is composed of
.sp
.BI blksize
specifies the maximum block size. If not given and the tape is labelled, the block size is taken from the header label when the field is not zero; otherwise: for all drive types except Redwoods the default is 32760 if lrecl is not specified, record length otherwise. On Redwoods, the default is 262144 if the record length is not specified or the largest multiple of record length below 262144.
.sp
.BI filler
is a dummy field, sometimes used internally inside memory, but have no persistent meaning.
.sp
.BI charconv
describes character conversion. Could be a logical or of
.BI ASCCONV
for no conversion, 
.BI EBCCONV
for ebcdic to/from ascii conversion, and
.BI FIXVAR
to change trailing blanks to newlines. Default is 
.BI ASCCONV
(no conversion).
.sp
.BI keep
is a flag telling stager to keep data on disk after a successful migration.
.sp
.BI lrecl
specifies the logical record length for fixed length record format files.
.sp
.BI nread
, if specified, gives the number of records that will be copied to tape.
.sp
.BI poolname
gives the pool name to which belong the internal disk file (c.f. ipath below)
.sp
.BI recfm
specifies the record format of the data on the tape. It can be:
.TP 2.0i
.HP
.BI F " or " FS
is suitable for use with direct access Fortran unformatted I/O or C I/O, 
.TP
.HP
.BI FB " or " FBS
to group several records of lrecl bytes into tape blocks of blksize bytes, 
.TP
.HP
.BI U
that is an alias for U,f77, 
.TP
.HP
.BI U,bin
saying that blocks may be of unknown length (data is transferred as a byte stream. This format is suitable for use with direct access  Fortran unformatted I/O or C I/O), 
.TP
.HP
.BI U,f77
when blocks may be of unknown length (then a single logical record on disk corresponds to one tape block. The disk copy of the file is formatted according to the convention for sequential FORTRAN unformatted I/O),  and
.TP
.HP
.BI F,\-f77
when the tape file is known to be formatted according to the convention for sequential Fortran unformatted I/O (the control words are stripped off so that the disk file is suitable for use with direct access Fortran unformatted I/O or C I/O).
.P
.BI size
specifies how many bytes the owner wanted to limit the recall (all kind of data) or the migration (tape only, CASTOR files are always migrated up to EOF)
.sp
.BI ipath
gives the internal path name
.sp
.BI t_or_d
gives the kind of record the structure is describing, it can be
.TP 2.0i
.HP
.BI t
for tape files, 
.TP
.HP
.BI d
for disk files, 
.TP
.HP
.BI m
for HSM files different than CASTOR
.TP
.HP
.BI h
for CASTOR files
.P
.BI group
gives the group name corresponding to the group id at the time the structure was created
.sp
.BI user
gives the user name
.sp
.BI uid
gives the user id
.sp
.BI gid
gives the group id
.sp
.BI mask
gives the user's mask when file was created on disk
.sp
.BI reqid
is a request id
.sp
.BI status
gives the current status of this entry. It can be a logical or of:
.TP 2.0i
.HP
.BI STAGEIN
original request is a recall
.TP
.HP
.BI STAGEOUT
original request is a creation
.TP
.HP
.BI STAGEWRT " or " STAGEPUT
original request is a migration
.TP
.HP
.BI STAGEALLOC
original request was an allocation on disk
.TP
.HP
.BI WAITING_SPC
request is currently waiting for space (so there should be a garbage collector running)
.TP
.HP
.BI WAITING_REQ
request is waiting on another one
.TP
.HP
.BI STAGED
request has been successfully staged (recall or migration)
.TP
.HP
.BI PUT_FAILED
migration of the file failed
.TP
.HP
.BI STAGED_LSZ
recall of this file succeeded but is declared to be a partial file
.TP
.HP
.BI STAGED_TPE
recall of this (tape) file suceeded but blocks with parity error have been skipped
.TP
.HP
.BI CAN_BE_MIGR
this (castor) file is a candidate for the next migration
.TP
.HP
.BI LAST_TPFILE
this (tape) file is the last on tape
.TP
.HP
.BI BEING_MIGR
this (castor) file is being migrated
.TP
.HP
.BI WAITING_MIGR
this (castor) file is is an intermediate state, usually changed in a very short period to
.I BEING_MIGR
.TP
.HP
.BI WAITING_NS
this (castor) file is waiting on successful creation in the CASTOR Name Server
.TP
.HP
.BI STAGE_RDONLY
this record describes a readonly access to a CASTOR file
.P
.BI actual_size
gives known size on disk last time it was accessed, current size in case of querying about running requests (like 
.I STAGEIN
or
.I STAGEOUT)
.sp
.BI c_time
gives the creation time from stage point of view (using clock on the host where is running the stager daemon)
.sp
.BI a_time
gives the last known access time from stage point of view (using clock on the host where is running the stager daemon)
.sp
.BI nbaccess
gives the known number of accessses from stage point of view
.sp
.BI u1.t
desbribes a tape oriented structure, composed of:
.TP 2.0i
.HP
.BI den
tape density, for example 200GC for 9940B tapes
.TP
.HP
.BI dgn
tape device group.
.TP
.HP
.BI fid
fileid in HDR1
.TP
.HP
.BI filstat
can be 'n' or 'o'. Implies non-empty 
.I fid
field. for 
.I 'n'
, the existing fileid is not checked but if the new file would overwrite an existing one, the old file expiry date is checked. For 
.I 'o'
, the existing fileid is checked.
.TP
.HP
.BI fseq
is the file sequence list corresponding the copy on disk. Default is 1. Multiple files may be specified using the following syntax:
.RS
.BI f1\-f2
for files f1 to f2 inclusive
.br
.BI f1\-
for files f1 to the last file on the tape
.br
.BI f1\-f2,f4,f6\-
for a non-consecutive ranges of files
.br
.BI u
for positioning by fileid
.RE
.TP
.HP
.BI lbl
gives the label type. This can be 
.I al
for ANSI label,
.I blp
to bypass label,
.I nl
for unlabelled tape,
.I sl
for standard IBM label, or 
.I aul
for ANSI user label
.TP
.HP
.BI retentd
gives the retention period on tape, in day
.TP
.HP
.BI side
gives the side in case multi-side media
.TP
.HP
.BI tapesrvr
forces use of a tape server 
.TP
.HP
.BI E_Tflags
is be a logical or of:
.RS
.BI SKIPBAD
to skip bad blocks
.br
.BI KEEPFILE
to keep file in case of error
.br
.BI IGNOREEOI
to not take two consecutive TMs as EOI
.br
.BI NOTRLCHK
to not check trailer labels
.RE
.TP
.HP
.BI vid
is an array specifying the tape VID if different from the VSN. In the case of multi-volume files a series of vids may be given, up to a maximum of MAXVSN
.TP
.HP
.BI vsn
is an array specifying the volume serial number of the tape. In the case of a multi-volume file a series of vsns may be given, up to MAXVSN. When 
.I vid
and 
.I vsn
are both used, each vsn must be matched by a vid at the same indice
.P
.BI u1.d
is for a disk oriented structure
.TP 2.0i
.HP
.BI xfile
is the name of the external disk file
.TP
.HP
.BI Xparm
gives additional parameters for the copy of the disk file
.P
.BI u1.m
is for HSM files not from CASTOR.
.TP 2.0i
.HP
.BI xfile
is the name of the HSM file
.P
.BI u1.h
is for CASTOR files
.TP 2.0i
.HP
.BI xfile
is the name of the CASTOR file
.TP
.HP
.BI server
is the CASTOR nameserver (could be an alias). This machine will be contacted for any operation done on
.BI xfile
.TP
.HP
.BI fileid
is the CASTOR invariant associated with
.BI xfile
on nameserver
.BI server
.TP
.HP
.BI fileclass
is the file class of
.BI xfile
.TP
.HP
.BI tppool
is the tape pool on which 
.BI xfile
will be migrated, in case of creatino or update of it
.TP
.HP
.BI retenp_on_disk
is either \-1 or a positive number, so that retention period on disk of
.BI xfile
is the default taken from fileclass or a given number of seconds, respectively
.TP
.HP
.BI mintime_beforemigr
is the minimum number of seconds to wait until file is migrated, \-1 for the default from fileclass, or a positive number.

.SH NOTES
.BI u1
is an union. So modification in structure 
.BI t
for example, implies modification of other structure as well.
.sp
The field
.BI t_or_d
is used to know which kind of structure to access within 
.BI u1
union.
.sp
.BI u1.m
and
.BI u1.d
structures needs the 
.BI rfcp
command to be installed.
.sp
.BI u1.m
structure needs the 
.BI rfcp
command to support HSM files not of the CASTOR type.
.sp
Using more than one entry in the
.I vid
or
.I vsn
arrays is meaningul only for volume spanning

.SH LIMITS
Because catalog is maintained in memory (the disk version is used only for the creation/updates/deletions), stage impose lower limit on strings, in particular:
.BI STAGE_MAX_HSMLENGTH
and
.BI MAXPATH
, c.f. \fBstage_limits\fP(3) man page.
.sp

.SH SEE ALSO
\fBCastor_limits\fP(3), \fBstage_macros\fP(3), \fBrfcp\fP(1)

.SH AUTHOR
\fBCASTOR\fP Team <castor.support@cern.ch>

