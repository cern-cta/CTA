.\" $Id: stageqry_Hsm.man,v 1.1 2002/09/07 08:00:00 jdurand Exp $
.\"
.\" @(#)$RCSfile: stageqry_Hsm.man,v $ $Revision: 1.1 $ $Date: 2002/09/07 08:00:00 $ CERN IT-DS/HSM Jean-Damien Durand
.\" Copyright (C) 2002 by CERN/IT/DS/HSM
.\" All rights reserved
.\"
.TH STAGEQRY_HSM "3" "$Date: 2002/09/07 08:00:00 $" "CASTOR" "Stage Library Functions"
.SH NAME
stageqry_Hsm \- Query the stager catalog about an HSM file
.SH SYNOPSIS
.BI "#include <" stage_api.h ">"
.sp
.BI "int stageqry_Hsm(u_signed64 " flags ", char *" hostname ", char *" poolname ", char *" filename ", int *" nstcp_output ", struct stgcat_entry **" stcp_output ", int *" nstpp_output ", struct stgpath_entry **" stpp_output ");"

.SH DESCRIPTION
The \fBstageqry_Hsm\fP API method queries the stager catalog for a given HSM 
.I filename.

.SH PARAMETERS
.TP 2.0i
.BI "u_signed64 " flags
Flags that are driving the search in the stager catalog. It can be zero or a bit-wise of the following values:
.TP 2.0i
.I STAGE_DUMP
A dump of the found catalog entries is written to the output.
.TP
.I STAGE_NOREGEXP
The HSM filename in input is not a regular expression. By default it is a regexp.
.TP
.I STAGE_ALL
Search over all entries. Default is to restrict to your group.
.TP
.I STAGE_FILENAME
The full HSM filename of found catalog entries is written to the output
.TP
.I STAGE_LINKNAME
Only the eventual links to found catalog entries in written to the output
.TP
.I STAGE_LONG
Gives more details for each file: the login name, the group name of the user who requested the initial stage operation, the creation and the date of last access.
.TP
.I STAGE_PATHNAME
Gives the internal path for each found catalog entry.
.TP
.I STAGE_SORTED
List of staged files sorted in ascending order of last access time weighted by file size: W = atime \- (86400 * log (size / 1024)). There are six fields per file: date of last access, time of last access, size in Mbytes, number of accesses, internal path and user path.
.TP
.I STAGE_USER
Restricts the query to files that belong to the requestor.
.TP
.I STAGE_EXTENDED
Adds  two  columns  to  the  output:  they give the request id and the internal pathname.
.TP
.I STAGE_CLASS
Gives CASTOR's file classes specifications. Please note  that  the  fileclasses  specifications listed will only be those that were concerned by any file that  was or is beeing migrated. In particular if a given entry is already STAGED when the stager daemon  starts  up  and  no new file, belonging to the same fileclass, appears to be or have been a candidate for migration up to when you run this stageqry_HSm call, such a fileclass will not be listed.
.TP
.I STAGE_RETENP
Gives current retention period on disk. This period will be showed in terms of either maximum timestamp, or generic keywords that are: AS_LONG_AS_POSSIBLE and INFINITE_LIFETIME, or Expired. The CASTOR files lifetime can be changed using the \fBstagechng\fP command. A retention period of INFINITE_LIFETIME guarantees that the corresponding entry will never be purged. A retention period of AS_LONG_AS_POSSIBLE says that the corresponding entry can be purged if there is missing space into internal disks. Another value specifies that the corresponding entry will be automatically removed if local time of the stager daemon exceeds printed value, or will be removed almost immediated if it says Expired.
.TP
.I STAGE_MINTIME
Gives current minimum time before migration. This concerns only entries that are in the CAN_BE_MIGR state.
.TP
.BI "char *" hostname
Gives explicitely the hostname where is the stager daemon. If it NULL, default value apply: either the environment variable STAGE_HOST, an entry 'STG HOST' in /etc/shift.conf file, or the default "stagepublic".
.TP
.BI "char *" poolname
Restrict search to a given poolname. Can be NULL.
.TP
.BI "char *" filename
Gives the explicit filename you want to query for.
.TP
.BI "int *" nstcp_output
Filled with the number of found records.
.TP
.BI "struct  stgcat_entry **" stcp_output
Filled with the address of an array containg the found records. Up to the user to free it if necessary.
.TP
.BI "int *" nstpp_output
Filled with the number of found records.
.TP
.BI "struct  stgpath_entry **" stcp_output
Filled with the address of an array containg the link records. Only if STAGE_LINKNAME is used. Up to the user to free it if necessary.

.SH EXAMPLE
.ft CW
.nf
.sp
#include <stdlib.h>
#include <sys/types.h>
#include <signal.h>
#include <stdio.h>
#include <stage_api.h>
#include <serrno.h>
     
#define YOUR_FILE_NAME "/castor/psi.ch/user/t/toto/file"
#define VERBOSE 0
      
void stcplog _PROTO((int, char *));
void stcpprint _PROTO((struct stgcat_entry *, struct stgpath_entry *));
void stcplog _PROTO((int, char *));

int main(argc,argv)
     int argc;
     char **argv;
{
  int nstcp_output;
  struct stgcat_entry *stcp_output = NULL;
  int rc, i, isstaged = 0;
 
  if (stage_setlog(&stcplog) != 0) {
    fprintf(stderr,"### stage_setlog error (%s)\n", sstrerror(serrno));
    exit(EXIT_FAILURE);
  }
 
  rc = stageqry_Hsm((u_signed64) 0,              /* Flags */
                    NULL,                        /* Hostname */
                    NULL,                        /* Poolname */
                    (argc > 1 ? argv[1] : YOUR_FILE_NAME), /* Nb stcp input */
                    &nstcp_output,               /* Nb stcp output */
                    &stcp_output,                /* Stcp output */
                    NULL,                        /* Nb stpp output */
                    NULL);                       /* Stpp output */
  if (rc != 0) {
    fprintf(stderr,"### stageqry_Hsm error (%s)\n", sstrerror(serrno));
  } else {
    for (i = 0; i < nstcp_output; i++) {
#if VERBOSE
      stcpprint(stcp_output + i, NULL);
#endif
      if ((stcp_output[i].status & 0xF0) == STAGED) isstaged++;
    }
  }
  if (stcp_output != NULL) free (stcp_output);   /* User responsability ! */
  
  fprintf(stdout,"%s : Found %d entr%s with the STAGED status\n",
          (argc > 1 ? argv[1] : YOUR_FILE_NAME),
          isstaged,
          (isstaged > 1) ? "ies" : "y");

  exit(isstaged ? 0 : 1);
}
 
void stcpprint(stcp,stpp)
     struct stgcat_entry *stcp;
     struct stgpath_entry *stpp;
{
  if (stcp != NULL) print_stcp(stcp);
  if (stpp != NULL) print_stpp(stpp);
}
 
void stcplog(level,msg)
     int level;
     char *msg;
{
#if VERBOSE
  fprintf(stdout, "%s", msg);
#endif
}
.ft
.LP
.fi

.SH RETURN VALUE
0 on success, -1 on failure.

.SH ERRORS
If failure, the serrno variable might contain one of the following error codes:
.TP 1.9i
.B SENOMAPFND
Can't open mapping database (Windows only)
.TP
.B EFAULT
Bad address
.TP
.B EINVAL
Invalid argument
.TP
.B ESTGROUP
Invalid group
.TP
.B SECONNDROP
Connection closed by remote end
.TP
.B SECOMERR
Communication error
.TP
.B SEINTERNAL
Internal error
.TP
.B SESYSERR
System error

.SH SEE ALSO
\fBstageqry\fP(1), \fBstage_setlog\fP(3)

.SH AUTHOR
\fBCASTOR\fP Team <castor.support@cern.ch>

