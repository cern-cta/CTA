/*
 * Copyright (C) 1999-2003 by CERN/IT/PDP/DM
 * All rights reserved
 */
 
#ifndef lint
static char sccsid[] = "@(#)$RCSfile: vmgr_oracle_ifce.pc,v $ $Revision: 1.30 $ $Date: 2007/08/07 14:33:49 $ CERN IT-PDP/DM Jean-Philippe Baud";
#endif /* not lint */

#include <errno.h>
#include <string.h>
#include <sys/types.h>
#include <unistd.h>
#include <sqlca.h>
#ifndef USE_ORACLE
#define USE_ORACLE
#endif
#include "serrno.h"
#include "u64subr.h"
#include "vmgr.h"
#include "vmgr_server.h"

/* prototypes */
int vmgrlogit(char *func, char *msg, ...);

static sql_context ctx[VMGR_NBTHREADS];

int vmgr_init_dbpkg()
{
	int i;

	EXEC SQL ENABLE THREADS;
	for (i = 0; i < VMGR_NBTHREADS; i++) {
		EXEC SQL CONTEXT ALLOCATE :ctx[i];
	}
	return (0);
}

EXEC SQL CONTEXT USE :ctx[dbfd->idx];

int vmgr_abort_tr(dbfd)
struct vmgr_dbfd *dbfd;
{
	EXEC SQL ROLLBACK WORK;
	dbfd->tr_started = 0;
	return (0);
}

int vmgr_closedb(dbfd)
struct vmgr_dbfd *dbfd;
{
	EXEC SQL CONTEXT FREE :ctx[dbfd->idx];
	return (0);
}

int vmgr_delete_denmap_entry(dbfd, rec_addr)
struct vmgr_dbfd *dbfd;
vmgr_dbrec_addr *rec_addr;
{
	char func[25];
	char rowid_value[19];
	struct sqlca sqlca;

	strcpy (func, "vmgr_delete_denmap_entry");
	memcpy (rowid_value, rec_addr, sizeof(rowid_value));
	EXEC SQL DELETE FROM vmgr_tape_denmap WHERE ROWID = :rowid_value;
	if (sqlca.sqlcode) {
		vmgrlogit (func, "DELETE error: %.*s\n", sqlca.sqlerrm.sqlerrml,
		    sqlca.sqlerrm.sqlerrmc);
		serrno = SEINTERNAL;
		return (-1);
	}
	return (0);
}

int vmgr_delete_dgnmap_entry(dbfd, rec_addr)
struct vmgr_dbfd *dbfd;
vmgr_dbrec_addr *rec_addr;
{
	char func[25];
	char rowid_value[19];
	struct sqlca sqlca;

	strcpy (func, "vmgr_delete_dgnmap_entry");
	memcpy (rowid_value, rec_addr, sizeof(rowid_value));
	EXEC SQL DELETE FROM vmgr_tape_dgnmap WHERE ROWID = :rowid_value;
	if (sqlca.sqlcode) {
		vmgrlogit (func, "DELETE error: %.*s\n", sqlca.sqlerrm.sqlerrml,
		    sqlca.sqlerrm.sqlerrmc);
		serrno = SEINTERNAL;
		return (-1);
	}
	return (0);
}

int vmgr_delete_library_entry(dbfd, rec_addr)
struct vmgr_dbfd *dbfd;
vmgr_dbrec_addr *rec_addr;
{
	char func[26];
	char rowid_value[19];
	struct sqlca sqlca;

	strcpy (func, "vmgr_delete_library_entry");
	memcpy (rowid_value, rec_addr, sizeof(rowid_value));
	EXEC SQL DELETE FROM vmgr_tape_library WHERE ROWID = :rowid_value;
	if (sqlca.sqlcode) {
		vmgrlogit (func, "DELETE error: %.*s\n", sqlca.sqlerrm.sqlerrml,
		    sqlca.sqlerrm.sqlerrmc);
		serrno = SEINTERNAL;
		return (-1);
	}
	return (0);
}

int vmgr_delete_model_entry(dbfd, rec_addr)
struct vmgr_dbfd *dbfd;
vmgr_dbrec_addr *rec_addr;
{
	char func[24];
	char rowid_value[19];
	struct sqlca sqlca;

	strcpy (func, "vmgr_delete_model_entry");
	memcpy (rowid_value, rec_addr, sizeof(rowid_value));
	EXEC SQL DELETE FROM vmgr_tape_media WHERE ROWID = :rowid_value;
	if (sqlca.sqlcode) {
		vmgrlogit (func, "DELETE error: %.*s\n", sqlca.sqlerrm.sqlerrml,
		    sqlca.sqlerrm.sqlerrmc);
		serrno = SEINTERNAL;
		return (-1);
	}
	return (0);
}

int vmgr_delete_pool_entry(dbfd, rec_addr)
struct vmgr_dbfd *dbfd;
vmgr_dbrec_addr *rec_addr;
{
	char func[23];
	char rowid_value[19];
	struct sqlca sqlca;

	strcpy (func, "vmgr_delete_pool_entry");
	memcpy (rowid_value, rec_addr, sizeof(rowid_value));
	EXEC SQL DELETE FROM vmgr_tape_pool WHERE ROWID = :rowid_value;
	if (sqlca.sqlcode) {
		vmgrlogit (func, "DELETE error: %.*s\n", sqlca.sqlerrm.sqlerrml,
		    sqlca.sqlerrm.sqlerrmc);
		serrno = SEINTERNAL;
		return (-1);
	}
	return (0);
}

int vmgr_delete_side_entry(dbfd, rec_addr)
struct vmgr_dbfd *dbfd;
vmgr_dbrec_addr *rec_addr;
{
	char func[23];
	char rowid_value[19];
	struct sqlca sqlca;

	strcpy (func, "vmgr_delete_side_entry");
	memcpy (rowid_value, rec_addr, sizeof(rowid_value));
	EXEC SQL DELETE FROM vmgr_tape_side WHERE ROWID = :rowid_value;
	if (sqlca.sqlcode) {
		vmgrlogit (func, "DELETE error: %.*s\n", sqlca.sqlerrm.sqlerrml,
		    sqlca.sqlerrm.sqlerrmc);
		serrno = SEINTERNAL;
		return (-1);
	}
	return (0);
}

int vmgr_delete_tag_entry(dbfd, rec_addr)
struct vmgr_dbfd *dbfd;
vmgr_dbrec_addr *rec_addr;
{
	char func[22];
	char rowid_value[19];
	struct sqlca sqlca;

	strcpy (func, "vmgr_delete_tag_entry");
	memcpy (rowid_value, rec_addr, sizeof(rowid_value));
	EXEC SQL DELETE FROM vmgr_tape_tag WHERE ROWID = :rowid_value;
	if (sqlca.sqlcode) {
		vmgrlogit (func, "DELETE error: %.*s\n", sqlca.sqlerrm.sqlerrml,
		    sqlca.sqlerrm.sqlerrmc);
		serrno = SEINTERNAL;
		return (-1);
	}
	return (0);
}

int vmgr_delete_tape_entry(dbfd, rec_addr)
struct vmgr_dbfd *dbfd;
vmgr_dbrec_addr *rec_addr;
{
	char func[23];
	char rowid_value[19];
	struct sqlca sqlca;

	strcpy (func, "vmgr_delete_tape_entry");
	memcpy (rowid_value, rec_addr, sizeof(rowid_value));
	EXEC SQL DELETE FROM vmgr_tape_info WHERE ROWID = :rowid_value;
	if (sqlca.sqlcode) {
		vmgrlogit (func, "DELETE error: %.*s\n", sqlca.sqlerrm.sqlerrml,
		    sqlca.sqlerrm.sqlerrmc);
		serrno = SEINTERNAL;
		return (-1);
	}
	return (0);
}

int vmgr_end_tr(dbfd)
struct vmgr_dbfd *dbfd;
{
	EXEC SQL COMMIT WORK;
	dbfd->tr_started = 0;
	return (0);
}

int vmgr_get_denmap_entry(dbfd, model, media_letter, density, denmap_entry, lock, rec_addr)
struct vmgr_dbfd *dbfd;
char *model;
char *media_letter;
char *density;
struct vmgr_tape_denmap *denmap_entry;
int lock;
vmgr_dbrec_addr *rec_addr;
{
	char func[22];
	char rowid_value[19];
	struct sqlca sqlca;
	EXEC SQL DECLARE denmap_cursor CURSOR FOR
		SELECT
		 MD_MODEL, MD_MEDIA_LETTER, MD_DENSITY, NATIVE_CAPACITY
		FROM vmgr_tape_denmap
		WHERE md_model = :model AND md_media_letter = :media_letter AND
		 md_density = :density;
	EXEC SQL DECLARE denmap_cursor4upd CURSOR FOR
		SELECT ROWID,
		 MD_MODEL, MD_MEDIA_LETTER, MD_DENSITY, NATIVE_CAPACITY
		FROM vmgr_tape_denmap
		WHERE md_model = :model AND md_media_letter = :media_letter AND
		 md_density = :density
		FOR UPDATE;

	strcpy (func, "vmgr_get_denmap_entry");
	if (lock) {
		EXEC SQL OPEN denmap_cursor4upd;
		if (sqlca.sqlcode) {
			vmgrlogit (func, "OPEN CURSOR error: %.*s\n",
			    sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc);
			serrno = SEINTERNAL;
			return (-1);
		}
		EXEC SQL FETCH denmap_cursor4upd INTO
		 :rowid_value,
		 :denmap_entry->md_model, :denmap_entry->md_media_letter,
		 :denmap_entry->md_density, :denmap_entry->native_capacity;
	} else {
		EXEC SQL OPEN denmap_cursor;
		if (sqlca.sqlcode) {
			vmgrlogit (func, "OPEN CURSOR error: %.*s\n",
			    sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc);
			serrno = SEINTERNAL;
			return (-1);
		}
		EXEC SQL FETCH denmap_cursor INTO
		 :denmap_entry->md_model, :denmap_entry->md_media_letter,
		 :denmap_entry->md_density, :denmap_entry->native_capacity;
	}
	switch (sqlca.sqlcode) {
	case 0:
		if (lock)
			memcpy (rec_addr, rowid_value, sizeof(rowid_value));
		return (0);
	case 1403:
		serrno = ENOENT;
		break;
	default:
		vmgrlogit (func, "FETCH error: %.*s\n", sqlca.sqlerrm.sqlerrml,
		    sqlca.sqlerrm.sqlerrmc);
		serrno = SEINTERNAL;
	}
	return (-1);
}

int vmgr_get_dgnmap_entry(dbfd, model, library, dgnmap_entry, lock, rec_addr)
struct vmgr_dbfd *dbfd;
char *model;
char *library;
struct vmgr_tape_dgnmap *dgnmap_entry;
int lock;
vmgr_dbrec_addr *rec_addr;
{
	char func[22];
	char rowid_value[19];
	struct sqlca sqlca;
	EXEC SQL DECLARE dgnmap_cursor CURSOR FOR
		SELECT
		 DGN, MODEL, LIBRARY
		FROM vmgr_tape_dgnmap
		WHERE model = :model AND library = :library;
	EXEC SQL DECLARE dgnmap_cursor4upd CURSOR FOR
		SELECT ROWID,
		 DGN, MODEL, LIBRARY
		FROM vmgr_tape_dgnmap
		WHERE model = :model AND library = :library
		FOR UPDATE;

	strcpy (func, "vmgr_get_dgnmap_entry");
	if (lock) {
		EXEC SQL OPEN dgnmap_cursor4upd;
		if (sqlca.sqlcode) {
			vmgrlogit (func, "OPEN CURSOR error: %.*s\n",
			    sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc);
			serrno = SEINTERNAL;
			return (-1);
		}
		EXEC SQL FETCH dgnmap_cursor4upd INTO
		 :rowid_value,
		 :dgnmap_entry->dgn, :dgnmap_entry->model,
		 :dgnmap_entry->library;
	} else {
		EXEC SQL OPEN dgnmap_cursor;
		if (sqlca.sqlcode) {
			vmgrlogit (func, "OPEN CURSOR error: %.*s\n",
			    sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc);
			serrno = SEINTERNAL;
			return (-1);
		}
		EXEC SQL FETCH dgnmap_cursor INTO
		 :dgnmap_entry->dgn, :dgnmap_entry->model,
		 :dgnmap_entry->library;
	}
	switch (sqlca.sqlcode) {
	case 0:
		if (lock)
			memcpy (rec_addr, rowid_value, sizeof(rowid_value));
		return (0);
	case 1403:
		serrno = ENOENT;
		break;
	default:
		vmgrlogit (func, "FETCH error: %.*s\n", sqlca.sqlerrm.sqlerrml,
		    sqlca.sqlerrm.sqlerrmc);
		serrno = SEINTERNAL;
	}
	return (-1);
}

int vmgr_get_library_entry(dbfd, library_name, library_entry, lock, rec_addr)
struct vmgr_dbfd *dbfd;
char *library_name;
struct vmgr_tape_library *library_entry;
int lock;
vmgr_dbrec_addr *rec_addr;
{
	char func[23];
	char rowid_value[19];
	struct sqlca sqlca;
	EXEC SQL DECLARE library_cursor CURSOR FOR
		SELECT
		 NAME, CAPACITY,
		 NB_FREE_SLOTS, STATUS
		FROM vmgr_tape_library
		WHERE name = :library_name;
	EXEC SQL DECLARE library_cursor4upd CURSOR FOR
		SELECT ROWID,
		 NAME, CAPACITY,
		 NB_FREE_SLOTS, STATUS
		FROM vmgr_tape_library
		WHERE name = :library_name
		FOR UPDATE;

	strcpy (func, "vmgr_get_library_entry");
	if (lock) {
		EXEC SQL OPEN library_cursor4upd;
		if (sqlca.sqlcode) {
			vmgrlogit (func, "OPEN CURSOR error: %.*s\n",
			    sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc);
			serrno = SEINTERNAL;
			return (-1);
		}
		EXEC SQL FETCH library_cursor4upd INTO
		 :rowid_value,
		 :library_entry->name, :library_entry->capacity,
		 :library_entry->nb_free_slots, :library_entry->status;
	} else {
		EXEC SQL OPEN library_cursor;
		if (sqlca.sqlcode) {
			vmgrlogit (func, "OPEN CURSOR error: %.*s\n",
			    sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc);
			serrno = SEINTERNAL;
			return (-1);
		}
		EXEC SQL FETCH library_cursor INTO
		 :library_entry->name, :library_entry->capacity,
		 :library_entry->nb_free_slots, :library_entry->status;
	}
	switch (sqlca.sqlcode) {
	case 0:
		if (lock)
			memcpy (rec_addr, rowid_value, sizeof(rowid_value));
		return (0);
	case 1403:
		serrno = ENOENT;
		break;
	default:
		vmgrlogit (func, "FETCH error: %.*s\n", sqlca.sqlerrm.sqlerrml,
		    sqlca.sqlerrm.sqlerrmc);
		serrno = SEINTERNAL;
	}
	return (-1);
}

int vmgr_get_model_entry(dbfd, model, model_entry, lock, rec_addr)
struct vmgr_dbfd *dbfd;
char *model;
struct vmgr_tape_media *model_entry;
int lock;
vmgr_dbrec_addr *rec_addr;
{
	char func[21];
	char rowid_value[19];
	struct sqlca sqlca;
	EXEC SQL DECLARE model_cursor CURSOR FOR
		SELECT
		 M_MODEL, M_MEDIA_LETTER,
		 MEDIA_COST
		FROM vmgr_tape_media
		WHERE m_model = :model;
	EXEC SQL DECLARE model_cursor4upd CURSOR FOR
		SELECT ROWID,
		 M_MODEL, M_MEDIA_LETTER,
		 MEDIA_COST
		FROM vmgr_tape_media
		WHERE m_model = :model
		FOR UPDATE;

	strcpy (func, "vmgr_get_model_entry");
	if (lock) {
		EXEC SQL OPEN model_cursor4upd;
		if (sqlca.sqlcode) {
			vmgrlogit (func, "OPEN CURSOR error: %.*s\n",
			    sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc);
			serrno = SEINTERNAL;
			return (-1);
		}
		EXEC SQL FETCH model_cursor4upd INTO
		 :rowid_value,
		 :model_entry->m_model, :model_entry->m_media_letter,
		 :model_entry->media_cost;
	} else {
		EXEC SQL OPEN model_cursor;
		if (sqlca.sqlcode) {
			vmgrlogit (func, "OPEN CURSOR error: %.*s\n",
			    sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc);
			serrno = SEINTERNAL;
			return (-1);
		}
		EXEC SQL FETCH model_cursor INTO
		 :model_entry->m_model, :model_entry->m_media_letter,
		 :model_entry->media_cost;
	}
	switch (sqlca.sqlcode) {
	case 0:
		if (lock)
			memcpy (rec_addr, rowid_value, sizeof(rowid_value));
		return (0);
	case 1403:
		serrno = ENOENT;
		break;
	default:
		vmgrlogit (func, "FETCH error: %.*s\n", sqlca.sqlerrm.sqlerrml,
		    sqlca.sqlerrm.sqlerrmc);
		serrno = SEINTERNAL;
	}
	return (-1);
}

int vmgr_get_pool_entry(dbfd, pool_name, pool_entry, lock, rec_addr)
struct vmgr_dbfd *dbfd;
char *pool_name;
struct vmgr_tape_pool *pool_entry;
int lock;
vmgr_dbrec_addr *rec_addr;
{
	char capacity_str[21];
	char func[20];
	char rowid_value[19];
	struct sqlca sqlca;
	char tot_free_space_str[21];
	EXEC SQL DECLARE pool_cursor CURSOR FOR
		SELECT
		 NAME, OWNER_UID, GID, TO_CHAR(CAPACITY), TO_CHAR(TOT_FREE_SPACE)
		FROM vmgr_tape_pool
		WHERE name = :pool_name;
	EXEC SQL DECLARE pool_cursor4upd CURSOR FOR
		SELECT ROWID,
		 NAME, OWNER_UID, GID, TO_CHAR(CAPACITY), TO_CHAR(TOT_FREE_SPACE)
		FROM vmgr_tape_pool
		WHERE name = :pool_name
		FOR UPDATE;

	strcpy (func, "vmgr_get_pool_entry");
	if (lock) {
		EXEC SQL OPEN pool_cursor4upd;
		if (sqlca.sqlcode) {
			vmgrlogit (func, "OPEN CURSOR error: %.*s\n",
			    sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc);
			serrno = SEINTERNAL;
			return (-1);
		}
		EXEC SQL FETCH pool_cursor4upd INTO
		 :rowid_value,
		 :pool_entry->name, :pool_entry->uid, :pool_entry->gid,
		 :capacity_str, :tot_free_space_str;
	} else {
		EXEC SQL OPEN pool_cursor;
		if (sqlca.sqlcode) {
			vmgrlogit (func, "OPEN CURSOR error: %.*s\n",
			    sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc);
			serrno = SEINTERNAL;
			return (-1);
		}
		EXEC SQL FETCH pool_cursor INTO
		 :pool_entry->name, :pool_entry->uid, :pool_entry->gid,
		 :capacity_str, :tot_free_space_str;
	}
	switch (sqlca.sqlcode) {
	case 0:
		if (lock)
			memcpy (rec_addr, rowid_value, sizeof(rowid_value));
		pool_entry->capacity = strtou64 (capacity_str);
		pool_entry->tot_free_space = strtou64 (tot_free_space_str);
		return (0);
	case 1403:
		serrno = ENOENT;
		break;
	default:
		vmgrlogit (func, "FETCH error: %.*s\n", sqlca.sqlerrm.sqlerrml,
		    sqlca.sqlerrm.sqlerrmc);
		serrno = SEINTERNAL;
	}
	return (-1);
}

int vmgr_get_side_by_fullid (dbfd, vid, side, side_entry, lock, rec_addr)
struct vmgr_dbfd *dbfd;
char *vid;
int side;
struct vmgr_tape_side *side_entry;
int lock;
vmgr_dbrec_addr *rec_addr;
{
	char func[24];
	char rowid_value[19];
	struct sqlca sqlca;
	EXEC SQL DECLARE side_fullid_cursor CURSOR FOR
		SELECT
		 VID, SIDE, POOLNAME, STATUS, ESTIMATED_FREE_SPACE, NBFILES
		FROM vmgr_tape_side
		WHERE vid = :vid AND side = :side;
	EXEC SQL DECLARE side_fullid_cursor4upd CURSOR FOR
		SELECT ROWID,
		 VID, SIDE, POOLNAME, STATUS, ESTIMATED_FREE_SPACE, NBFILES
		FROM vmgr_tape_side
		WHERE vid = :vid AND side = :side
		FOR UPDATE;

	strcpy (func, "vmgr_get_side_by_fullid");
	if (lock) {
		EXEC SQL OPEN side_fullid_cursor4upd;
		if (sqlca.sqlcode) {
			vmgrlogit (func, "OPEN CURSOR error: %.*s\n",
			    sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc);
			serrno = SEINTERNAL;
			return (-1);
		}
		EXEC SQL FETCH side_fullid_cursor4upd INTO
		 :rowid_value,
		 :side_entry->vid, :side_entry->side, :side_entry->poolname,
		 :side_entry->status, :side_entry->estimated_free_space,
		 :side_entry->nbfiles;
	} else {
		EXEC SQL OPEN side_fullid_cursor;
		if (sqlca.sqlcode) {
			vmgrlogit (func, "OPEN CURSOR error: %.*s\n",
			    sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc);
			serrno = SEINTERNAL;
			return (-1);
		}
		EXEC SQL FETCH side_fullid_cursor INTO
		 :side_entry->vid, :side_entry->side, :side_entry->poolname,
		 :side_entry->status, :side_entry->estimated_free_space,
		 :side_entry->nbfiles;
	}
	switch (sqlca.sqlcode) {
	case 0:
		if (lock)
			memcpy (rec_addr, rowid_value, sizeof(rowid_value));
		return (0);
	case 1403:
		serrno = ENOENT;
		break;
	default:
		vmgrlogit (func, "FETCH error: %.*s\n", sqlca.sqlerrm.sqlerrml,
		    sqlca.sqlerrm.sqlerrmc);
		serrno = SEINTERNAL;
	}
	return (-1);
}

int vmgr_get_tag_by_vid(dbfd, vid, tag_entry, lock, rec_addr)
struct vmgr_dbfd *dbfd;
char *vid;
struct vmgr_tape_tag *tag_entry;
int lock;
vmgr_dbrec_addr *rec_addr;
{
	char func[20];
	char rowid_value[20];
	struct sqlca sqlca;
	EXEC SQL DECLARE tag_cursor CURSOR FOR
		SELECT
		 VID, TEXT
		FROM vmgr_tape_tag
		WHERE vid = :vid;
	EXEC SQL DECLARE tag_cursor4upd CURSOR FOR
		SELECT ROWID,
		 VID, TEXT
		FROM vmgr_tape_tag
		WHERE vid = :vid
		FOR UPDATE;

	strcpy (func, "vmgr_get_tag_by_vid");
	if (lock) {
		EXEC SQL OPEN tag_cursor4upd;
		if (sqlca.sqlcode) {
			vmgrlogit (func, "OPEN CURSOR error: %.*s\n",
			    sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc);
			serrno = SEINTERNAL;
			return (-1);
		}
		EXEC SQL FETCH tag_cursor4upd INTO
		 :rowid_value,
		 :tag_entry->vid, :tag_entry->text;
	} else {
		EXEC SQL OPEN tag_cursor;
		if (sqlca.sqlcode) {
			vmgrlogit (func, "OPEN CURSOR error: %.*s\n",
			    sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc);
			serrno = SEINTERNAL;
			return (-1);
		}
		EXEC SQL FETCH tag_cursor INTO
		 :tag_entry->vid, :tag_entry->text;
	}
	switch (sqlca.sqlcode) {
	case 0:
		if (lock)
			memcpy (rec_addr, rowid_value, sizeof(rowid_value));
		return (0);
	case 1403:
		serrno = ENOENT;
		break;
	default:
		vmgrlogit (func, "FETCH error: %.*s\n", sqlca.sqlerrm.sqlerrml,
		    sqlca.sqlerrm.sqlerrmc);
		serrno = SEINTERNAL;
	}
	return (-1);
}

int vmgr_get_tape_by_vid(dbfd, vid, tape_entry, lock, rec_addr)
struct vmgr_dbfd *dbfd;
char *vid;
struct vmgr_tape_info *tape_entry;
int lock;
vmgr_dbrec_addr *rec_addr;
{
	char func[21];
	short mf_ind;	/* indicator variable for manufacturer column */
	char rowid_value[19];
	short sn_ind;	/* indicator variable for sn column */
	struct sqlca sqlca;
	EXEC SQL DECLARE tape_vid_cursor CURSOR FOR
		SELECT
		 VID, VSN, LIBRARY, DENSITY, LBLTYPE, MODEL, MEDIA_LETTER,
		 MANUFACTURER, SN, NBSIDES, ETIME, RCOUNT, WCOUNT, RHOST, WHOST,
		 RJID, WJID, RTIME, WTIME
		FROM vmgr_tape_info
		WHERE vid = :vid;
	EXEC SQL DECLARE tape_vid_cursor4upd CURSOR FOR
		SELECT ROWID,
		 VID, VSN, LIBRARY, DENSITY, LBLTYPE, MODEL, MEDIA_LETTER,
		 MANUFACTURER, SN, NBSIDES, ETIME, RCOUNT, WCOUNT, RHOST, WHOST,
		 RJID, WJID, RTIME, WTIME
		FROM vmgr_tape_info
		WHERE vid = :vid
		FOR UPDATE;

	strcpy (func, "vmgr_get_tape_by_vid");
	if (lock) {
		EXEC SQL OPEN tape_vid_cursor4upd;
		if (sqlca.sqlcode) {
			vmgrlogit (func, "OPEN CURSOR error: %.*s\n",
			    sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc);
			serrno = SEINTERNAL;
			return (-1);
		}
		EXEC SQL FETCH tape_vid_cursor4upd INTO
		 :rowid_value,
		 :tape_entry->vid, :tape_entry->vsn, :tape_entry->library,
		 :tape_entry->density, :tape_entry->lbltype, :tape_entry->model,
		 :tape_entry->media_letter, :tape_entry->manufacturer:mf_ind,
		 :tape_entry->sn:sn_ind, :tape_entry->nbsides, :tape_entry->etime,
		 :tape_entry->rcount, :tape_entry->wcount, :tape_entry->rhost,
		 :tape_entry->whost, :tape_entry->rjid, :tape_entry->wjid,
		 :tape_entry->rtime, :tape_entry->wtime;
	} else {
		EXEC SQL OPEN tape_vid_cursor;
		if (sqlca.sqlcode) {
			vmgrlogit (func, "OPEN CURSOR error: %.*s\n",
			    sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc);
			serrno = SEINTERNAL;
			return (-1);
		}
		EXEC SQL FETCH tape_vid_cursor INTO
		 :tape_entry->vid, :tape_entry->vsn, :tape_entry->library,
		 :tape_entry->density, :tape_entry->lbltype, :tape_entry->model,
		 :tape_entry->media_letter, :tape_entry->manufacturer:mf_ind,
		 :tape_entry->sn:sn_ind, :tape_entry->nbsides, :tape_entry->etime,
		 :tape_entry->rcount, :tape_entry->wcount, :tape_entry->rhost,
		 :tape_entry->whost, :tape_entry->rjid, :tape_entry->wjid,
		 :tape_entry->rtime, :tape_entry->wtime;
	}
	switch (sqlca.sqlcode) {
	case 0:
		if (lock)
			memcpy (rec_addr, rowid_value, sizeof(rowid_value));
		return (0);
	case 1403:
		serrno = ENOENT;
		break;
	default:
		vmgrlogit (func, "FETCH error: %.*s\n", sqlca.sqlerrm.sqlerrml,
		    sqlca.sqlerrm.sqlerrmc);
		serrno = SEINTERNAL;
	}
	return (-1);
}

int vmgr_get_side_by_size(dbfd, poolname, Size, side_entry, lock, rec_addr)
struct vmgr_dbfd *dbfd;
char *poolname;
u_signed64 Size;
struct vmgr_tape_side *side_entry;
int lock;
vmgr_dbrec_addr *rec_addr;
{
	char func[22];
	int reqsize = (Size + 1023) / 1024;
	char rowid_value[19];
	struct sqlca sqlca;
	EXEC SQL DECLARE tape_size_cursor4upd CURSOR FOR
		SELECT ROWID,
		 vid, side, poolname, status, estimated_free_space, nbfiles
		FROM vmgr_tape_side
		WHERE vid = (
                  SELECT vid FROM (
                    SELECT vid
		    FROM vmgr_tape_side
		    WHERE estimated_free_space =
                          (SELECT min(estimated_free_space)
			     FROM vmgr_tape_side
			    WHERE poolname = :poolname
			      AND status = 0 
			      AND estimated_free_space >= :reqsize)
		    AND poolname = :poolname
		    AND status = 0
		    ORDER BY DBMS_RANDOM.VALUE
                  ) WHERE ROWNUM < 2
                ) FOR UPDATE;
	EXEC SQL DECLARE tape_maxsize_cursor4upd CURSOR FOR
		SELECT ROWID,
		 vid, side, poolname, status, estimated_free_space, nbfiles
		FROM vmgr_tape_side
		WHERE vid = (
                  SELECT vid FROM (
                    SELECT vid
		    FROM vmgr_tape_side
		    WHERE estimated_free_space =
                          (SELECT max(estimated_free_space)
			     FROM vmgr_tape_side
			    WHERE poolname = :poolname
			      AND status = 0)
		    AND poolname = :poolname
		    AND status = 0
		    ORDER BY DBMS_RANDOM.VALUE
                  ) WHERE ROWNUM < 2
                ) FOR UPDATE;

	strcpy (func, "vmgr_get_tape_by_size");
	EXEC SQL OPEN tape_size_cursor4upd;
	if (sqlca.sqlcode) {
		vmgrlogit (func, "OPEN CURSOR error: %.*s\n",
		    sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc);
		serrno = SEINTERNAL;
		return (-1);
	}
	EXEC SQL FETCH tape_size_cursor4upd INTO
	 :rowid_value,
	 :side_entry->vid, :side_entry->side, :side_entry->poolname,
	 :side_entry->status, :side_entry->estimated_free_space,
	 :side_entry->nbfiles;
	if (sqlca.sqlcode == 1403) {
		EXEC SQL OPEN tape_maxsize_cursor4upd;
		if (sqlca.sqlcode) {
			vmgrlogit (func, "OPEN CURSOR error: %.*s\n",
			    sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc);
			serrno = SEINTERNAL;
			return (-1);
		}
		EXEC SQL FETCH tape_maxsize_cursor4upd INTO
		 :rowid_value,
		 :side_entry->vid, :side_entry->side, :side_entry->poolname,
		 :side_entry->status, :side_entry->estimated_free_space,
		 :side_entry->nbfiles;
	}
	switch (sqlca.sqlcode) {
	case 0:
		if (lock)
			memcpy (rec_addr, rowid_value, sizeof(rowid_value));
		return (0);
	case 1403:
		serrno = ENOENT;
		break;
	default:
		vmgrlogit (func, "FETCH error: %.*s\n", sqlca.sqlerrm.sqlerrml,
		    sqlca.sqlerrm.sqlerrmc);
		serrno = SEINTERNAL;
	}
	return (-1);
}

int vmgr_insert_denmap_entry(dbfd, denmap_entry)
struct vmgr_dbfd *dbfd;
struct vmgr_tape_denmap *denmap_entry;
{
	char func[25];
	struct sqlca sqlca;

	strcpy (func, "vmgr_insert_denmap_entry");
	EXEC SQL INSERT INTO vmgr_tape_denmap
		(MD_MODEL, MD_MEDIA_LETTER, MD_DENSITY, NATIVE_CAPACITY)
		VALUES
		(:denmap_entry->md_model, :denmap_entry->md_media_letter,
		 :denmap_entry->md_density, :denmap_entry->native_capacity);
	switch (sqlca.sqlcode) {
	case 0:
		return (0);
	case -1:
		serrno = EEXIST;
		break;
	case -1631:
	case -1632:
	case -1654:
		serrno = ENOSPC;
		break;
	default:
		vmgrlogit (func, "INSERT error: %.*s\n", sqlca.sqlerrm.sqlerrml,
		    sqlca.sqlerrm.sqlerrmc);
		serrno = SEINTERNAL;
	}
	return (-1);
}

int vmgr_insert_dgnmap_entry(dbfd, dgnmap_entry)
struct vmgr_dbfd *dbfd;
struct vmgr_tape_dgnmap *dgnmap_entry;
{
	char func[25];
	struct sqlca sqlca;

	strcpy (func, "vmgr_insert_dgnmap_entry");
	EXEC SQL INSERT INTO vmgr_tape_dgnmap
		(DGN, MODEL, LIBRARY)
		VALUES
		(:dgnmap_entry->dgn, :dgnmap_entry->model,
		 :dgnmap_entry->library);
	switch (sqlca.sqlcode) {
	case 0:
		return (0);
	case -1:
		serrno = EEXIST;
		break;
	case -1631:
	case -1632:
	case -1654:
		serrno = ENOSPC;
		break;
	default:
		vmgrlogit (func, "INSERT error: %.*s\n", sqlca.sqlerrm.sqlerrml,
		    sqlca.sqlerrm.sqlerrmc);
		serrno = SEINTERNAL;
	}
	return (-1);
}

int vmgr_insert_library_entry(dbfd, library_entry)
struct vmgr_dbfd *dbfd;
struct vmgr_tape_library *library_entry;
{
	char func[26];
	struct sqlca sqlca;

	strcpy (func, "vmgr_insert_library_entry");
	EXEC SQL INSERT INTO vmgr_tape_library
		(NAME, CAPACITY, NB_FREE_SLOTS, STATUS)
		VALUES
		(:library_entry->name, :library_entry->capacity,
		 :library_entry->nb_free_slots, :library_entry->status);
	switch (sqlca.sqlcode) {
	case 0:
		return (0);
	case -1:
		serrno = EEXIST;
		break;
	case -1631:
	case -1632:
	case -1654:
		serrno = ENOSPC;
		break;
	default:
		vmgrlogit (func, "INSERT error: %.*s\n", sqlca.sqlerrm.sqlerrml,
		    sqlca.sqlerrm.sqlerrmc);
		serrno = SEINTERNAL;
	}
	return (-1);
}

int vmgr_insert_model_entry(dbfd, model_entry)
struct vmgr_dbfd *dbfd;
struct vmgr_tape_media *model_entry;
{
	char func[24];
	struct sqlca sqlca;

	strcpy (func, "vmgr_insert_model_entry");
	EXEC SQL INSERT INTO vmgr_tape_media
		(M_MODEL, M_MEDIA_LETTER, MEDIA_COST)
		VALUES
		(:model_entry->m_model, :model_entry->m_media_letter,
		 :model_entry->media_cost);
	switch (sqlca.sqlcode) {
	case 0:
		return (0);
	case -1:
		serrno = EEXIST;
		break;
	case -1631:
	case -1632:
	case -1654:
		serrno = ENOSPC;
		break;
	default:
		vmgrlogit (func, "INSERT error: %.*s\n", sqlca.sqlerrm.sqlerrml,
		    sqlca.sqlerrm.sqlerrmc);
		serrno = SEINTERNAL;
	}
	return (-1);
}

int vmgr_insert_pool_entry(dbfd, pool_entry)
struct vmgr_dbfd *dbfd;
struct vmgr_tape_pool *pool_entry;
{
	char capacity_str[21];
	char func[23];
	struct sqlca sqlca;
	char tot_free_space_str[21];

	strcpy (func, "vmgr_insert_pool_entry");
	(void) u64tostr (pool_entry->capacity, capacity_str, -1);
	(void) u64tostr (pool_entry->tot_free_space, tot_free_space_str, -1);
	EXEC SQL INSERT INTO vmgr_tape_pool
		(NAME, OWNER_UID, GID, CAPACITY, TOT_FREE_SPACE)
		VALUES
		(:pool_entry->name, :pool_entry->uid, :pool_entry->gid,
		 TO_NUMBER(:capacity_str), TO_NUMBER(:tot_free_space_str));
	switch (sqlca.sqlcode) {
	case 0:
		return (0);
	case -1:
		serrno = EEXIST;
		break;
	case -1631:
	case -1632:
	case -1654:
		serrno = ENOSPC;
		break;
	default:
		vmgrlogit (func, "INSERT error: %.*s\n", sqlca.sqlerrm.sqlerrml,
		    sqlca.sqlerrm.sqlerrmc);
		serrno = SEINTERNAL;
	}
	return (-1);
}

int vmgr_insert_side_entry(dbfd, side_entry)
struct vmgr_dbfd *dbfd;
struct vmgr_tape_side *side_entry;
{
	char func[23];
	struct sqlca sqlca;

	strcpy (func, "vmgr_insert_side_entry");
	EXEC SQL INSERT INTO vmgr_tape_side
		(VID, SIDE, POOLNAME, STATUS, ESTIMATED_FREE_SPACE, NBFILES)
		VALUES
		(:side_entry->vid, :side_entry->side, :side_entry->poolname,
		 :side_entry->status, :side_entry->estimated_free_space,
		 :side_entry->nbfiles);
	switch (sqlca.sqlcode) {
	case 0:
		return (0);
	case -1:
		serrno = EEXIST;
		break;
	case -1631:
	case -1632:
	case -1654:
		serrno = ENOSPC;
		break;
	default:
		vmgrlogit (func, "INSERT error: %.*s\n", sqlca.sqlerrm.sqlerrml,
		    sqlca.sqlerrm.sqlerrmc);
		serrno = SEINTERNAL;
	}
	return (-1);
}

int vmgr_insert_tag_entry(dbfd, tag_entry)
struct vmgr_dbfd *dbfd;
struct vmgr_tape_tag *tag_entry;
{
	char func[22];
	struct sqlca sqlca;

	strcpy (func, "vmgr_insert_tag_entry");
	EXEC SQL INSERT INTO vmgr_tape_tag
		(VID,  TEXT)
		VALUES
		(:tag_entry->vid, :tag_entry->text);
	switch (sqlca.sqlcode) {
	case 0:
		return (0);
	case -1:
		serrno = EEXIST;
		break;
	case -1631:
	case -1632:
	case -1654:
		serrno = ENOSPC;
		break;
	default:
		vmgrlogit (func, "INSERT error: %.*s\n", sqlca.sqlerrm.sqlerrml,
		    sqlca.sqlerrm.sqlerrmc);
		serrno = SEINTERNAL;
	}
	return (-1);
}

int vmgr_insert_tape_entry(dbfd, tape_entry)
struct vmgr_dbfd *dbfd;
struct vmgr_tape_info *tape_entry;
{
	char func[23];
	struct sqlca sqlca;

	strcpy (func, "vmgr_insert_tape_entry");
	EXEC SQL INSERT INTO vmgr_tape_info
		(VID, VSN, LIBRARY, DENSITY, LBLTYPE, MODEL, MEDIA_LETTER,
		 MANUFACTURER, SN, NBSIDES, ETIME, RCOUNT, WCOUNT, RHOST, WHOST,
		 RJID, WJID, RTIME, WTIME)
		VALUES
		(:tape_entry->vid, :tape_entry->vsn, :tape_entry->library,
		 :tape_entry->density, :tape_entry->lbltype, :tape_entry->model,
		 :tape_entry->media_letter, :tape_entry->manufacturer,
		 :tape_entry->sn, :tape_entry->nbsides, :tape_entry->etime,
		 :tape_entry->rcount, :tape_entry->wcount, :tape_entry->rhost,
		 :tape_entry->whost, :tape_entry->rjid, :tape_entry->wjid,
		 :tape_entry->rtime, :tape_entry->wtime);
	switch (sqlca.sqlcode) {
	case 0:
		return (0);
	case -1:
		serrno = EEXIST;
		break;
	case -1631:
	case -1632:
	case -1654:
		serrno = ENOSPC;
		break;
	default:
		vmgrlogit (func, "INSERT error: %.*s\n", sqlca.sqlerrm.sqlerrml,
		    sqlca.sqlerrm.sqlerrmc);
		serrno = SEINTERNAL;
	}
	return (-1);
}

int vmgr_list_denmap_entry(dbfd, bol, denmap_entry, endlist, dblistptr)
struct vmgr_dbfd *dbfd;
int bol;
struct vmgr_tape_denmap *denmap_entry;
int endlist;
DBLISTPTR *dblistptr;
{
	char func[23];
	struct sqlca sqlca;
	EXEC SQL DECLARE list_denmap_cursor CURSOR FOR
		SELECT
		 MD_MODEL, MD_MEDIA_LETTER, MD_DENSITY, NATIVE_CAPACITY
		FROM vmgr_tape_denmap
		ORDER BY md_model, md_media_letter, native_capacity;

	strcpy (func, "vmgr_list_denmap_entry");
	if (endlist)
		return (1);
	if (bol) {
		EXEC SQL OPEN list_denmap_cursor;
		if (sqlca.sqlcode) {
			vmgrlogit (func, "OPEN CURSOR error: %.*s\n",
			    sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc);
			serrno = SEINTERNAL;
			return (-1);
		}
	}
	EXEC SQL FETCH list_denmap_cursor INTO
	 :denmap_entry->md_model, :denmap_entry->md_media_letter,
	 :denmap_entry->md_density, :denmap_entry->native_capacity;
	switch (sqlca.sqlcode) {
	case 0:
		return (0);
	case 1403:
		return (1);
	default:
		vmgrlogit (func, "FETCH error: %.*s\n", sqlca.sqlerrm.sqlerrml,
		    sqlca.sqlerrm.sqlerrmc);
		serrno = SEINTERNAL;
		return (-1);
	}
}

int vmgr_list_dgnmap_entry(dbfd, bol, dgnmap_entry, endlist, dblistptr)
struct vmgr_dbfd *dbfd;
int bol;
struct vmgr_tape_dgnmap *dgnmap_entry;
int endlist;
DBLISTPTR *dblistptr;
{
	char func[23];
	struct sqlca sqlca;
	EXEC SQL DECLARE list_dgnmap_cursor CURSOR FOR
		SELECT
		 DGN, MODEL, LIBRARY
		FROM vmgr_tape_dgnmap
		ORDER BY dgn;

	strcpy (func, "vmgr_list_dgnmap_entry");
	if (endlist)
		return (1);
	if (bol) {
		EXEC SQL OPEN list_dgnmap_cursor;
		if (sqlca.sqlcode) {
			vmgrlogit (func, "OPEN CURSOR error: %.*s\n",
			    sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc);
			serrno = SEINTERNAL;
			return (-1);
		}
	}
	EXEC SQL FETCH list_dgnmap_cursor INTO
	 :dgnmap_entry->dgn, :dgnmap_entry->model,
	 :dgnmap_entry->library;
	switch (sqlca.sqlcode) {
	case 0:
		return (0);
	case 1403:
		return (1);
	default:
		vmgrlogit (func, "FETCH error: %.*s\n", sqlca.sqlerrm.sqlerrml,
		    sqlca.sqlerrm.sqlerrmc);
		serrno = SEINTERNAL;
		return (-1);
	}
}

int vmgr_list_library_entry(dbfd, bol, library_entry, endlist, dblistptr)
struct vmgr_dbfd *dbfd;
int bol;
struct vmgr_tape_library *library_entry;
int endlist;
DBLISTPTR *dblistptr;
{
	char func[24];
	struct sqlca sqlca;
	EXEC SQL DECLARE list_library_cursor CURSOR FOR
		SELECT
		 NAME, CAPACITY, NB_FREE_SLOTS, STATUS
		FROM vmgr_tape_library
		ORDER BY name;

	strcpy (func, "vmgr_list_library_entry");
	if (endlist)
		return (1);
	if (bol) {
		EXEC SQL OPEN list_library_cursor;
		if (sqlca.sqlcode) {
			vmgrlogit (func, "OPEN CURSOR error: %.*s\n",
			    sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc);
			serrno = SEINTERNAL;
			return (-1);
		}
	}
	EXEC SQL FETCH list_library_cursor INTO
	 :library_entry->name, :library_entry->capacity,
	 :library_entry->nb_free_slots, :library_entry->status;
	switch (sqlca.sqlcode) {
	case 0:
		return (0);
	case 1403:
		return (1);
	default:
		vmgrlogit (func, "FETCH error: %.*s\n", sqlca.sqlerrm.sqlerrml,
		    sqlca.sqlerrm.sqlerrmc);
		serrno = SEINTERNAL;
		return (-1);
	}
}

int vmgr_list_model_entry(dbfd, bol, model_entry, endlist, dblistptr)
struct vmgr_dbfd *dbfd;
int bol;
struct vmgr_tape_media *model_entry;
int endlist;
DBLISTPTR *dblistptr;
{
	char func[22];
	struct sqlca sqlca;
	EXEC SQL DECLARE list_model_cursor CURSOR FOR
		SELECT
		 M_MODEL, M_MEDIA_LETTER, MEDIA_COST
		FROM vmgr_tape_media
		ORDER BY m_model, m_media_letter;

	strcpy (func, "vmgr_list_model_entry");
	if (endlist)
		return (1);
	if (bol) {
		EXEC SQL OPEN list_model_cursor;
		if (sqlca.sqlcode) {
			vmgrlogit (func, "OPEN CURSOR error: %.*s\n",
			    sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc);
			serrno = SEINTERNAL;
			return (-1);
		}
	}
	EXEC SQL FETCH list_model_cursor INTO
	 :model_entry->m_model, :model_entry->m_media_letter,
	 :model_entry->media_cost;
	switch (sqlca.sqlcode) {
	case 0:
		return (0);
	case 1403:
		return (1);
	default:
		vmgrlogit (func, "FETCH error: %.*s\n", sqlca.sqlerrm.sqlerrml,
		    sqlca.sqlerrm.sqlerrmc);
		serrno = SEINTERNAL;
		return (-1);
	}
}

int vmgr_list_pool_entry(dbfd, bol, pool_entry, endlist, dblistptr)
struct vmgr_dbfd *dbfd;
int bol;
struct vmgr_tape_pool *pool_entry;
int endlist;
DBLISTPTR *dblistptr;
{
	char capacity_str[21];
	char func[21];
	struct sqlca sqlca;
	char tot_free_space_str[21];
	EXEC SQL DECLARE list_pool_cursor CURSOR FOR
		SELECT
		 NAME, OWNER_UID, GID, TO_CHAR(CAPACITY), TO_CHAR(TOT_FREE_SPACE)
		FROM vmgr_tape_pool
		ORDER BY name;

	strcpy (func, "vmgr_list_pool_entry");
	if (endlist)
		return (1);
	if (bol) {
		EXEC SQL OPEN list_pool_cursor;
		if (sqlca.sqlcode) {
			vmgrlogit (func, "OPEN CURSOR error: %.*s\n",
			    sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc);
			serrno = SEINTERNAL;
			return (-1);
		}
	}
	EXEC SQL FETCH list_pool_cursor INTO
	 :pool_entry->name, :pool_entry->uid, :pool_entry->gid,
	 :capacity_str, :tot_free_space_str;
	switch (sqlca.sqlcode) {
	case 0:
		pool_entry->capacity = strtou64 (capacity_str);
		pool_entry->tot_free_space = strtou64 (tot_free_space_str);
		return (0);
	case 1403:
		return (1);
	default:
		vmgrlogit (func, "FETCH error: %.*s\n", sqlca.sqlerrm.sqlerrml,
		    sqlca.sqlerrm.sqlerrmc);
		serrno = SEINTERNAL;
		return (-1);
	}
}

int vmgr_list_side_entry(dbfd, bol, vid, pool_name, side_entry, endlist, dblistptr)
struct vmgr_dbfd *dbfd;
int bol;
char *vid;
char *pool_name;
struct vmgr_tape_side *side_entry;
int endlist;
DBLISTPTR *dblistptr;
{
	char func[21];
	struct sqlca sqlca;
	EXEC SQL DECLARE list_tape_cursor CURSOR FOR
		SELECT
		 VID, SIDE, POOLNAME, STATUS, ESTIMATED_FREE_SPACE, NBFILES
		FROM vmgr_tape_side
		ORDER BY vid, side;
	EXEC SQL DECLARE list_tape_in_pool_cursor CURSOR FOR
		SELECT
		 VID, SIDE, POOLNAME, STATUS, ESTIMATED_FREE_SPACE, NBFILES
		FROM vmgr_tape_side
		WHERE poolname = :pool_name
		ORDER BY vid, side;
	EXEC SQL DECLARE list_vid_cursor CURSOR FOR
		SELECT
		 VID, SIDE, POOLNAME, STATUS, ESTIMATED_FREE_SPACE, NBFILES
		FROM vmgr_tape_side
		WHERE vid = :vid
		ORDER BY side;

	strcpy (func, "vmgr_list_side_entry");
	if (endlist)
		return (1);
	if (*vid) {
		if (bol) {
			EXEC SQL OPEN list_vid_cursor;
			if (sqlca.sqlcode) {
				vmgrlogit (func, "OPEN CURSOR error: %.*s\n",
				    sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc);
				serrno = SEINTERNAL;
				return (-1);
			}
		}
		EXEC SQL FETCH list_vid_cursor INTO
		 :side_entry->vid, :side_entry->side, :side_entry->poolname,
		 :side_entry->status, :side_entry->estimated_free_space,
		 :side_entry->nbfiles;
	} else if (*pool_name) {
		if (bol) {
			EXEC SQL OPEN list_tape_in_pool_cursor;
			if (sqlca.sqlcode) {
				vmgrlogit (func, "OPEN CURSOR error: %.*s\n",
				    sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc);
				serrno = SEINTERNAL;
				return (-1);
			}
		}
		EXEC SQL FETCH list_tape_in_pool_cursor INTO
		 :side_entry->vid, :side_entry->side, :side_entry->poolname,
		 :side_entry->status, :side_entry->estimated_free_space,
		 :side_entry->nbfiles;
	} else {
		if (bol) {
			EXEC SQL OPEN list_tape_cursor;
			if (sqlca.sqlcode) {
				vmgrlogit (func, "OPEN CURSOR error: %.*s\n",
				    sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc);
				serrno = SEINTERNAL;
				return (-1);
			}
		}
		EXEC SQL FETCH list_tape_cursor INTO
		 :side_entry->vid, :side_entry->side, :side_entry->poolname,
		 :side_entry->status, :side_entry->estimated_free_space,
		 :side_entry->nbfiles;
	}
	switch (sqlca.sqlcode) {
	case 0:
		return (0);
	case 1403:
		if (*vid && bol) {
			serrno = ENOENT;
			return (-1);
		} else
			return (1);
	default:
		vmgrlogit (func, "FETCH error: %.*s\n", sqlca.sqlerrm.sqlerrml,
		    sqlca.sqlerrm.sqlerrmc);
		serrno = SEINTERNAL;
		return (-1);
	}
}

int vmgr_opendb(db_srvr, db_user, db_pwd, dbfd)
char *db_srvr;
char *db_user;
char *db_pwd;
struct vmgr_dbfd *dbfd;
{
	char func[16];
	int ntries;
	struct sqlca sqlca;

	strcpy (func, "vmgr_opendb");
	ntries = 0;
	while (1) {
		EXEC SQL CONNECT :db_user IDENTIFIED BY :db_pwd USING :db_srvr;
		if (sqlca.sqlcode == 0) return (0);
		if (sqlca.sqlcode != -1014 && sqlca.sqlcode != -1033 &&
		    sqlca.sqlcode != -1034) break;
		if (ntries++ >= MAXRETRY) break;
		sleep (RETRYI);
	}
	vmgrlogit (func, "CONNECT error: %.*s\n", sqlca.sqlerrm.sqlerrml,
	    sqlca.sqlerrm.sqlerrmc);
	serrno = SEINTERNAL;
	return (-1);
}

int vmgr_start_tr(s, dbfd)
int s;
struct vmgr_dbfd *dbfd;
{
	dbfd->tr_started = 1;
	return (0);
}

int vmgr_update_library_entry(dbfd, rec_addr, library_entry)
struct vmgr_dbfd *dbfd;
vmgr_dbrec_addr *rec_addr;
struct vmgr_tape_library *library_entry;
{
	char func[26];
	char rowid_value[19];
	struct sqlca sqlca;

	strcpy (func, "vmgr_update_library_entry");
	memcpy (rowid_value, rec_addr, sizeof(rowid_value));
	EXEC SQL UPDATE vmgr_tape_library SET
		CAPACITY = :library_entry->capacity,
		NB_FREE_SLOTS = :library_entry->nb_free_slots,
		STATUS = :library_entry->status
		WHERE ROWID = :rowid_value;
	if (sqlca.sqlcode) {
		vmgrlogit (func, "UPDATE error: %.*s\n", sqlca.sqlerrm.sqlerrml,
		    sqlca.sqlerrm.sqlerrmc);
		serrno = SEINTERNAL;
		return (-1);
	}
	return (0);
}

int vmgr_update_model_entry(dbfd, rec_addr, model_entry)
struct vmgr_dbfd *dbfd;
vmgr_dbrec_addr *rec_addr;
struct vmgr_tape_media *model_entry;
{
	char func[24];
	char rowid_value[19];
	struct sqlca sqlca;

	strcpy (func, "vmgr_update_model_entry");
	memcpy (rowid_value, rec_addr, sizeof(rowid_value));
	EXEC SQL UPDATE vmgr_tape_media SET
		MEDIA_COST = :model_entry->media_cost
		WHERE ROWID = :rowid_value;
	if (sqlca.sqlcode) {
		vmgrlogit (func, "UPDATE error: %.*s\n", sqlca.sqlerrm.sqlerrml,
		    sqlca.sqlerrm.sqlerrmc);
		serrno = SEINTERNAL;
		return (-1);
	}
	return (0);
}

int vmgr_update_pool_entry(dbfd, rec_addr, pool_entry)
struct vmgr_dbfd *dbfd;
vmgr_dbrec_addr *rec_addr;
struct vmgr_tape_pool *pool_entry;
{
	char capacity_str[21];
	char func[23];
	char rowid_value[19];
	struct sqlca sqlca;
	char tot_free_space_str[21];

	strcpy (func, "vmgr_update_pool_entry");
	memcpy (rowid_value, rec_addr, sizeof(rowid_value));
	(void) u64tostr (pool_entry->capacity, capacity_str, -1);
	(void) u64tostr (pool_entry->tot_free_space, tot_free_space_str, -1);
	EXEC SQL UPDATE vmgr_tape_pool SET
		OWNER_UID = :pool_entry->uid,
		GID = :pool_entry->gid,
		CAPACITY = TO_NUMBER(:capacity_str),
		TOT_FREE_SPACE = TO_NUMBER(:tot_free_space_str)
		WHERE ROWID = :rowid_value;
	if (sqlca.sqlcode) {
		vmgrlogit (func, "UPDATE error: %.*s\n", sqlca.sqlerrm.sqlerrml,
		    sqlca.sqlerrm.sqlerrmc);
		serrno = SEINTERNAL;
		return (-1);
	}
	return (0);
}

int vmgr_update_side_entry(dbfd, rec_addr, side_entry)
struct vmgr_dbfd *dbfd;
vmgr_dbrec_addr *rec_addr;
struct vmgr_tape_side *side_entry;
{
	char func[23];
	char rowid_value[19];
	struct sqlca sqlca;

	strcpy (func, "vmgr_update_side_entry");
	memcpy (rowid_value, rec_addr, sizeof(rowid_value));
	EXEC SQL UPDATE vmgr_tape_side SET
		POOLNAME = :side_entry->poolname,
		STATUS = :side_entry->status,
		ESTIMATED_FREE_SPACE = :side_entry->estimated_free_space,
		NBFILES = :side_entry->nbfiles
		WHERE ROWID = :rowid_value;
	if (sqlca.sqlcode) {
		vmgrlogit (func, "UPDATE error: %.*s\n", sqlca.sqlerrm.sqlerrml,
		    sqlca.sqlerrm.sqlerrmc);
		serrno = SEINTERNAL;
		return (-1);
	}
	return (0);
}

int vmgr_update_tag_entry(dbfd, rec_addr, tag_entry)
struct vmgr_dbfd *dbfd;
vmgr_dbrec_addr *rec_addr;
struct vmgr_tape_tag *tag_entry;
{
	char func[22];
	char rowid_value[19];
	struct sqlca sqlca;

	strcpy (func, "vmgr_update_tag_entry");
	memcpy (rowid_value, rec_addr, sizeof(rowid_value));
	EXEC SQL UPDATE vmgr_tape_tag SET
		TEXT = :tag_entry->text
		WHERE ROWID = :rowid_value;
	if (sqlca.sqlcode) {
		vmgrlogit (func, "UPDATE error: %.*s\n", sqlca.sqlerrm.sqlerrml,
		    sqlca.sqlerrm.sqlerrmc);
		serrno = SEINTERNAL;
		return (-1);
	}
	return (0);
}

int vmgr_update_tape_entry(dbfd, rec_addr, tape_entry)
struct vmgr_dbfd *dbfd;
vmgr_dbrec_addr *rec_addr;
struct vmgr_tape_info *tape_entry;
{
	char func[23];
	char rowid_value[19];
	struct sqlca sqlca;

	strcpy (func, "vmgr_update_tape_entry");
	memcpy (rowid_value, rec_addr, sizeof(rowid_value));
	EXEC SQL UPDATE vmgr_tape_info SET
		VSN = :tape_entry->vsn,
		LIBRARY = :tape_entry->library,
		DENSITY = :tape_entry->density,
		LBLTYPE = :tape_entry->lbltype,
		MODEL = :tape_entry->model,
		MEDIA_LETTER = :tape_entry->media_letter,
		MANUFACTURER = :tape_entry->manufacturer,
		SN = :tape_entry->sn,
		NBSIDES = :tape_entry->nbsides,
		ETIME = :tape_entry->etime,
		RCOUNT = :tape_entry->rcount,
		WCOUNT = :tape_entry->wcount,
		RHOST = :tape_entry->rhost,
		WHOST = :tape_entry->whost,
		RJID = :tape_entry->rjid,
		WJID = :tape_entry->wjid,
		RTIME = :tape_entry->rtime,
		WTIME = :tape_entry->wtime
		WHERE ROWID = :rowid_value;
	if (sqlca.sqlcode) {
		vmgrlogit (func, "UPDATE error: %.*s\n", sqlca.sqlerrm.sqlerrml,
		    sqlca.sqlerrm.sqlerrmc);
		serrno = SEINTERNAL;
		return (-1);
	}
	return (0);
}
