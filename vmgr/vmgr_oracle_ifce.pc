/*
 * Copyright (C) 1999-2003 by CERN/IT/PDP/DM
 * All rights reserved
 */

#include <errno.h>
#include <string.h>
#include <sys/types.h>
#include <unistd.h>
#include <stdio.h>
#include <sqlca.h>
#include <sqlcpr.h>
#include "serrno.h"
#include "u64subr.h"
#include "vmgr.h"
#include "vmgr_server.h"

static sql_context ctx[VMGR_MAXNBTHREADS];
static const char *const VMGRSCHEMAVERSION = "2_1_10_1";

int vmgr_init_dbpkg()
{
  EXEC SQL ENABLE THREADS;
  return (0);
}

static void
vmgr_oracle_error(char *func,
                  char *sql_method,
                  struct vmgr_dbfd *dbfd,
                  struct sqlca *sqlca)
{
  char   err_msg[512];
  size_t err_size = sizeof(err_msg);
  size_t err_len;

  sqlglmt(ctx[dbfd->idx], (unsigned char*)err_msg, &err_size, &err_len);
  if (err_msg[err_len - 1] == '\n') {
    err_msg[err_len - 1] = '\0';
  }

  vmgrlogit("MSG=\"Error: Encountered ORACLE error\" Method=\"%s\" "
            "Function=\"%s\" Error=\"%.*s\"",
            sql_method, func, err_len, err_msg);

  /* Connection to the database was lost ? */
  if (sqlca->sqlcode == -2396  || sqlca->sqlcode == -3113  ||
      sqlca->sqlcode == -28    || sqlca->sqlcode == -3114  ||
      sqlca->sqlcode == -32102 || sqlca->sqlcode == -3135  ||
      sqlca->sqlcode == -12170 || sqlca->sqlcode == -12541 ||
      sqlca->sqlcode == -1012  || sqlca->sqlcode == -1003  ||
      sqlca->sqlcode == -12571 ||
       (sqlca->sqlcode <= -25401 && sqlca->sqlcode >= -25409) ||
      sqlca->sqlcode == -1033  || sqlca->sqlcode == -1089) {
    if (dbfd->connected == 1) {
      vmgr_closedb (dbfd);
    }
  }
  serrno = SEINTERNAL;
}

EXEC SQL CONTEXT USE :ctx[dbfd->idx];

int vmgr_abort_tr(struct vmgr_dbfd *dbfd)
{
  EXEC SQL ROLLBACK WORK;
  dbfd->tr_started = 0;
  return (0);
}

int vmgr_closedb(struct vmgr_dbfd *dbfd)
{
  EXEC SQL ROLLBACK WORK RELEASE;
  EXEC SQL CONTEXT FREE :ctx[dbfd->idx];
  dbfd->connected = 0;
  return (0);
}

int vmgr_delete_denmap_entry(struct vmgr_dbfd *dbfd,
                             vmgr_dbrec_addr *rec_addr)
{
  char func[25];
  char rowid_value[19];
  struct sqlca sqlca;

  strncpy (func, "vmgr_delete_denmap_entry", 25);
  memcpy (rowid_value, rec_addr, sizeof(rowid_value));
  EXEC SQL DELETE FROM vmgr_tape_denmap WHERE ROWID = :rowid_value;
  if (sqlca.sqlcode) {
    vmgr_oracle_error (func, "DELETE", dbfd, &sqlca);
    return (-1);
  }
  return (0);
}

int vmgr_delete_dgnmap_entry(struct vmgr_dbfd *dbfd,
                             vmgr_dbrec_addr *rec_addr)
{
  char func[25];
  char rowid_value[19];
  struct sqlca sqlca;

  strncpy (func, "vmgr_delete_dgnmap_entry", 25);
  memcpy (rowid_value, rec_addr, sizeof(rowid_value));
  EXEC SQL DELETE FROM vmgr_tape_dgnmap WHERE ROWID = :rowid_value;
  if (sqlca.sqlcode) {
    vmgr_oracle_error (func, "DELETE", dbfd, &sqlca);
    return (-1);
  }
  return (0);
}

int vmgr_delete_library_entry(struct vmgr_dbfd *dbfd,
                              vmgr_dbrec_addr *rec_addr)
{
  char func[26];
  char rowid_value[19];
  struct sqlca sqlca;

  strncpy (func, "vmgr_delete_library_entry", 26);
  memcpy (rowid_value, rec_addr, sizeof(rowid_value));
  EXEC SQL DELETE FROM vmgr_tape_library WHERE ROWID = :rowid_value;
  if (sqlca.sqlcode) {
    vmgr_oracle_error (func, "DELETE", dbfd, &sqlca);
    return (-1);
  }
  return (0);
}

int vmgr_delete_model_entry(struct vmgr_dbfd *dbfd,
                            vmgr_dbrec_addr *rec_addr)
{
  char func[24];
  char rowid_value[19];
  struct sqlca sqlca;

  strncpy (func, "vmgr_delete_model_entry", 24);
  memcpy (rowid_value, rec_addr, sizeof(rowid_value));
  EXEC SQL DELETE FROM vmgr_tape_media WHERE ROWID = :rowid_value;
  if (sqlca.sqlcode) {
    vmgr_oracle_error (func, "DELETE", dbfd, &sqlca);
    return (-1);
  }
  return (0);
}

int vmgr_delete_pool_entry(struct vmgr_dbfd *dbfd,
                           vmgr_dbrec_addr *rec_addr)
{
  char func[23];
  char rowid_value[19];
  struct sqlca sqlca;

  strncpy (func, "vmgr_delete_pool_entry", 23);
  memcpy (rowid_value, rec_addr, sizeof(rowid_value));
  EXEC SQL DELETE FROM vmgr_tape_pool WHERE ROWID = :rowid_value;
  if (sqlca.sqlcode) {
    vmgr_oracle_error (func, "DELETE", dbfd, &sqlca);
    return (-1);
  }
  return (0);
}

int vmgr_delete_side_entry(struct vmgr_dbfd *dbfd,
                           vmgr_dbrec_addr *rec_addr)
{
  char func[23];
  char rowid_value[19];
  struct sqlca sqlca;

  strncpy (func, "vmgr_delete_side_entry", 23);
  memcpy (rowid_value, rec_addr, sizeof(rowid_value));
  EXEC SQL DELETE FROM vmgr_tape_side WHERE ROWID = :rowid_value;
  if (sqlca.sqlcode) {
    vmgr_oracle_error (func, "DELETE", dbfd, &sqlca);
    return (-1);
  }
  return (0);
}

int vmgr_delete_tag_entry(struct vmgr_dbfd *dbfd,
                          vmgr_dbrec_addr *rec_addr)
{
  char func[22];
  char rowid_value[19];
  struct sqlca sqlca;

  strncpy (func, "vmgr_delete_tag_entry", 22);
  memcpy (rowid_value, rec_addr, sizeof(rowid_value));
  EXEC SQL DELETE FROM vmgr_tape_tag WHERE ROWID = :rowid_value;
  if (sqlca.sqlcode) {
    vmgr_oracle_error (func, "DELETE", dbfd, &sqlca);
    return (-1);
  }
  return (0);
}

int vmgr_delete_tape_entry(struct vmgr_dbfd *dbfd,
                           vmgr_dbrec_addr *rec_addr)
{
  char func[23];
  char rowid_value[19];
  struct sqlca sqlca;

  strncpy (func, "vmgr_delete_tape_entry", 23);
  memcpy (rowid_value, rec_addr, sizeof(rowid_value));
  EXEC SQL DELETE FROM vmgr_tape_info WHERE ROWID = :rowid_value;
  if (sqlca.sqlcode) {
    vmgr_oracle_error (func, "DELETE", dbfd, &sqlca);
    return (-1);
  }
  return (0);
}

int vmgr_end_tr(struct vmgr_dbfd *dbfd)
{
  EXEC SQL COMMIT WORK;
  dbfd->tr_started = 0;
  return (0);
}

int vmgr_get_denmap_entry_byte_u64(
                                   struct vmgr_dbfd *dbfd,
                                   char *model,
                                   char *media_letter,
                                   char *density,
                                   struct vmgr_tape_denmap_byte_u64 *denmap_entry,
                                   int lock,
                                   vmgr_dbrec_addr *rec_addr)
{
  char func[22];
  char rowid_value[19];
  struct sqlca sqlca;
  char native_capacity_byte_str[21];
  EXEC SQL DECLARE denmap_cursor CURSOR FOR
    SELECT
    MD_MODEL, MD_MEDIA_LETTER, MD_DENSITY, TO_CHAR(NATIVE_CAPACITY)
    FROM vmgr_tape_denmap
    WHERE md_model = :model AND md_media_letter = :media_letter AND
    md_density = :density;
  EXEC SQL DECLARE denmap_cursor4upd CURSOR FOR
    SELECT ROWID,
    MD_MODEL, MD_MEDIA_LETTER, MD_DENSITY, TO_CHAR(NATIVE_CAPACITY)
    FROM vmgr_tape_denmap
    WHERE md_model = :model AND md_media_letter = :media_letter AND
    md_density = :density
    FOR UPDATE;

  strncpy (func, "vmgr_get_denmap_entry", 22);
  if (lock) {
    EXEC SQL OPEN denmap_cursor4upd;
    if (sqlca.sqlcode) {
      vmgr_oracle_error (func, "OPEN CURSOR", dbfd, &sqlca);
      return (-1);
    }
    EXEC SQL FETCH denmap_cursor4upd INTO
      :rowid_value,
      :denmap_entry->md_model,
      :denmap_entry->md_media_letter,
      :denmap_entry->md_density,
      :native_capacity_byte_str;
  } else {
    EXEC SQL OPEN denmap_cursor;
    if (sqlca.sqlcode) {
      vmgr_oracle_error (func, "OPEN CURSOR", dbfd, &sqlca);
      return (-1);
    }
    EXEC SQL FETCH denmap_cursor INTO
      :denmap_entry->md_model,
      :denmap_entry->md_media_letter,
      :denmap_entry->md_density,
      :native_capacity_byte_str;
  }
  switch (sqlca.sqlcode) {
  case 0:
    if (lock)
      memcpy (rec_addr, rowid_value, sizeof(rowid_value));
    denmap_entry->native_capacity_byte_u64 =
      strtou64 (native_capacity_byte_str);
    return (0);
  case 1403:
    serrno = ENOENT;
    break;
  default:
    vmgr_oracle_error (func, "FETCH", dbfd, &sqlca);
  }
  return (-1);
}

int vmgr_get_dgnmap_entry(struct vmgr_dbfd *dbfd,
                          char *model,
                          char *library,
                          struct vmgr_tape_dgnmap *dgnmap_entry,
                          int lock,
                          vmgr_dbrec_addr *rec_addr)
{
  char func[22];
  char rowid_value[19];
  struct sqlca sqlca;
  EXEC SQL DECLARE dgnmap_cursor CURSOR FOR
    SELECT
    DGN, MODEL, LIBRARY
    FROM vmgr_tape_dgnmap
    WHERE model = :model AND library = :library;
  EXEC SQL DECLARE dgnmap_cursor4upd CURSOR FOR
    SELECT ROWID,
    DGN, MODEL, LIBRARY
    FROM vmgr_tape_dgnmap
    WHERE model = :model AND library = :library
    FOR UPDATE;

  strncpy (func, "vmgr_get_dgnmap_entry", 22);
  if (lock) {
    EXEC SQL OPEN dgnmap_cursor4upd;
    if (sqlca.sqlcode) {
      vmgr_oracle_error (func, "OPEN CURSOR", dbfd, &sqlca);
      return (-1);
    }
    EXEC SQL FETCH dgnmap_cursor4upd INTO
      :rowid_value,
      :dgnmap_entry->dgn, :dgnmap_entry->model,
      :dgnmap_entry->library;
  } else {
    EXEC SQL OPEN dgnmap_cursor;
    if (sqlca.sqlcode) {
      vmgr_oracle_error (func, "OPEN CURSOR", dbfd, &sqlca);
      return (-1);
    }
    EXEC SQL FETCH dgnmap_cursor INTO
      :dgnmap_entry->dgn, :dgnmap_entry->model,
      :dgnmap_entry->library;
  }
  switch (sqlca.sqlcode) {
  case 0:
    if (lock)
      memcpy (rec_addr, rowid_value, sizeof(rowid_value));
    return (0);
  case 1403:
    serrno = ENOENT;
    break;
  default:
    vmgr_oracle_error (func, "FETCH", dbfd, &sqlca);
  }
  return (-1);
}

int vmgr_get_library_entry(struct vmgr_dbfd *dbfd,
                           char *library_name,
                           struct vmgr_tape_library *library_entry,
                           int lock,
                           vmgr_dbrec_addr *rec_addr)
{
  char func[23];
  char rowid_value[19];
  struct sqlca sqlca;
  EXEC SQL DECLARE library_cursor CURSOR FOR
    SELECT
    NAME, CAPACITY,
    NB_FREE_SLOTS, STATUS
    FROM vmgr_tape_library
    WHERE name = :library_name;
  EXEC SQL DECLARE library_cursor4upd CURSOR FOR
    SELECT ROWID,
    NAME, CAPACITY,
    NB_FREE_SLOTS, STATUS
    FROM vmgr_tape_library
    WHERE name = :library_name
    FOR UPDATE;

  strncpy (func, "vmgr_get_library_entry", 23);
  if (lock) {
    EXEC SQL OPEN library_cursor4upd;
    if (sqlca.sqlcode) {
      vmgr_oracle_error (func, "OPEN CURSOR", dbfd, &sqlca);
      return (-1);
    }
    EXEC SQL FETCH library_cursor4upd INTO
      :rowid_value,
      :library_entry->name, :library_entry->capacity,
      :library_entry->nb_free_slots, :library_entry->status;
  } else {
    EXEC SQL OPEN library_cursor;
    if (sqlca.sqlcode) {
      vmgr_oracle_error (func, "OPEN CURSOR", dbfd, &sqlca);
      return (-1);
    }
    EXEC SQL FETCH library_cursor INTO
      :library_entry->name, :library_entry->capacity,
      :library_entry->nb_free_slots, :library_entry->status;
  }
  switch (sqlca.sqlcode) {
  case 0:
    if (lock)
      memcpy (rec_addr, rowid_value, sizeof(rowid_value));
    return (0);
  case 1403:
    serrno = ENOENT;
    break;
  default:
    vmgr_oracle_error (func, "FETCH", dbfd, &sqlca);
  }
  return (-1);
}

int vmgr_get_model_entry(struct vmgr_dbfd *dbfd,
                         char *model,
                         struct vmgr_tape_media *model_entry,
                         int lock,
                         vmgr_dbrec_addr *rec_addr)
{
  char func[21];
  char rowid_value[19];
  struct sqlca sqlca;
  EXEC SQL DECLARE model_cursor CURSOR FOR
    SELECT
    M_MODEL, M_MEDIA_LETTER,
    MEDIA_COST
    FROM vmgr_tape_media
    WHERE m_model = :model;
  EXEC SQL DECLARE model_cursor4upd CURSOR FOR
    SELECT ROWID,
    M_MODEL, M_MEDIA_LETTER,
    MEDIA_COST
    FROM vmgr_tape_media
    WHERE m_model = :model
    FOR UPDATE;

  strncpy (func, "vmgr_get_model_entry", 21);
  if (lock) {
    EXEC SQL OPEN model_cursor4upd;
    if (sqlca.sqlcode) {
      vmgr_oracle_error (func, "OPEN CURSOR", dbfd, &sqlca);
      return (-1);
    }
    EXEC SQL FETCH model_cursor4upd INTO
      :rowid_value,
      :model_entry->m_model, :model_entry->m_media_letter,
      :model_entry->media_cost;
  } else {
    EXEC SQL OPEN model_cursor;
    if (sqlca.sqlcode) {
      vmgr_oracle_error (func, "OPEN CURSOR", dbfd, &sqlca);
      return (-1);
    }
    EXEC SQL FETCH model_cursor INTO
      :model_entry->m_model, :model_entry->m_media_letter,
      :model_entry->media_cost;
  }
  switch (sqlca.sqlcode) {
  case 0:
    if (lock)
      memcpy (rec_addr, rowid_value, sizeof(rowid_value));
    return (0);
  case 1403:
    serrno = ENOENT;
    break;
  default:
    vmgr_oracle_error (func, "FETCH", dbfd, &sqlca);
  }
  return (-1);
}

int vmgr_get_pool_entry_byte_u64(struct vmgr_dbfd *dbfd,
                                 char *pool_name,
                                 struct vmgr_tape_pool_byte_u64 *pool_entry,
                                 int lock,
                                 vmgr_dbrec_addr *rec_addr)
{
  char capacity_byte_str[21];
  char func[20];
  char rowid_value[19];
  struct sqlca sqlca;
  char tot_free_space_byte_str[21];
  EXEC SQL DECLARE pool_cursor CURSOR FOR
    SELECT
    NAME, OWNER_UID, GID, TO_CHAR(CAPACITY),
    TO_CHAR(TOT_FREE_SPACE)
    FROM vmgr_tape_pool
    WHERE name = :pool_name;
  EXEC SQL DECLARE pool_cursor4upd CURSOR FOR
    SELECT ROWID,
    NAME, OWNER_UID, GID, TO_CHAR(CAPACITY),
    TO_CHAR(TOT_FREE_SPACE)
    FROM vmgr_tape_pool
    WHERE name = :pool_name
    FOR UPDATE;

  strncpy (func, "vmgr_get_pool_entry", 20);
  if (lock) {
    EXEC SQL OPEN pool_cursor4upd;
    if (sqlca.sqlcode) {
      vmgr_oracle_error (func, "OPEN CURSOR", dbfd, &sqlca);
      return (-1);
    }
    EXEC SQL FETCH pool_cursor4upd INTO
      :rowid_value,
      :pool_entry->name, :pool_entry->uid, :pool_entry->gid,
      :capacity_byte_str, :tot_free_space_byte_str;
  } else {
    EXEC SQL OPEN pool_cursor;
    if (sqlca.sqlcode) {
      vmgr_oracle_error (func, "OPEN CURSOR", dbfd, &sqlca);
      return (-1);
    }
    EXEC SQL FETCH pool_cursor INTO
      :pool_entry->name, :pool_entry->uid, :pool_entry->gid,
      :capacity_byte_str, :tot_free_space_byte_str;
  }
  switch (sqlca.sqlcode) {
  case 0:
    if (lock)
      memcpy (rec_addr, rowid_value, sizeof(rowid_value));
    pool_entry->capacity_byte_u64 = strtou64 (capacity_byte_str);
    pool_entry->tot_free_space_byte_u64 =
      strtou64 (tot_free_space_byte_str);
    return (0);
  case 1403:
    serrno = ENOENT;
    break;
  default:
    vmgr_oracle_error (func, "FETCH", dbfd, &sqlca);
  }
  return (-1);
}

int vmgr_get_side_by_fullid_byte_u64 (struct vmgr_dbfd *dbfd,
                                      char *vid,
                                      int side,
                                      struct vmgr_tape_side_byte_u64 *side_entry,
                                      int lock,
                                      vmgr_dbrec_addr *rec_addr)
{
  char func[24];
  char rowid_value[19];
  struct sqlca sqlca;
  char estimated_free_space_byte_str[21];
  EXEC SQL DECLARE side_fullid_cursor CURSOR FOR
    SELECT
    VID, SIDE, POOLNAME, STATUS, TO_CHAR(ESTIMATED_FREE_SPACE),
    NBFILES
    FROM vmgr_tape_side
    WHERE vid = :vid AND side = :side;
  EXEC SQL DECLARE side_fullid_cursor4upd CURSOR FOR
    SELECT ROWID,
    VID, SIDE, POOLNAME, STATUS, TO_CHAR(ESTIMATED_FREE_SPACE),
    NBFILES
    FROM vmgr_tape_side
    WHERE vid = :vid AND side = :side
    FOR UPDATE;

  strncpy (func, "vmgr_get_side_by_fullid", 24);
  if (lock) {
    EXEC SQL OPEN side_fullid_cursor4upd;
    if (sqlca.sqlcode) {
      vmgr_oracle_error (func, "OPEN CURSOR", dbfd, &sqlca);
      return (-1);
    }
    EXEC SQL FETCH side_fullid_cursor4upd INTO
      :rowid_value,
      :side_entry->vid, :side_entry->side, :side_entry->poolname,
      :side_entry->status, :estimated_free_space_byte_str,
      :side_entry->nbfiles;
  } else {
    EXEC SQL OPEN side_fullid_cursor;
    if (sqlca.sqlcode) {
      vmgr_oracle_error (func, "OPEN CURSOR", dbfd, &sqlca);
      return (-1);
    }
    EXEC SQL FETCH side_fullid_cursor INTO
      :side_entry->vid, :side_entry->side, :side_entry->poolname,
      :side_entry->status, :estimated_free_space_byte_str,
      :side_entry->nbfiles;
  }
  switch (sqlca.sqlcode) {
  case 0:
    if (lock)
      memcpy (rec_addr, rowid_value, sizeof(rowid_value));
    side_entry->estimated_free_space_byte_u64 =
      strtou64 (estimated_free_space_byte_str);
    return (0);
  case 1403:
    serrno = ENOENT;
    break;
  default:
    vmgr_oracle_error (func, "FETCH", dbfd, &sqlca);
  }
  return (-1);
}

int vmgr_get_tag_by_vid(struct vmgr_dbfd *dbfd,
                        char *vid,
                        struct vmgr_tape_tag *tag_entry,
                        int lock,
                        vmgr_dbrec_addr *rec_addr)
{
  char func[20];
  char rowid_value[20];
  struct sqlca sqlca;
  EXEC SQL DECLARE tag_cursor CURSOR FOR
    SELECT
    VID, TEXT
    FROM vmgr_tape_tag
    WHERE vid = :vid;
  EXEC SQL DECLARE tag_cursor4upd CURSOR FOR
    SELECT ROWID,
    VID, TEXT
    FROM vmgr_tape_tag
    WHERE vid = :vid
    FOR UPDATE;

  strncpy (func, "vmgr_get_tag_by_vid", 20);
  if (lock) {
    EXEC SQL OPEN tag_cursor4upd;
    if (sqlca.sqlcode) {
      vmgr_oracle_error (func, "OPEN CURSOR", dbfd, &sqlca);
      return (-1);
    }
    EXEC SQL FETCH tag_cursor4upd INTO
      :rowid_value,
      :tag_entry->vid, :tag_entry->text;
  } else {
    EXEC SQL OPEN tag_cursor;
    if (sqlca.sqlcode) {
      vmgr_oracle_error (func, "OPEN CURSOR", dbfd, &sqlca);
      return (-1);
    }
    EXEC SQL FETCH tag_cursor INTO
      :tag_entry->vid, :tag_entry->text;
  }
  switch (sqlca.sqlcode) {
  case 0:
    if (lock)
      memcpy (rec_addr, rowid_value, sizeof(rowid_value));
    return (0);
  case 1403:
    serrno = ENOENT;
    break;
  default:
    vmgr_oracle_error (func, "FETCH", dbfd, &sqlca);
  }
  return (-1);
}

int vmgr_get_tape_by_vid_byte_u64(struct vmgr_dbfd *dbfd,
                                  char *vid,
                                  struct vmgr_tape_info_byte_u64 *tape_entry,
                                  int lock,
                                  vmgr_dbrec_addr *rec_addr)
{
  char func[21];
  short mf_ind;        /* indicator variable for manufacturer column */
  char rowid_value[19];
  short sn_ind;        /* indicator variable for sn column */
  struct sqlca sqlca;
  EXEC SQL DECLARE tape_vid_cursor CURSOR FOR
    SELECT
    VID, VSN, LIBRARY, DENSITY, LBLTYPE, MODEL, MEDIA_LETTER,
    MANUFACTURER, SN, NBSIDES, ETIME, RCOUNT, WCOUNT, RHOST, WHOST,
    RJID, WJID, RTIME, WTIME
    FROM vmgr_tape_info
    WHERE vid = :vid;
  EXEC SQL DECLARE tape_vid_cursor4upd CURSOR FOR
    SELECT ROWID,
    VID, VSN, LIBRARY, DENSITY, LBLTYPE, MODEL, MEDIA_LETTER,
    MANUFACTURER, SN, NBSIDES, ETIME, RCOUNT, WCOUNT, RHOST, WHOST,
    RJID, WJID, RTIME, WTIME
    FROM vmgr_tape_info
    WHERE vid = :vid
    FOR UPDATE;

  strncpy (func, "vmgr_get_tape_by_vid", 21);
  if (lock) {
    EXEC SQL OPEN tape_vid_cursor4upd;
    if (sqlca.sqlcode) {
      vmgr_oracle_error (func, "OPEN CURSOR", dbfd, &sqlca);
      return (-1);
    }
    EXEC SQL FETCH tape_vid_cursor4upd INTO
      :rowid_value,
      :tape_entry->vid, :tape_entry->vsn, :tape_entry->library,
      :tape_entry->density, :tape_entry->lbltype, :tape_entry->model,
      :tape_entry->media_letter, :tape_entry->manufacturer:mf_ind,
      :tape_entry->sn:sn_ind, :tape_entry->nbsides, :tape_entry->etime,
      :tape_entry->rcount, :tape_entry->wcount, :tape_entry->rhost,
      :tape_entry->whost, :tape_entry->rjid, :tape_entry->wjid,
      :tape_entry->rtime, :tape_entry->wtime;
  } else {
    EXEC SQL OPEN tape_vid_cursor;
    if (sqlca.sqlcode) {
      vmgr_oracle_error (func, "OPEN CURSOR", dbfd, &sqlca);
      return (-1);
    }
    EXEC SQL FETCH tape_vid_cursor INTO
      :tape_entry->vid, :tape_entry->vsn, :tape_entry->library,
      :tape_entry->density, :tape_entry->lbltype, :tape_entry->model,
      :tape_entry->media_letter, :tape_entry->manufacturer:mf_ind,
      :tape_entry->sn:sn_ind, :tape_entry->nbsides, :tape_entry->etime,
      :tape_entry->rcount, :tape_entry->wcount, :tape_entry->rhost,
      :tape_entry->whost, :tape_entry->rjid, :tape_entry->wjid,
      :tape_entry->rtime, :tape_entry->wtime;
  }
  switch (sqlca.sqlcode) {
  case 0:
    if (lock)
      memcpy (rec_addr, rowid_value, sizeof(rowid_value));
    return (0);
  case 1403:
    serrno = ENOENT;
    break;
  default:
    vmgr_oracle_error (func, "FETCH", dbfd, &sqlca);
  }
  return (-1);
}

int vmgr_get_side_by_size_byte_u64(struct vmgr_dbfd *dbfd,
                                   char *poolname,
                                   u_signed64 Size,
                                   struct vmgr_tape_side_byte_u64 *side_entry,
                                   int lock,
                                   vmgr_dbrec_addr *rec_addr)
{
  char func[22];
  int reqsize = (Size + 1023) / 1024;
  char rowid_value[19];
  struct sqlca sqlca;
  char estimated_free_space_byte_str[21];

  /* Try to find the five tapes with the least amount of free space that have */
  /* enough space to satisfy the specified request size, then pick one of     */
  /* those tapes at random.                                                   */
  EXEC SQL DECLARE tape_size_cursor4upd CURSOR FOR
    SELECT ROWID, vid, side, poolname, status, TO_CHAR(estimated_free_space),
    nbfiles
    FROM vmgr_tape_side
    WHERE
    vmgr_tape_side.vid = (
                          SELECT vid
                          FROM (
                                SELECT vid
                                FROM (
                                      SELECT vid
                                      FROM (
                                            SELECT vmgr_tape_side.vid
                                            FROM vmgr_tape_side, vmgr_tape_info, vmgr_tape_library
                                            WHERE
                                            vmgr_tape_side.vid = vmgr_tape_info.vid
                                            AND vmgr_tape_info.library = vmgr_tape_library.name
                                            AND vmgr_tape_library.status = 0
                                            AND vmgr_tape_side.poolname = :poolname
                                            AND vmgr_tape_side.status = 0
                                            AND vmgr_tape_side.estimated_free_space >= :reqsize
                                            ORDER BY vmgr_tape_side.estimated_free_space asc, DBMS_RANDOM.VALUE)
                                      WHERE rownum <= 5)
                                ORDER BY DBMS_RANDOM.VALUE)
                          WHERE ROWNUM < 2)
    FOR UPDATE;

  /* Try to find the five tapes with the most amount of free space and then */
  /* choose one of them at random                                           */
  EXEC SQL DECLARE tape_maxsize_cursor4upd CURSOR FOR
    SELECT ROWID, vid, side, poolname, status, TO_CHAR(estimated_free_space),
    nbfiles
    FROM vmgr_tape_side
    WHERE
    vmgr_tape_side.vid = (
                          SELECT vid
                          FROM (
                                SELECT vid
                                FROM (
                                      SELECT vid
                                      FROM (
                                            SELECT vmgr_tape_side.vid
                                            FROM vmgr_tape_side, vmgr_tape_info, vmgr_tape_library
                                            WHERE
                                            vmgr_tape_side.vid = vmgr_tape_info.vid
                                            AND vmgr_tape_info.library = vmgr_tape_library.name
                                            AND vmgr_tape_library.status = 0
                                            AND vmgr_tape_side.poolname = :poolname
                                            AND vmgr_tape_side.status = 0
                                            ORDER BY vmgr_tape_side.estimated_free_space desc, DBMS_RANDOM.VALUE)
                                      WHERE rownum <= 5)
                                ORDER BY DBMS_RANDOM.VALUE)
                          WHERE ROWNUM < 2)
    FOR UPDATE;

  strncpy (func, "vmgr_get_tape_by_size", 22);
  EXEC SQL OPEN tape_size_cursor4upd;
  if (sqlca.sqlcode) {
    vmgr_oracle_error (func, "OPEN CURSOR", dbfd, &sqlca);
    return (-1);
  }
  EXEC SQL FETCH tape_size_cursor4upd INTO
    :rowid_value,
    :side_entry->vid, :side_entry->side, :side_entry->poolname,
    :side_entry->status, :estimated_free_space_byte_str,
    :side_entry->nbfiles;
  /* If no data was found */
  if (sqlca.sqlcode == 1403) {
    EXEC SQL OPEN tape_maxsize_cursor4upd;
    if (sqlca.sqlcode) {
      vmgr_oracle_error (func, "OPEN CURSOR", dbfd, &sqlca);
      return (-1);
    }
    EXEC SQL FETCH tape_maxsize_cursor4upd INTO
      :rowid_value,
      :side_entry->vid, :side_entry->side, :side_entry->poolname,
      :side_entry->status, :estimated_free_space_byte_str,
      :side_entry->nbfiles;
  }
  switch (sqlca.sqlcode) {
  case 0:
    if (lock)
      memcpy (rec_addr, rowid_value, sizeof(rowid_value));
    side_entry->estimated_free_space_byte_u64 =
      strtou64 (estimated_free_space_byte_str);
    return (0);
  case 1403:
    serrno = ENOENT;
    break;
  default:
    vmgr_oracle_error (func, "FETCH", dbfd, &sqlca);
  }
  return (-1);
}

int vmgr_insert_denmap_entry_byte_u64(struct vmgr_dbfd *dbfd,
                                      struct vmgr_tape_denmap_byte_u64 *denmap_entry)
{
  char func[25];
  struct sqlca sqlca;
  char native_capacity_byte_str[21];

  strncpy (func, "vmgr_insert_denmap_entry", 25);
  (void) u64tostr (denmap_entry->native_capacity_byte_u64,
                   native_capacity_byte_str, -1);
  EXEC SQL INSERT INTO vmgr_tape_denmap
    (MD_MODEL, MD_MEDIA_LETTER, MD_DENSITY, NATIVE_CAPACITY)
    VALUES
    (:denmap_entry->md_model,
     :denmap_entry->md_media_letter,
     :denmap_entry->md_density,
     TO_NUMBER(:native_capacity_byte_str));
  switch (sqlca.sqlcode) {
  case 0:
    return (0);
  case -1:
    serrno = EEXIST;
    break;
  case -1631:
  case -1632:
  case -1654:
    serrno = ENOSPC;
    break;
  default:
    vmgr_oracle_error (func, "INSERT", dbfd, &sqlca);
  }
  return (-1);
}

int vmgr_insert_dgnmap_entry(struct vmgr_dbfd *dbfd,
                             struct vmgr_tape_dgnmap *dgnmap_entry)
{
  char func[25];
  struct sqlca sqlca;

  strncpy (func, "vmgr_insert_dgnmap_entry", 25);
  EXEC SQL INSERT INTO vmgr_tape_dgnmap
    (DGN, MODEL, LIBRARY)
    VALUES
    (:dgnmap_entry->dgn, :dgnmap_entry->model,
     :dgnmap_entry->library);
  switch (sqlca.sqlcode) {
  case 0:
    return (0);
  case -1:
    serrno = EEXIST;
    break;
  case -1631:
  case -1632:
  case -1654:
    serrno = ENOSPC;
    break;
  default:
    vmgr_oracle_error (func, "INSERT", dbfd, &sqlca);
  }
  return (-1);
}

int vmgr_insert_library_entry(struct vmgr_dbfd *dbfd,
                              struct vmgr_tape_library *library_entry)
{
  char func[26];
  struct sqlca sqlca;

  strncpy (func, "vmgr_insert_library_entry", 26);
  EXEC SQL INSERT INTO vmgr_tape_library
    (NAME, CAPACITY, NB_FREE_SLOTS, STATUS)
    VALUES
    (:library_entry->name, :library_entry->capacity,
     :library_entry->nb_free_slots, :library_entry->status);
  switch (sqlca.sqlcode) {
  case 0:
    return (0);
  case -1:
    serrno = EEXIST;
    break;
  case -1631:
  case -1632:
  case -1654:
    serrno = ENOSPC;
    break;
  default:
    vmgr_oracle_error (func, "INSERT", dbfd, &sqlca);
  }
  return (-1);
}

int vmgr_insert_model_entry(struct vmgr_dbfd *dbfd,
                            struct vmgr_tape_media *model_entry)
{
  char func[24];
  struct sqlca sqlca;

  strncpy (func, "vmgr_insert_model_entry", 24);
  EXEC SQL INSERT INTO vmgr_tape_media
    (M_MODEL, M_MEDIA_LETTER, MEDIA_COST)
    VALUES
    (:model_entry->m_model, :model_entry->m_media_letter,
     :model_entry->media_cost);
  switch (sqlca.sqlcode) {
  case 0:
    return (0);
  case -1:
    serrno = EEXIST;
    break;
  case -1631:
  case -1632:
  case -1654:
    serrno = ENOSPC;
    break;
  default:
    vmgr_oracle_error (func, "INSERT", dbfd, &sqlca);
  }
  return (-1);
}

int vmgr_insert_pool_entry_byte_u64(struct vmgr_dbfd *dbfd,
                                    struct vmgr_tape_pool_byte_u64 *pool_entry)
{
  char capacity_byte_str[21];
  char func[23];
  struct sqlca sqlca;
  char tot_free_space_byte_str[21];

  strncpy (func, "vmgr_insert_pool_entry", 23);
  (void) u64tostr (pool_entry->capacity_byte_u64, capacity_byte_str, -1);
  (void) u64tostr (pool_entry->tot_free_space_byte_u64,
                   tot_free_space_byte_str, -1);
  EXEC SQL INSERT INTO vmgr_tape_pool
    (NAME, OWNER_UID, GID, CAPACITY, TOT_FREE_SPACE)
    VALUES
    (:pool_entry->name, :pool_entry->uid, :pool_entry->gid,
     TO_NUMBER(:capacity_byte_str),
     TO_NUMBER(:tot_free_space_byte_str));
  switch (sqlca.sqlcode) {
  case 0:
    return (0);
  case -1:
    serrno = EEXIST;
    break;
  case -1631:
  case -1632:
  case -1654:
    serrno = ENOSPC;
    break;
  default:
    vmgr_oracle_error (func, "INSERT", dbfd, &sqlca);
  }
  return (-1);
}

int vmgr_insert_side_entry_byte_u64(struct vmgr_dbfd *dbfd,
                                    struct vmgr_tape_side_byte_u64 *side_entry)
{
  char func[23];
  struct sqlca sqlca;
  char estimated_free_space_byte_str[21];

  strncpy (func, "vmgr_insert_side_entry", 23);
  (void) u64tostr (side_entry->estimated_free_space_byte_u64,
                   estimated_free_space_byte_str, -1);
  EXEC SQL INSERT INTO vmgr_tape_side
    (VID, SIDE, POOLNAME, STATUS, ESTIMATED_FREE_SPACE, NBFILES)
    VALUES
    (:side_entry->vid, :side_entry->side, :side_entry->poolname,
     :side_entry->status, TO_NUMBER(:estimated_free_space_byte_str),
     :side_entry->nbfiles);
  switch (sqlca.sqlcode) {
  case 0:
    return (0);
  case -1:
    serrno = EEXIST;
    break;
  case -1631:
  case -1632:
  case -1654:
    serrno = ENOSPC;
    break;
  default:
    vmgr_oracle_error (func, "INSERT", dbfd, &sqlca);
  }
  return (-1);
}

int vmgr_insert_tag_entry(struct vmgr_dbfd *dbfd,
                          struct vmgr_tape_tag *tag_entry)
{
  char func[22];
  struct sqlca sqlca;

  strncpy (func, "vmgr_insert_tag_entry", 22);
  EXEC SQL INSERT INTO vmgr_tape_tag
    (VID,  TEXT)
    VALUES
    (:tag_entry->vid, :tag_entry->text);
  switch (sqlca.sqlcode) {
  case 0:
    return (0);
  case -1:
    serrno = EEXIST;
    break;
  case -1631:
  case -1632:
  case -1654:
    serrno = ENOSPC;
    break;
  default:
    vmgr_oracle_error (func, "INSERT", dbfd, &sqlca);
  }
  return (-1);
}

int vmgr_insert_tape_entry_byte_u64(struct vmgr_dbfd *dbfd,
                                    struct vmgr_tape_info_byte_u64 *tape_entry)
{
  char func[23];
  struct sqlca sqlca;

  strncpy (func, "vmgr_insert_tape_entry", 23);
  EXEC SQL INSERT INTO vmgr_tape_info
    (VID, VSN, LIBRARY, DENSITY, LBLTYPE, MODEL, MEDIA_LETTER,
     MANUFACTURER, SN, NBSIDES, ETIME, RCOUNT, WCOUNT, RHOST, WHOST,
     RJID, WJID, RTIME, WTIME)
    VALUES
    (:tape_entry->vid, :tape_entry->vsn, :tape_entry->library,
     :tape_entry->density, :tape_entry->lbltype, :tape_entry->model,
     :tape_entry->media_letter, :tape_entry->manufacturer,
     :tape_entry->sn, :tape_entry->nbsides, :tape_entry->etime,
     :tape_entry->rcount, :tape_entry->wcount, :tape_entry->rhost,
     :tape_entry->whost, :tape_entry->rjid, :tape_entry->wjid,
     :tape_entry->rtime, :tape_entry->wtime);
  switch (sqlca.sqlcode) {
  case 0:
    return (0);
  case -1:
    serrno = EEXIST;
    break;
  case -1631:
  case -1632:
  case -1654:
    serrno = ENOSPC;
    break;
  default:
    vmgr_oracle_error (func, "INSERT", dbfd, &sqlca);
  }
  return (-1);
}

int vmgr_list_denmap_entry_byte_u64(
                                    struct vmgr_dbfd *dbfd,
                                    int bol,
                                    struct vmgr_tape_denmap_byte_u64 *denmap_entry,
                                    int endlist)
{
  char func[23];
  struct sqlca sqlca;
  char native_capacity_byte_str[21];
  EXEC SQL DECLARE list_denmap_cursor CURSOR FOR
    SELECT
    MD_MODEL, MD_MEDIA_LETTER, MD_DENSITY, TO_CHAR(NATIVE_CAPACITY)
    FROM vmgr_tape_denmap
    ORDER BY md_model, md_media_letter, native_capacity;

  strncpy (func, "vmgr_list_denmap_entry", 23);
  if (endlist)
    return (1);
  if (bol) {
    EXEC SQL OPEN list_denmap_cursor;
    if (sqlca.sqlcode) {
      vmgr_oracle_error (func, "OPEN CURSOR", dbfd, &sqlca);
      return (-1);
    }
  }
  EXEC SQL FETCH list_denmap_cursor INTO
    :denmap_entry->md_model, :denmap_entry->md_media_letter,
    :denmap_entry->md_density, :native_capacity_byte_str;
  switch (sqlca.sqlcode) {
  case 0:
    denmap_entry->native_capacity_byte_u64 =
      strtou64 (native_capacity_byte_str);
    return (0);
  case 1403:
    return (1);
  default:
    vmgr_oracle_error (func, "FETCH", dbfd, &sqlca);
    return (-1);
  }
}

int vmgr_list_dgnmap_entry(struct vmgr_dbfd *dbfd,
                           int bol,
                           struct vmgr_tape_dgnmap *dgnmap_entry,
                           int endlist)
{
  char func[23];
  struct sqlca sqlca;
  EXEC SQL DECLARE list_dgnmap_cursor CURSOR FOR
    SELECT
    DGN, MODEL, LIBRARY
    FROM vmgr_tape_dgnmap
    ORDER BY dgn;

  strncpy (func, "vmgr_list_dgnmap_entry", 23);
  if (endlist)
    return (1);
  if (bol) {
    EXEC SQL OPEN list_dgnmap_cursor;
    if (sqlca.sqlcode) {
      vmgr_oracle_error (func, "OPEN CURSOR", dbfd, &sqlca);
      return (-1);
    }
  }
  EXEC SQL FETCH list_dgnmap_cursor INTO
    :dgnmap_entry->dgn, :dgnmap_entry->model,
    :dgnmap_entry->library;
  switch (sqlca.sqlcode) {
  case 0:
    return (0);
  case 1403:
    return (1);
  default:
    vmgr_oracle_error (func, "FETCH", dbfd, &sqlca);
    return (-1);
  }
}

int vmgr_list_library_entry(struct vmgr_dbfd *dbfd,
                            int bol,
                            struct vmgr_tape_library *library_entry,
                            int endlist)
{
  char func[24];
  struct sqlca sqlca;
  EXEC SQL DECLARE list_library_cursor CURSOR FOR
    SELECT
    NAME, CAPACITY, NB_FREE_SLOTS, STATUS
    FROM vmgr_tape_library
    ORDER BY name;

  strncpy (func, "vmgr_list_library_entry", 24);
  if (endlist)
    return (1);
  if (bol) {
    EXEC SQL OPEN list_library_cursor;
    if (sqlca.sqlcode) {
      vmgr_oracle_error (func, "OPEN CURSOR", dbfd, &sqlca);
      return (-1);
    }
  }
  EXEC SQL FETCH list_library_cursor INTO
    :library_entry->name, :library_entry->capacity,
    :library_entry->nb_free_slots, :library_entry->status;
  switch (sqlca.sqlcode) {
  case 0:
    return (0);
  case 1403:
    return (1);
  default:
    vmgr_oracle_error (func, "FETCH", dbfd, &sqlca);
    return (-1);
  }
}

int vmgr_list_model_entry(struct vmgr_dbfd *dbfd,
                          int bol,
                          struct vmgr_tape_media *model_entry,
                          int endlist)
{
  char func[22];
  struct sqlca sqlca;
  EXEC SQL DECLARE list_model_cursor CURSOR FOR
    SELECT
    M_MODEL, M_MEDIA_LETTER, MEDIA_COST
    FROM vmgr_tape_media
    ORDER BY m_model, m_media_letter;

  strncpy (func, "vmgr_list_model_entry", 22);
  if (endlist)
    return (1);
  if (bol) {
    EXEC SQL OPEN list_model_cursor;
    if (sqlca.sqlcode) {
      vmgr_oracle_error (func, "OPEN CURSOR", dbfd, &sqlca);
      return (-1);
    }
  }
  EXEC SQL FETCH list_model_cursor INTO
    :model_entry->m_model, :model_entry->m_media_letter,
    :model_entry->media_cost;
  switch (sqlca.sqlcode) {
  case 0:
    return (0);
  case 1403:
    return (1);
  default:
    vmgr_oracle_error (func, "FETCH", dbfd, &sqlca);
    return (-1);
  }
}

int vmgr_list_pool_entry_byte_u64(struct vmgr_dbfd *dbfd,
                                  int bol,
                                  struct vmgr_tape_pool_byte_u64 *pool_entry,
                                  int endlist)
{
  char capacity_byte_str[21];
  char func[21];
  struct sqlca sqlca;
  char tot_free_space_byte_str[21];
  EXEC SQL DECLARE list_pool_cursor CURSOR FOR
    SELECT
    NAME, OWNER_UID, GID, TO_CHAR(CAPACITY), TO_CHAR(TOT_FREE_SPACE)
    FROM vmgr_tape_pool
    ORDER BY name;

  strncpy (func, "vmgr_list_pool_entry", 21);
  if (endlist)
    return (1);
  if (bol) {
    EXEC SQL OPEN list_pool_cursor;
    if (sqlca.sqlcode) {
      vmgr_oracle_error (func, "OPEN CURSOR", dbfd, &sqlca);
      return (-1);
    }
  }
  EXEC SQL FETCH list_pool_cursor INTO
    :pool_entry->name, :pool_entry->uid, :pool_entry->gid,
    :capacity_byte_str, :tot_free_space_byte_str;
  switch (sqlca.sqlcode) {
  case 0:
    pool_entry->capacity_byte_u64 = strtou64 (capacity_byte_str);
    pool_entry->tot_free_space_byte_u64 =
      strtou64 (tot_free_space_byte_str);
    return (0);
  case 1403:
    return (1);
  default:
    vmgr_oracle_error (func, "FETCH", dbfd, &sqlca);
    return (-1);
  }
}

int vmgr_list_side_entry_byte_u64(struct vmgr_dbfd *dbfd,
                                  int bol,
                                  char *vid,
                                  char *pool_name,
                                  struct vmgr_tape_side_byte_u64 *side_entry,
                                  int endlist)
{
  char func[21];
  struct sqlca sqlca;
  char estimated_free_space_byte_str[21];
  EXEC SQL DECLARE list_tape_cursor CURSOR FOR
    SELECT
    VID, SIDE, POOLNAME, STATUS, TO_CHAR(ESTIMATED_FREE_SPACE),
    NBFILES
    FROM vmgr_tape_side
    ORDER BY vid, side;
  EXEC SQL DECLARE list_tape_in_pool_cursor CURSOR FOR
    SELECT
    VID, SIDE, POOLNAME, STATUS, TO_CHAR(ESTIMATED_FREE_SPACE),
    NBFILES
    FROM vmgr_tape_side
    WHERE poolname = :pool_name
    ORDER BY vid, side;
  EXEC SQL DECLARE list_vid_cursor CURSOR FOR
    SELECT
    VID, SIDE, POOLNAME, STATUS, TO_CHAR(ESTIMATED_FREE_SPACE),
    NBFILES
    FROM vmgr_tape_side
    WHERE vid = :vid
    ORDER BY side;

  strncpy (func, "vmgr_list_side_entry", 21);
  if (endlist)
    return (1);
  if (*vid) {
    if (bol) {
      EXEC SQL OPEN list_vid_cursor;
      if (sqlca.sqlcode) {
        vmgr_oracle_error (func, "OPEN CURSOR", dbfd, &sqlca);
        return (-1);
      }
    }
    EXEC SQL FETCH list_vid_cursor INTO
      :side_entry->vid, :side_entry->side, :side_entry->poolname,
      :side_entry->status, :estimated_free_space_byte_str,
      :side_entry->nbfiles;
  } else if (*pool_name) {
    if (bol) {
      EXEC SQL OPEN list_tape_in_pool_cursor;
      if (sqlca.sqlcode) {
        vmgr_oracle_error (func, "OPEN CURSOR", dbfd, &sqlca);
        return (-1);
      }
    }
    EXEC SQL FETCH list_tape_in_pool_cursor INTO
      :side_entry->vid, :side_entry->side, :side_entry->poolname,
      :side_entry->status, :estimated_free_space_byte_str,
      :side_entry->nbfiles;
  } else {
    if (bol) {
      EXEC SQL OPEN list_tape_cursor;
      if (sqlca.sqlcode) {
        vmgr_oracle_error (func, "OPEN CURSOR", dbfd, &sqlca);
        return (-1);
      }
    }
    EXEC SQL FETCH list_tape_cursor INTO
      :side_entry->vid, :side_entry->side, :side_entry->poolname,
      :side_entry->status, :estimated_free_space_byte_str,
      :side_entry->nbfiles;
  }
  switch (sqlca.sqlcode) {
  case 0:
    side_entry->estimated_free_space_byte_u64 =
      strtou64 (estimated_free_space_byte_str);
    return (0);
  case 1403:
    if (*vid && bol) {
      serrno = ENOENT;
      return (-1);
    } else
      return (1);
  default:
    vmgr_oracle_error (func, "FETCH", dbfd, &sqlca);
    return (-1);
  }
}

int vmgr_opendb(struct vmgr_dbfd *dbfd)
{
  extern char vmgrconfigfile[CA_MAXPATHLEN+1];
  char func[16];
  struct sqlca sqlca;
  char db_connect[104];
  char buf[CA_MAXLINELEN+1];
  char db_user[CA_MAXLINELEN+1];
  char db_pwd[CA_MAXLINELEN+1];
  char db_srv[CA_MAXLINELEN+1];
  char db_name[CA_MAXLINELEN+1];
  char *p = NULL;
  FILE *fp = NULL;
  char schema_version[21] = "";

  strncpy (func, "vmgr_opendb", 16);
  EXEC SQL CONTEXT ALLOCATE :ctx[dbfd->idx];

  db_user[0] = db_pwd[0] = db_srv[0] = '\0';
  serrno = 0;
  if ((fp = fopen(vmgrconfigfile, "r")) == NULL) {
    vmgrlogit("MSG=\"Error: Failed to open VMGCONFIG\" Path=\"%s\" "
              "Function=\"%s\" Error=\"%s\"",
              vmgrconfigfile, func, strerror(errno));
    return (-1);
  }
  while (fgets(buf, sizeof(buf), fp)) {
    if (buf[0] == '#') {
      continue; /* ignore comments */
    }
    /* parse content */
    db_user[0] = db_pwd[0] = db_srv[0] = '\0';
    if ((p = strtok(buf, "/\n")) != NULL)
      strcpy (db_user, p);
    if ((p = strtok(NULL, "@\n")) != NULL)
      strcpy (db_pwd, p);
    if ((p = strtok(NULL, "/\n")) != NULL)
      strcpy (db_srv, p);
    if ((p = strtok(NULL, "\n")) != NULL)
      strcpy (db_name, p);
    else
      strcpy(db_name, "Cns_db");
  }
  fclose(fp);

  if ((db_user[0] == '\0') ||
      (db_pwd[0]  == '\0') ||
      (db_srv[0]  == '\0') ||
      (db_name[0] == '\0')) {
    vmgrlogit("MSG=\"Error: Failed to extract database connect string\" "
              "Path=\"%s\" Function=\"%s\"", vmgrconfigfile, func);
    return (-1);
  }

  /* connect */
  if (strlen(db_srv) > 0) {
    sprintf(db_connect, "%s/%s@%s", db_user, db_pwd, db_srv);
  } else {
    sprintf(db_connect, "%s/%s", db_user, db_pwd);
  }
  vmgrlogit("MSG=\"Attempting to connect to database\" "
            "ConnectionDetails=\"%s/*******@%s\"", db_user, db_srv);

  EXEC SQL CONNECT :db_connect;
  if (sqlca.sqlcode == 0) {
    dbfd->connected = 1;
  } else {
    vmgr_closedb (dbfd);
    vmgr_oracle_error (func, "CONNECT", dbfd, &sqlca);
    return -1;
  }

  /* determine the schema version */
  EXEC SQL SELECT schemaVersion INTO :schema_version
             FROM CastorVersion;
  switch (sqlca.sqlcode) {
  case 0: {
    if (strcmp(schema_version, VMGRSCHEMAVERSION) != 0) {
      vmgr_closedb (dbfd);
      vmgrlogit("MSG=\"Error: Incorrect schema version detected, "
                "disconnecting\" SchemaVersion=\"%s\" RequiredVersion=\"%s\"",
                schema_version, VMGRSCHEMAVERSION);
      return -1;
    }
    vmgrlogit("MSG=\"Connection successful\" SchemaVersion=\"%s\"",
              schema_version);
    return 0;
  }
  default:
    vmgr_oracle_error (func, "CONNECT", dbfd, &sqlca);
    return -1;
  }

  return (0);
}

int vmgr_start_tr(struct vmgr_dbfd *dbfd)
{
  dbfd->tr_started = 1;
  return (0);
}

int vmgr_update_library_entry(struct vmgr_dbfd *dbfd,
                              vmgr_dbrec_addr *rec_addr,
                              struct vmgr_tape_library *library_entry)
{
  char func[26];
  char rowid_value[19];
  struct sqlca sqlca;

  strncpy (func, "vmgr_update_library_entry", 26);
  memcpy (rowid_value, rec_addr, sizeof(rowid_value));
  EXEC SQL UPDATE vmgr_tape_library SET
    CAPACITY = :library_entry->capacity,
    NB_FREE_SLOTS = :library_entry->nb_free_slots,
    STATUS = :library_entry->status
    WHERE ROWID = :rowid_value;
  if (sqlca.sqlcode) {
    vmgr_oracle_error (func, "UPDATE", dbfd, &sqlca);
    return (-1);
  }
  return (0);
}

int vmgr_update_model_entry(struct vmgr_dbfd *dbfd,
                            vmgr_dbrec_addr *rec_addr,
                            struct vmgr_tape_media *model_entry)
{
  char func[24];
  char rowid_value[19];
  struct sqlca sqlca;

  strncpy (func, "vmgr_update_model_entry", 24);
  memcpy (rowid_value, rec_addr, sizeof(rowid_value));
  EXEC SQL UPDATE vmgr_tape_media SET
    MEDIA_COST = :model_entry->media_cost
    WHERE ROWID = :rowid_value;
  if (sqlca.sqlcode) {
    vmgr_oracle_error (func, "UPDATE", dbfd, &sqlca);
    return (-1);
  }
  return (0);
}

int vmgr_update_pool_entry_byte_u64(struct vmgr_dbfd *dbfd,
                                    vmgr_dbrec_addr *rec_addr,
                                    struct vmgr_tape_pool_byte_u64 *pool_entry)
{
  char capacity_byte_str[21];
  char func[23];
  char rowid_value[19];
  struct sqlca sqlca;
  char tot_free_space_byte_str[21];

  strncpy (func, "vmgr_update_pool_entry", 23);
  memcpy (rowid_value, rec_addr, sizeof(rowid_value));
  (void) u64tostr (pool_entry->capacity_byte_u64, capacity_byte_str, -1);
  (void) u64tostr (pool_entry->tot_free_space_byte_u64,
                   tot_free_space_byte_str, -1);
  EXEC SQL UPDATE vmgr_tape_pool SET
    OWNER_UID = :pool_entry->uid,
    GID = :pool_entry->gid,
    CAPACITY = TO_NUMBER(:capacity_byte_str),
    TOT_FREE_SPACE = TO_NUMBER(:tot_free_space_byte_str)
    WHERE ROWID = :rowid_value;
  if (sqlca.sqlcode) {
    vmgr_oracle_error (func, "UPDATE", dbfd, &sqlca);
    return (-1);
  }
  return (0);
}

int vmgr_update_side_entry_byte_u64(struct vmgr_dbfd *dbfd,
                                    vmgr_dbrec_addr *rec_addr,
                                    struct vmgr_tape_side_byte_u64 *side_entry)
{
  char func[23];
  char rowid_value[19];
  struct sqlca sqlca;
  char estimated_free_space_byte_str[21];

  strncpy (func, "vmgr_update_side_entry", 23);
  (void) u64tostr (side_entry->estimated_free_space_byte_u64,
                   estimated_free_space_byte_str, -1);
  memcpy (rowid_value, rec_addr, sizeof(rowid_value));
  EXEC SQL UPDATE vmgr_tape_side SET
    POOLNAME = :side_entry->poolname,
    STATUS = :side_entry->status,
    ESTIMATED_FREE_SPACE =
    TO_NUMBER(:estimated_free_space_byte_str),
    NBFILES = :side_entry->nbfiles
    WHERE ROWID = :rowid_value;
  if (sqlca.sqlcode) {
    vmgr_oracle_error (func, "UPDATE", dbfd, &sqlca);
    return (-1);
  }
  return (0);
}

int vmgr_update_tag_entry(struct vmgr_dbfd *dbfd,
                          vmgr_dbrec_addr *rec_addr,
                          struct vmgr_tape_tag *tag_entry)
{
  char func[22];
  char rowid_value[19];
  struct sqlca sqlca;

  strncpy (func, "vmgr_update_tag_entry", 22);
  memcpy (rowid_value, rec_addr, sizeof(rowid_value));
  EXEC SQL UPDATE vmgr_tape_tag SET
    TEXT = :tag_entry->text
    WHERE ROWID = :rowid_value;
  if (sqlca.sqlcode) {
    vmgr_oracle_error (func, "UPDATE", dbfd, &sqlca);
    return (-1);
  }
  return (0);
}

int vmgr_update_tape_entry_byte_u64(struct vmgr_dbfd *dbfd,
                                    vmgr_dbrec_addr *rec_addr,
                                    struct vmgr_tape_info_byte_u64 *tape_entry)
{
  char func[23];
  char rowid_value[19];
  struct sqlca sqlca;

  strncpy (func, "vmgr_update_tape_entry", 23);
  memcpy (rowid_value, rec_addr, sizeof(rowid_value));
  EXEC SQL UPDATE vmgr_tape_info SET
    VSN = :tape_entry->vsn,
    LIBRARY = :tape_entry->library,
    DENSITY = :tape_entry->density,
    LBLTYPE = :tape_entry->lbltype,
    MODEL = :tape_entry->model,
    MEDIA_LETTER = :tape_entry->media_letter,
    MANUFACTURER = :tape_entry->manufacturer,
    SN = :tape_entry->sn,
    NBSIDES = :tape_entry->nbsides,
    ETIME = :tape_entry->etime,
    RCOUNT = :tape_entry->rcount,
    WCOUNT = :tape_entry->wcount,
    RHOST = :tape_entry->rhost,
    WHOST = :tape_entry->whost,
    RJID = :tape_entry->rjid,
    WJID = :tape_entry->wjid,
    RTIME = :tape_entry->rtime,
    WTIME = :tape_entry->wtime
    WHERE ROWID = :rowid_value;
  if (sqlca.sqlcode) {
    vmgr_oracle_error (func, "UPDATE", dbfd, &sqlca);
    return (-1);
  }
  return (0);
}
