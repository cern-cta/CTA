/**** This file has been autogenerated by gencastor from Umbrello UML model ***/

/******************************************************************************
 *                      castor/db/cnv/DbSegmentCnv.cpp
 *
 * This file is part of the Castor project.
 * See http://castor.web.cern.ch/castor
 *
 * Copyright (C) 2003  CERN
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 *
 * @author Castor Dev team, castor-dev@cern.ch
 *****************************************************************************/

// Include Files
#include "DbSegmentCnv.hpp"
#include "castor/BaseAddress.hpp"
#include "castor/CnvFactory.hpp"
#include "castor/Constants.hpp"
#include "castor/IAddress.hpp"
#include "castor/ICnvSvc.hpp"
#include "castor/IObject.hpp"
#include "castor/VectorAddress.hpp"
#include "castor/db/DbCnvSvc.hpp"
#include "castor/exception/Exception.hpp"
#include "castor/exception/Internal.hpp"
#include "castor/exception/InvalidArgument.hpp"
#include "castor/exception/NoEntry.hpp"
#include "castor/exception/OutOfMemory.hpp"
#include "castor/stager/Segment.hpp"
#include "castor/stager/SegmentStatusCodes.hpp"
#include "castor/stager/Tape.hpp"
#include "castor/stager/TapeCopy.hpp"
#include <stdlib.h>
#include <vector>

//------------------------------------------------------------------------------
// Instantiation of a static factory class - should never be used
//------------------------------------------------------------------------------
static castor::CnvFactory<castor::db::cnv::DbSegmentCnv>* s_factoryDbSegmentCnv =
  new castor::CnvFactory<castor::db::cnv::DbSegmentCnv>();

//------------------------------------------------------------------------------
// Static constants initialization
//------------------------------------------------------------------------------
/// SQL statement for request insertion
const std::string castor::db::cnv::DbSegmentCnv::s_insertStatementString =
"INSERT INTO Segment (fseq, offset, bytes_in, bytes_out, host_bytes, segmCksumAlgorithm, segmCksum, errMsgTxt, errorCode, severity, blockId0, blockId1, blockId2, blockId3, creationTime, priority, id, copy, status, tape) VALUES (:1,:2,:3,:4,:5,:6,:7,:8,:9,:10,:11,:12,:13,:14,:15,:16,ids_seq.nextval,:17,:18,:19) RETURNING id INTO :20";

/// SQL statement for request deletion
const std::string castor::db::cnv::DbSegmentCnv::s_deleteStatementString =
"DELETE FROM Segment WHERE id = :1";

/// SQL statement for request selection
const std::string castor::db::cnv::DbSegmentCnv::s_selectStatementString =
"SELECT fseq, offset, bytes_in, bytes_out, host_bytes, segmCksumAlgorithm, segmCksum, errMsgTxt, errorCode, severity, blockId0, blockId1, blockId2, blockId3, creationTime, priority, id, copy, status, tape FROM Segment WHERE id = :1";

/// SQL statement for bulk request selection
const std::string castor::db::cnv::DbSegmentCnv::s_bulkSelectStatementString =
"DECLARE \
   TYPE RecordType IS RECORD (fseq NUMBER, offset INTEGER, bytes_in INTEGER, bytes_out INTEGER, host_bytes INTEGER, segmCksumAlgorithm VARCHAR2(2048), segmCksum NUMBER, errMsgTxt VARCHAR2(2048), errorCode NUMBER, severity NUMBER, blockId0 INTEGER, blockId1 INTEGER, blockId2 INTEGER, blockId3 INTEGER, creationTime INTEGER, priority INTEGER, id INTEGER, copy INTEGER, status INTEGER, tape INTEGER); \
   TYPE CurType IS REF CURSOR RETURN RecordType; \
   PROCEDURE bulkSelect(ids IN castor.\"cnumList\", \
                        objs OUT CurType) AS \
   BEGIN \
     FORALL i IN ids.FIRST..ids.LAST \
       INSERT INTO bulkSelectHelper VALUES(ids(i)); \
     OPEN objs FOR SELECT fseq, offset, bytes_in, bytes_out, host_bytes, segmCksumAlgorithm, segmCksum, errMsgTxt, errorCode, severity, blockId0, blockId1, blockId2, blockId3, creationTime, priority, id, copy, status, tape \
                     FROM Segment t, bulkSelectHelper h \
                    WHERE t.id = h.objId; \
     DELETE FROM bulkSelectHelper; \
   END; \
 BEGIN \
   bulkSelect(:1, :2); \
 END;";

/// SQL statement for request update
const std::string castor::db::cnv::DbSegmentCnv::s_updateStatementString =
"UPDATE Segment SET fseq = :1, offset = :2, bytes_in = :3, bytes_out = :4, host_bytes = :5, segmCksumAlgorithm = :6, segmCksum = :7, errMsgTxt = :8, errorCode = :9, severity = :10, blockId0 = :11, blockId1 = :12, blockId2 = :13, blockId3 = :14, priority = :15, status = :16 WHERE id = :17";

/// SQL statement for type storage
const std::string castor::db::cnv::DbSegmentCnv::s_storeTypeStatementString =
"INSERT /* Segment class */ INTO Id2Type (id, type) VALUES (:1, :2)";

/// SQL statement for type deletion
const std::string castor::db::cnv::DbSegmentCnv::s_deleteTypeStatementString =
"DELETE FROM Id2Type WHERE id = :1";

/// SQL existence statement for member copy
const std::string castor::db::cnv::DbSegmentCnv::s_checkTapeCopyExistStatementString =
"SELECT id FROM TapeCopy WHERE id = :1";

/// SQL update statement for member copy
const std::string castor::db::cnv::DbSegmentCnv::s_updateTapeCopyStatementString =
"UPDATE Segment SET copy = :1 WHERE id = :2";

/// SQL existence statement for member tape
const std::string castor::db::cnv::DbSegmentCnv::s_checkTapeExistStatementString =
"SELECT id FROM Tape WHERE id = :1";

/// SQL update statement for member tape
const std::string castor::db::cnv::DbSegmentCnv::s_updateTapeStatementString =
"UPDATE Segment SET tape = :1 WHERE id = :2";

//------------------------------------------------------------------------------
// Constructor
//------------------------------------------------------------------------------
castor::db::cnv::DbSegmentCnv::DbSegmentCnv(castor::ICnvSvc* cnvSvc) :
  DbBaseCnv(cnvSvc),
  m_insertStatement(0),
  m_deleteStatement(0),
  m_selectStatement(0),
  m_bulkSelectStatement(0),
  m_updateStatement(0),
  m_storeTypeStatement(0),
  m_deleteTypeStatement(0),
  m_checkTapeCopyExistStatement(0),
  m_updateTapeCopyStatement(0),
  m_checkTapeExistStatement(0),
  m_updateTapeStatement(0) {}

//------------------------------------------------------------------------------
// Destructor
//------------------------------------------------------------------------------
castor::db::cnv::DbSegmentCnv::~DbSegmentCnv() throw() {
  reset();
}

//------------------------------------------------------------------------------
// reset
//------------------------------------------------------------------------------
void castor::db::cnv::DbSegmentCnv::reset() throw() {
  //Here we attempt to delete the statements correctly
  // If something goes wrong, we just ignore it
  try {
    if(m_insertStatement) delete m_insertStatement;
    if(m_deleteStatement) delete m_deleteStatement;
    if(m_selectStatement) delete m_selectStatement;
    if(m_bulkSelectStatement) delete m_bulkSelectStatement;
    if(m_updateStatement) delete m_updateStatement;
    if(m_storeTypeStatement) delete m_storeTypeStatement;
    if(m_deleteTypeStatement) delete m_deleteTypeStatement;
    if(m_checkTapeCopyExistStatement) delete m_checkTapeCopyExistStatement;
    if(m_updateTapeCopyStatement) delete m_updateTapeCopyStatement;
    if(m_checkTapeExistStatement) delete m_checkTapeExistStatement;
    if(m_updateTapeStatement) delete m_updateTapeStatement;
  } catch (castor::exception::Exception& ignored) {};
  // Now reset all pointers to 0
  m_insertStatement = 0;
  m_deleteStatement = 0;
  m_selectStatement = 0;
  m_bulkSelectStatement = 0;
  m_updateStatement = 0;
  m_storeTypeStatement = 0;
  m_deleteTypeStatement = 0;
  m_checkTapeCopyExistStatement = 0;
  m_updateTapeCopyStatement = 0;
  m_checkTapeExistStatement = 0;
  m_updateTapeStatement = 0;
  // Call upper level reset
  this->DbBaseCnv::reset();
}

//------------------------------------------------------------------------------
// ObjType
//------------------------------------------------------------------------------
unsigned int castor::db::cnv::DbSegmentCnv::ObjType() {
  return castor::stager::Segment::TYPE();
}

//------------------------------------------------------------------------------
// objType
//------------------------------------------------------------------------------
unsigned int castor::db::cnv::DbSegmentCnv::objType() const {
  return ObjType();
}

//------------------------------------------------------------------------------
// fillRep
//------------------------------------------------------------------------------
void castor::db::cnv::DbSegmentCnv::fillRep(castor::IAddress*,
                                            castor::IObject* object,
                                            unsigned int type,
                                            bool endTransaction)
  throw (castor::exception::Exception) {
  castor::stager::Segment* obj = 
    dynamic_cast<castor::stager::Segment*>(object);
  try {
    switch (type) {
    case castor::OBJ_TapeCopy :
      fillRepTapeCopy(obj);
      break;
    case castor::OBJ_Tape :
      fillRepTape(obj);
      break;
    default :
      castor::exception::InvalidArgument ex;
      ex.getMessage() << "fillRep called for type " << type 
                      << " on object of type " << obj->type() 
                      << ". This is meaningless.";
      throw ex;
    }
    if (endTransaction) {
      cnvSvc()->commit();
    }
  } catch (castor::exception::SQLError& e) {
    castor::exception::Internal ex;
    ex.getMessage() << "Error in fillRep for type " << type
                    << std::endl << e.getMessage().str() << std::endl;
    throw ex;
  }
}

//------------------------------------------------------------------------------
// fillRepTapeCopy
//------------------------------------------------------------------------------
void castor::db::cnv::DbSegmentCnv::fillRepTapeCopy(castor::stager::Segment* obj)
  throw (castor::exception::Exception) {
  if (0 != obj->copy()) {
    // Check checkTapeCopyExist statement
    if (0 == m_checkTapeCopyExistStatement) {
      m_checkTapeCopyExistStatement = createStatement(s_checkTapeCopyExistStatementString);
    }
    // retrieve the object from the database
    m_checkTapeCopyExistStatement->setUInt64(1, obj->copy()->id());
    castor::db::IDbResultSet *rset = m_checkTapeCopyExistStatement->executeQuery();
    if (!rset->next()) {
      castor::BaseAddress ad;
      ad.setCnvSvcName("DbCnvSvc");
      ad.setCnvSvcType(castor::SVC_DBCNV);
      cnvSvc()->createRep(&ad, obj->copy(), false);
    }
    // Close resultset
    delete rset;
  }
  // Check update statement
  if (0 == m_updateTapeCopyStatement) {
    m_updateTapeCopyStatement = createStatement(s_updateTapeCopyStatementString);
  }
  // Update local object
  m_updateTapeCopyStatement->setUInt64(1, 0 == obj->copy() ? 0 : obj->copy()->id());
  m_updateTapeCopyStatement->setUInt64(2, obj->id());
  m_updateTapeCopyStatement->execute();
}

//------------------------------------------------------------------------------
// fillRepTape
//------------------------------------------------------------------------------
void castor::db::cnv::DbSegmentCnv::fillRepTape(castor::stager::Segment* obj)
  throw (castor::exception::Exception) {
  if (0 != obj->tape()) {
    // Check checkTapeExist statement
    if (0 == m_checkTapeExistStatement) {
      m_checkTapeExistStatement = createStatement(s_checkTapeExistStatementString);
    }
    // retrieve the object from the database
    m_checkTapeExistStatement->setUInt64(1, obj->tape()->id());
    castor::db::IDbResultSet *rset = m_checkTapeExistStatement->executeQuery();
    if (!rset->next()) {
      castor::BaseAddress ad;
      ad.setCnvSvcName("DbCnvSvc");
      ad.setCnvSvcType(castor::SVC_DBCNV);
      cnvSvc()->createRep(&ad, obj->tape(), false);
    }
    // Close resultset
    delete rset;
  }
  // Check update statement
  if (0 == m_updateTapeStatement) {
    m_updateTapeStatement = createStatement(s_updateTapeStatementString);
  }
  // Update local object
  m_updateTapeStatement->setUInt64(1, 0 == obj->tape() ? 0 : obj->tape()->id());
  m_updateTapeStatement->setUInt64(2, obj->id());
  m_updateTapeStatement->execute();
}

//------------------------------------------------------------------------------
// fillObj
//------------------------------------------------------------------------------
void castor::db::cnv::DbSegmentCnv::fillObj(castor::IAddress*,
                                            castor::IObject* object,
                                            unsigned int type,
                                            bool endTransaction)
  throw (castor::exception::Exception) {
  castor::stager::Segment* obj = 
    dynamic_cast<castor::stager::Segment*>(object);
  switch (type) {
  case castor::OBJ_TapeCopy :
    fillObjTapeCopy(obj);
    break;
  case castor::OBJ_Tape :
    fillObjTape(obj);
    break;
  default :
    castor::exception::InvalidArgument ex;
    ex.getMessage() << "fillObj called on type " << type 
                    << " on object of type " << obj->type() 
                    << ". This is meaningless.";
    throw ex;
  }
  if (endTransaction) {
    cnvSvc()->commit();
  }
}

//------------------------------------------------------------------------------
// fillObjTapeCopy
//------------------------------------------------------------------------------
void castor::db::cnv::DbSegmentCnv::fillObjTapeCopy(castor::stager::Segment* obj)
  throw (castor::exception::Exception) {
  // Check whether the statement is ok
  if (0 == m_selectStatement) {
    m_selectStatement = createStatement(s_selectStatementString);
  }
  // retrieve the object from the database
  m_selectStatement->setUInt64(1, obj->id());
  castor::db::IDbResultSet *rset = m_selectStatement->executeQuery();
  if (!rset->next()) {
    castor::exception::NoEntry ex;
    ex.getMessage() << "No object found for id :" << obj->id();
    throw ex;
  }
  u_signed64 copyId = rset->getInt64(18);
  // Close ResultSet
  delete rset;
  // Check whether something should be deleted
  if (0 != obj->copy() &&
      (0 == copyId ||
       obj->copy()->id() != copyId)) {
    obj->copy()->removeSegments(obj);
    obj->setCopy(0);
  }
  // Update object or create new one
  if (0 != copyId) {
    if (0 == obj->copy()) {
      obj->setCopy
        (dynamic_cast<castor::stager::TapeCopy*>
         (cnvSvc()->getObjFromId(copyId)));
    } else {
      cnvSvc()->updateObj(obj->copy());
    }
    obj->copy()->addSegments(obj);
  }
}

//------------------------------------------------------------------------------
// fillObjTape
//------------------------------------------------------------------------------
void castor::db::cnv::DbSegmentCnv::fillObjTape(castor::stager::Segment* obj)
  throw (castor::exception::Exception) {
  // Check whether the statement is ok
  if (0 == m_selectStatement) {
    m_selectStatement = createStatement(s_selectStatementString);
  }
  // retrieve the object from the database
  m_selectStatement->setUInt64(1, obj->id());
  castor::db::IDbResultSet *rset = m_selectStatement->executeQuery();
  if (!rset->next()) {
    castor::exception::NoEntry ex;
    ex.getMessage() << "No object found for id :" << obj->id();
    throw ex;
  }
  u_signed64 tapeId = rset->getInt64(20);
  // Close ResultSet
  delete rset;
  // Check whether something should be deleted
  if (0 != obj->tape() &&
      (0 == tapeId ||
       obj->tape()->id() != tapeId)) {
    obj->tape()->removeSegments(obj);
    obj->setTape(0);
  }
  // Update object or create new one
  if (0 != tapeId) {
    if (0 == obj->tape()) {
      obj->setTape
        (dynamic_cast<castor::stager::Tape*>
         (cnvSvc()->getObjFromId(tapeId)));
    } else {
      cnvSvc()->updateObj(obj->tape());
    }
    obj->tape()->addSegments(obj);
  }
}

//------------------------------------------------------------------------------
// createRep
//------------------------------------------------------------------------------
void castor::db::cnv::DbSegmentCnv::createRep(castor::IAddress*,
                                              castor::IObject* object,
                                              bool endTransaction,
                                              unsigned int type)
  throw (castor::exception::Exception) {
  castor::stager::Segment* obj = 
    dynamic_cast<castor::stager::Segment*>(object);
  // check whether something needs to be done
  if (0 == obj) return;
  if (0 != obj->id()) return;
  try {
    // Check whether the statements are ok
    if (0 == m_insertStatement) {
      m_insertStatement = createStatement(s_insertStatementString);
      m_insertStatement->registerOutParam(20, castor::db::DBTYPE_UINT64);
    }
    if (0 == m_storeTypeStatement) {
      m_storeTypeStatement = createStatement(s_storeTypeStatementString);
    }
    // Now Save the current object
    m_insertStatement->setInt(1, obj->fseq());
    m_insertStatement->setUInt64(2, obj->offset());
    m_insertStatement->setUInt64(3, obj->bytes_in());
    m_insertStatement->setUInt64(4, obj->bytes_out());
    m_insertStatement->setUInt64(5, obj->host_bytes());
    m_insertStatement->setString(6, obj->segmCksumAlgorithm());
    m_insertStatement->setInt(7, obj->segmCksum());
    m_insertStatement->setString(8, obj->errMsgTxt());
    m_insertStatement->setInt(9, obj->errorCode());
    m_insertStatement->setInt(10, obj->severity());
    m_insertStatement->setInt(11, obj->blockId0());
    m_insertStatement->setInt(12, obj->blockId1());
    m_insertStatement->setInt(13, obj->blockId2());
    m_insertStatement->setInt(14, obj->blockId3());
    m_insertStatement->setInt(15, time(0));
    m_insertStatement->setUInt64(16, obj->priority());
    m_insertStatement->setUInt64(17, (type == OBJ_TapeCopy && obj->copy() != 0) ? obj->copy()->id() : 0);
    m_insertStatement->setInt(18, (int)obj->status());
    m_insertStatement->setUInt64(19, (type == OBJ_Tape && obj->tape() != 0) ? obj->tape()->id() : 0);
    m_insertStatement->execute();
    obj->setId(m_insertStatement->getUInt64(20));
    m_storeTypeStatement->setUInt64(1, obj->id());
    m_storeTypeStatement->setUInt64(2, obj->type());
    m_storeTypeStatement->execute();
    if (endTransaction) {
      cnvSvc()->commit();
    }
  } catch (castor::exception::SQLError& e) {
    // Always try to rollback
    try {
      if (endTransaction) cnvSvc()->rollback();
    } catch (castor::exception::Exception& ignored) {}
    castor::exception::InvalidArgument ex;
    ex.getMessage() << "Error in insert request :"
                    << std::endl << e.getMessage().str() << std::endl
                    << "Statement was : " << std::endl
                    << s_insertStatementString << std::endl
                    << " and parameters' values were :" << std::endl
                    << "  fseq : " << obj->fseq() << std::endl
                    << "  offset : " << obj->offset() << std::endl
                    << "  bytes_in : " << obj->bytes_in() << std::endl
                    << "  bytes_out : " << obj->bytes_out() << std::endl
                    << "  host_bytes : " << obj->host_bytes() << std::endl
                    << "  segmCksumAlgorithm : " << obj->segmCksumAlgorithm() << std::endl
                    << "  segmCksum : " << obj->segmCksum() << std::endl
                    << "  errMsgTxt : " << obj->errMsgTxt() << std::endl
                    << "  errorCode : " << obj->errorCode() << std::endl
                    << "  severity : " << obj->severity() << std::endl
                    << "  blockId0 : " << obj->blockId0() << std::endl
                    << "  blockId1 : " << obj->blockId1() << std::endl
                    << "  blockId2 : " << obj->blockId2() << std::endl
                    << "  blockId3 : " << obj->blockId3() << std::endl
                    << "  creationTime : " << obj->creationTime() << std::endl
                    << "  priority : " << obj->priority() << std::endl
                    << "  id : " << obj->id() << std::endl
                    << "  copy : " << (obj->copy() ? obj->copy()->id() : 0) << std::endl
                    << "  status : " << obj->status() << std::endl
                    << "  tape : " << (obj->tape() ? obj->tape()->id() : 0) << std::endl;
    throw ex;
  }
}

//------------------------------------------------------------------------------
// bulkCreateRep
//------------------------------------------------------------------------------
void castor::db::cnv::DbSegmentCnv::bulkCreateRep(castor::IAddress*,
                                                  std::vector<castor::IObject*> &objects,
                                                  bool endTransaction,
                                                  unsigned int type)
  throw (castor::exception::Exception) {
  // check whether something needs to be done
  int nb = objects.size();
  if (0 == nb) return;
  // Casts all objects
  std::vector<castor::stager::Segment*> objs;
  for (int i = 0; i < nb; i++) {
    objs.push_back(dynamic_cast<castor::stager::Segment*>(objects[i]));
  }
  std::vector<void *> allocMem;
  try {
    // Check whether the statements are ok
    if (0 == m_insertStatement) {
      m_insertStatement = createStatement(s_insertStatementString);
      m_insertStatement->registerOutParam(20, castor::db::DBTYPE_UINT64);
    }
    if (0 == m_storeTypeStatement) {
      m_storeTypeStatement = createStatement(s_storeTypeStatementString);
    }
    // build the buffers for fseq
    int* fseqBuffer = (int*) malloc(nb * sizeof(int));
    if (fseqBuffer == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(fseqBuffer);
    unsigned short* fseqBufLens = (unsigned short*) malloc(nb * sizeof(unsigned short));
    if (fseqBufLens == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(fseqBufLens);
    for (int i = 0; i < nb; i++) {
      fseqBuffer[i] = objs[i]->fseq();
      fseqBufLens[i] = sizeof(int);
    }
    m_insertStatement->setDataBuffer
      (1, fseqBuffer, castor::db::DBTYPE_INT, sizeof(fseqBuffer[0]), fseqBufLens);
    // build the buffers for offset
    double* offsetBuffer = (double*) malloc(nb * sizeof(double));
    if (offsetBuffer == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(offsetBuffer);
    unsigned short* offsetBufLens = (unsigned short*) malloc(nb * sizeof(unsigned short));
    if (offsetBufLens == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(offsetBufLens);
    for (int i = 0; i < nb; i++) {
      offsetBuffer[i] = objs[i]->offset();
      offsetBufLens[i] = sizeof(double);
    }
    m_insertStatement->setDataBuffer
      (2, offsetBuffer, castor::db::DBTYPE_UINT64, sizeof(offsetBuffer[0]), offsetBufLens);
    // build the buffers for bytes_in
    double* bytes_inBuffer = (double*) malloc(nb * sizeof(double));
    if (bytes_inBuffer == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(bytes_inBuffer);
    unsigned short* bytes_inBufLens = (unsigned short*) malloc(nb * sizeof(unsigned short));
    if (bytes_inBufLens == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(bytes_inBufLens);
    for (int i = 0; i < nb; i++) {
      bytes_inBuffer[i] = objs[i]->bytes_in();
      bytes_inBufLens[i] = sizeof(double);
    }
    m_insertStatement->setDataBuffer
      (3, bytes_inBuffer, castor::db::DBTYPE_UINT64, sizeof(bytes_inBuffer[0]), bytes_inBufLens);
    // build the buffers for bytes_out
    double* bytes_outBuffer = (double*) malloc(nb * sizeof(double));
    if (bytes_outBuffer == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(bytes_outBuffer);
    unsigned short* bytes_outBufLens = (unsigned short*) malloc(nb * sizeof(unsigned short));
    if (bytes_outBufLens == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(bytes_outBufLens);
    for (int i = 0; i < nb; i++) {
      bytes_outBuffer[i] = objs[i]->bytes_out();
      bytes_outBufLens[i] = sizeof(double);
    }
    m_insertStatement->setDataBuffer
      (4, bytes_outBuffer, castor::db::DBTYPE_UINT64, sizeof(bytes_outBuffer[0]), bytes_outBufLens);
    // build the buffers for host_bytes
    double* host_bytesBuffer = (double*) malloc(nb * sizeof(double));
    if (host_bytesBuffer == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(host_bytesBuffer);
    unsigned short* host_bytesBufLens = (unsigned short*) malloc(nb * sizeof(unsigned short));
    if (host_bytesBufLens == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(host_bytesBufLens);
    for (int i = 0; i < nb; i++) {
      host_bytesBuffer[i] = objs[i]->host_bytes();
      host_bytesBufLens[i] = sizeof(double);
    }
    m_insertStatement->setDataBuffer
      (5, host_bytesBuffer, castor::db::DBTYPE_UINT64, sizeof(host_bytesBuffer[0]), host_bytesBufLens);
    // build the buffers for segmCksumAlgorithm
    unsigned int segmCksumAlgorithmMaxLen = 0;
    for (int i = 0; i < nb; i++) {
      if (objs[i]->segmCksumAlgorithm().length()+1 > segmCksumAlgorithmMaxLen)
        segmCksumAlgorithmMaxLen = objs[i]->segmCksumAlgorithm().length()+1;
    }
    char* segmCksumAlgorithmBuffer = (char*) calloc(nb, segmCksumAlgorithmMaxLen);
    if (segmCksumAlgorithmBuffer == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(segmCksumAlgorithmBuffer);
    unsigned short* segmCksumAlgorithmBufLens = (unsigned short*) malloc(nb * sizeof(unsigned short));
    if (segmCksumAlgorithmBufLens == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(segmCksumAlgorithmBufLens);
    for (int i = 0; i < nb; i++) {
      strncpy(segmCksumAlgorithmBuffer+(i*segmCksumAlgorithmMaxLen), objs[i]->segmCksumAlgorithm().c_str(), segmCksumAlgorithmMaxLen);
      segmCksumAlgorithmBufLens[i] = objs[i]->segmCksumAlgorithm().length()+1; // + 1 for the trailing \0
    }
    m_insertStatement->setDataBuffer
      (6, segmCksumAlgorithmBuffer, castor::db::DBTYPE_STRING, segmCksumAlgorithmMaxLen, segmCksumAlgorithmBufLens);
    // build the buffers for segmCksum
    long* segmCksumBuffer = (long*) malloc(nb * sizeof(long));
    if (segmCksumBuffer == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(segmCksumBuffer);
    unsigned short* segmCksumBufLens = (unsigned short*) malloc(nb * sizeof(unsigned short));
    if (segmCksumBufLens == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(segmCksumBufLens);
    for (int i = 0; i < nb; i++) {
      segmCksumBuffer[i] = objs[i]->segmCksum();
      segmCksumBufLens[i] = sizeof(long);
    }
    m_insertStatement->setDataBuffer
      (7, segmCksumBuffer, castor::db::DBTYPE_INT, sizeof(segmCksumBuffer[0]), segmCksumBufLens);
    // build the buffers for errMsgTxt
    unsigned int errMsgTxtMaxLen = 0;
    for (int i = 0; i < nb; i++) {
      if (objs[i]->errMsgTxt().length()+1 > errMsgTxtMaxLen)
        errMsgTxtMaxLen = objs[i]->errMsgTxt().length()+1;
    }
    char* errMsgTxtBuffer = (char*) calloc(nb, errMsgTxtMaxLen);
    if (errMsgTxtBuffer == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(errMsgTxtBuffer);
    unsigned short* errMsgTxtBufLens = (unsigned short*) malloc(nb * sizeof(unsigned short));
    if (errMsgTxtBufLens == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(errMsgTxtBufLens);
    for (int i = 0; i < nb; i++) {
      strncpy(errMsgTxtBuffer+(i*errMsgTxtMaxLen), objs[i]->errMsgTxt().c_str(), errMsgTxtMaxLen);
      errMsgTxtBufLens[i] = objs[i]->errMsgTxt().length()+1; // + 1 for the trailing \0
    }
    m_insertStatement->setDataBuffer
      (8, errMsgTxtBuffer, castor::db::DBTYPE_STRING, errMsgTxtMaxLen, errMsgTxtBufLens);
    // build the buffers for errorCode
    int* errorCodeBuffer = (int*) malloc(nb * sizeof(int));
    if (errorCodeBuffer == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(errorCodeBuffer);
    unsigned short* errorCodeBufLens = (unsigned short*) malloc(nb * sizeof(unsigned short));
    if (errorCodeBufLens == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(errorCodeBufLens);
    for (int i = 0; i < nb; i++) {
      errorCodeBuffer[i] = objs[i]->errorCode();
      errorCodeBufLens[i] = sizeof(int);
    }
    m_insertStatement->setDataBuffer
      (9, errorCodeBuffer, castor::db::DBTYPE_INT, sizeof(errorCodeBuffer[0]), errorCodeBufLens);
    // build the buffers for severity
    int* severityBuffer = (int*) malloc(nb * sizeof(int));
    if (severityBuffer == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(severityBuffer);
    unsigned short* severityBufLens = (unsigned short*) malloc(nb * sizeof(unsigned short));
    if (severityBufLens == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(severityBufLens);
    for (int i = 0; i < nb; i++) {
      severityBuffer[i] = objs[i]->severity();
      severityBufLens[i] = sizeof(int);
    }
    m_insertStatement->setDataBuffer
      (10, severityBuffer, castor::db::DBTYPE_INT, sizeof(severityBuffer[0]), severityBufLens);
    // build the buffers for blockId0
    unsigned char* blockId0Buffer = (unsigned char*) malloc(nb * sizeof(unsigned char));
    if (blockId0Buffer == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(blockId0Buffer);
    unsigned short* blockId0BufLens = (unsigned short*) malloc(nb * sizeof(unsigned short));
    if (blockId0BufLens == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(blockId0BufLens);
    for (int i = 0; i < nb; i++) {
      blockId0Buffer[i] = objs[i]->blockId0();
      blockId0BufLens[i] = sizeof(unsigned char);
    }
    m_insertStatement->setDataBuffer
      (11, blockId0Buffer, castor::db::DBTYPE_INT, sizeof(blockId0Buffer[0]), blockId0BufLens);
    // build the buffers for blockId1
    unsigned char* blockId1Buffer = (unsigned char*) malloc(nb * sizeof(unsigned char));
    if (blockId1Buffer == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(blockId1Buffer);
    unsigned short* blockId1BufLens = (unsigned short*) malloc(nb * sizeof(unsigned short));
    if (blockId1BufLens == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(blockId1BufLens);
    for (int i = 0; i < nb; i++) {
      blockId1Buffer[i] = objs[i]->blockId1();
      blockId1BufLens[i] = sizeof(unsigned char);
    }
    m_insertStatement->setDataBuffer
      (12, blockId1Buffer, castor::db::DBTYPE_INT, sizeof(blockId1Buffer[0]), blockId1BufLens);
    // build the buffers for blockId2
    unsigned char* blockId2Buffer = (unsigned char*) malloc(nb * sizeof(unsigned char));
    if (blockId2Buffer == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(blockId2Buffer);
    unsigned short* blockId2BufLens = (unsigned short*) malloc(nb * sizeof(unsigned short));
    if (blockId2BufLens == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(blockId2BufLens);
    for (int i = 0; i < nb; i++) {
      blockId2Buffer[i] = objs[i]->blockId2();
      blockId2BufLens[i] = sizeof(unsigned char);
    }
    m_insertStatement->setDataBuffer
      (13, blockId2Buffer, castor::db::DBTYPE_INT, sizeof(blockId2Buffer[0]), blockId2BufLens);
    // build the buffers for blockId3
    unsigned char* blockId3Buffer = (unsigned char*) malloc(nb * sizeof(unsigned char));
    if (blockId3Buffer == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(blockId3Buffer);
    unsigned short* blockId3BufLens = (unsigned short*) malloc(nb * sizeof(unsigned short));
    if (blockId3BufLens == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(blockId3BufLens);
    for (int i = 0; i < nb; i++) {
      blockId3Buffer[i] = objs[i]->blockId3();
      blockId3BufLens[i] = sizeof(unsigned char);
    }
    m_insertStatement->setDataBuffer
      (14, blockId3Buffer, castor::db::DBTYPE_INT, sizeof(blockId3Buffer[0]), blockId3BufLens);
    // build the buffers for creationTime
    double* creationTimeBuffer = (double*) malloc(nb * sizeof(double));
    if (creationTimeBuffer == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(creationTimeBuffer);
    unsigned short* creationTimeBufLens = (unsigned short*) malloc(nb * sizeof(unsigned short));
    if (creationTimeBufLens == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(creationTimeBufLens);
    for (int i = 0; i < nb; i++) {
      creationTimeBuffer[i] = time(0);
      creationTimeBufLens[i] = sizeof(double);
    }
    m_insertStatement->setDataBuffer
      (15, creationTimeBuffer, castor::db::DBTYPE_UINT64, sizeof(creationTimeBuffer[0]), creationTimeBufLens);
    // build the buffers for priority
    double* priorityBuffer = (double*) malloc(nb * sizeof(double));
    if (priorityBuffer == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(priorityBuffer);
    unsigned short* priorityBufLens = (unsigned short*) malloc(nb * sizeof(unsigned short));
    if (priorityBufLens == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(priorityBufLens);
    for (int i = 0; i < nb; i++) {
      priorityBuffer[i] = objs[i]->priority();
      priorityBufLens[i] = sizeof(double);
    }
    m_insertStatement->setDataBuffer
      (16, priorityBuffer, castor::db::DBTYPE_UINT64, sizeof(priorityBuffer[0]), priorityBufLens);
    // build the buffers for copy
    double* copyBuffer = (double*) malloc(nb * sizeof(double));
    if (copyBuffer == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(copyBuffer);
    unsigned short* copyBufLens = (unsigned short*) malloc(nb * sizeof(unsigned short));
    if (copyBufLens == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(copyBufLens);
    for (int i = 0; i < nb; i++) {
      copyBuffer[i] = (type == OBJ_TapeCopy && objs[i]->copy() != 0) ? objs[i]->copy()->id() : 0;
      copyBufLens[i] = sizeof(double);
    }
    m_insertStatement->setDataBuffer
      (17, copyBuffer, castor::db::DBTYPE_UINT64, sizeof(copyBuffer[0]), copyBufLens);
    // build the buffers for status
    int* statusBuffer = (int*) malloc(nb * sizeof(int));
    if (statusBuffer == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(statusBuffer);
    unsigned short* statusBufLens = (unsigned short*) malloc(nb * sizeof(unsigned short));
    if (statusBufLens == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(statusBufLens);
    for (int i = 0; i < nb; i++) {
      statusBuffer[i] = objs[i]->status();
      statusBufLens[i] = sizeof(int);
    }
    m_insertStatement->setDataBuffer
      (18, statusBuffer, castor::db::DBTYPE_INT, sizeof(statusBuffer[0]), statusBufLens);
    // build the buffers for tape
    double* tapeBuffer = (double*) malloc(nb * sizeof(double));
    if (tapeBuffer == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(tapeBuffer);
    unsigned short* tapeBufLens = (unsigned short*) malloc(nb * sizeof(unsigned short));
    if (tapeBufLens == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(tapeBufLens);
    for (int i = 0; i < nb; i++) {
      tapeBuffer[i] = (type == OBJ_Tape && objs[i]->tape() != 0) ? objs[i]->tape()->id() : 0;
      tapeBufLens[i] = sizeof(double);
    }
    m_insertStatement->setDataBuffer
      (19, tapeBuffer, castor::db::DBTYPE_UINT64, sizeof(tapeBuffer[0]), tapeBufLens);
    // build the buffers for returned ids
    double* idBuffer = (double*) calloc(nb, sizeof(double));
    if (idBuffer == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(idBuffer);
    unsigned short* idBufLens = (unsigned short*) calloc(nb, sizeof(unsigned short));
    if (idBufLens == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(idBufLens);
    m_insertStatement->setDataBuffer
      (20, idBuffer, castor::db::DBTYPE_UINT64, sizeof(double), idBufLens);
    m_insertStatement->execute(nb);
    for (int i = 0; i < nb; i++) {
      objects[i]->setId((u_signed64)idBuffer[i]);
    }
    // reuse idBuffer for bulk insertion into Id2Type
    m_storeTypeStatement->setDataBuffer
      (1, idBuffer, castor::db::DBTYPE_UINT64, sizeof(idBuffer[0]), idBufLens);
    // build the buffers for type
    int* typeBuffer = (int*) malloc(nb * sizeof(int));
    if (typeBuffer == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(typeBuffer);
    unsigned short* typeBufLens = (unsigned short*) malloc(nb * sizeof(unsigned short));
    if (typeBufLens == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(typeBufLens);
    for (int i = 0; i < nb; i++) {
      typeBuffer[i] = objs[i]->type();
      typeBufLens[i] = sizeof(int);
    }
    m_storeTypeStatement->setDataBuffer
      (2, typeBuffer, castor::db::DBTYPE_INT, sizeof(typeBuffer[0]), typeBufLens);
    m_storeTypeStatement->execute(nb);
    // release the buffers
    for (unsigned int i = 0; i < allocMem.size(); i++) {
      free(allocMem[i]);
    }
    if (endTransaction) {
      cnvSvc()->commit();
    }
  } catch (castor::exception::SQLError& e) {
    // release the buffers
    for (unsigned int i = 0; i < allocMem.size(); i++) {
      free(allocMem[i]);
    }
    // Always try to rollback
    try {
      if (endTransaction) cnvSvc()->rollback();
    } catch (castor::exception::Exception& ignored) {}
    castor::exception::InvalidArgument ex;
    ex.getMessage() << "Error in bulkInsert request :"
                    << std::endl << e.getMessage().str() << std::endl
                    << " was called in bulk with "
                    << nb << " items." << std::endl;
    throw ex;
  }
}

//------------------------------------------------------------------------------
// updateRep
//------------------------------------------------------------------------------
void castor::db::cnv::DbSegmentCnv::updateRep(castor::IAddress*,
                                              castor::IObject* object,
                                              bool endTransaction)
  throw (castor::exception::Exception) {
  castor::stager::Segment* obj = 
    dynamic_cast<castor::stager::Segment*>(object);
  // check whether something needs to be done
  if (0 == obj) return;
  try {
    // Check whether the statements are ok
    if (0 == m_updateStatement) {
      m_updateStatement = createStatement(s_updateStatementString);
    }
    // Update the current object
    m_updateStatement->setInt(1, obj->fseq());
    m_updateStatement->setUInt64(2, obj->offset());
    m_updateStatement->setUInt64(3, obj->bytes_in());
    m_updateStatement->setUInt64(4, obj->bytes_out());
    m_updateStatement->setUInt64(5, obj->host_bytes());
    m_updateStatement->setString(6, obj->segmCksumAlgorithm());
    m_updateStatement->setInt(7, obj->segmCksum());
    m_updateStatement->setString(8, obj->errMsgTxt());
    m_updateStatement->setInt(9, obj->errorCode());
    m_updateStatement->setInt(10, obj->severity());
    m_updateStatement->setInt(11, obj->blockId0());
    m_updateStatement->setInt(12, obj->blockId1());
    m_updateStatement->setInt(13, obj->blockId2());
    m_updateStatement->setInt(14, obj->blockId3());
    m_updateStatement->setUInt64(15, obj->priority());
    m_updateStatement->setInt(16, (int)obj->status());
    m_updateStatement->setUInt64(17, obj->id());
    m_updateStatement->execute();
    if (endTransaction) {
      cnvSvc()->commit();
    }
  } catch (castor::exception::SQLError& e) {
    // Always try to rollback
    try {
      if (endTransaction) cnvSvc()->rollback();
    } catch (castor::exception::Exception& ignored) {}
    castor::exception::InvalidArgument ex;
    ex.getMessage() << "Error in update request :"
                    << std::endl << e.getMessage().str() << std::endl
                    << "Statement was : " << std::endl
                    << s_updateStatementString << std::endl
                    << " and id was " << obj->id() << std::endl;;
    throw ex;
  }
}

//------------------------------------------------------------------------------
// deleteRep
//------------------------------------------------------------------------------
void castor::db::cnv::DbSegmentCnv::deleteRep(castor::IAddress*,
                                              castor::IObject* object,
                                              bool endTransaction)
  throw (castor::exception::Exception) {
  castor::stager::Segment* obj = 
    dynamic_cast<castor::stager::Segment*>(object);
  // check whether something needs to be done
  if (0 == obj) return;
  try {
    // Check whether the statements are ok
    if (0 == m_deleteStatement) {
      m_deleteStatement = createStatement(s_deleteStatementString);
    }
    if (0 == m_deleteTypeStatement) {
      m_deleteTypeStatement = createStatement(s_deleteTypeStatementString);
    }
    // Now Delete the object
    m_deleteTypeStatement->setUInt64(1, obj->id());
    m_deleteTypeStatement->execute();
    m_deleteStatement->setUInt64(1, obj->id());
    m_deleteStatement->execute();
    if (endTransaction) {
      cnvSvc()->commit();
    }
  } catch (castor::exception::SQLError& e) {
    // Always try to rollback
    try {
      if (endTransaction) cnvSvc()->rollback();
    } catch (castor::exception::Exception& ignored) {}
    castor::exception::InvalidArgument ex;
    ex.getMessage() << "Error in delete request :"
                    << std::endl << e.getMessage().str() << std::endl
                    << "Statement was : " << std::endl
                    << s_deleteStatementString << std::endl
                    << " and id was " << obj->id() << std::endl;;
    throw ex;
  }
}

//------------------------------------------------------------------------------
// createObj
//------------------------------------------------------------------------------
castor::IObject* castor::db::cnv::DbSegmentCnv::createObj(castor::IAddress* address)
  throw (castor::exception::Exception) {
  castor::BaseAddress* ad = 
    dynamic_cast<castor::BaseAddress*>(address);
  try {
    // Check whether the statement is ok
    if (0 == m_selectStatement) {
      m_selectStatement = createStatement(s_selectStatementString);
    }
    // retrieve the object from the database
    m_selectStatement->setUInt64(1, ad->target());
    castor::db::IDbResultSet *rset = m_selectStatement->executeQuery();
    if (!rset->next()) {
      castor::exception::NoEntry ex;
      ex.getMessage() << "No object found for id :" << ad->target();
      throw ex;
    }
    // create the new Object
    castor::stager::Segment* object = new castor::stager::Segment();
    // Now retrieve and set members
    object->setFseq(rset->getInt(1));
    object->setOffset(rset->getUInt64(2));
    object->setBytes_in(rset->getUInt64(3));
    object->setBytes_out(rset->getUInt64(4));
    object->setHost_bytes(rset->getUInt64(5));
    object->setSegmCksumAlgorithm(rset->getString(6));
    object->setSegmCksum(rset->getInt(7));
    object->setErrMsgTxt(rset->getString(8));
    object->setErrorCode(rset->getInt(9));
    object->setSeverity(rset->getInt(10));
    object->setBlockId0(rset->getInt(11));
    object->setBlockId1(rset->getInt(12));
    object->setBlockId2(rset->getInt(13));
    object->setBlockId3(rset->getInt(14));
    object->setCreationTime(rset->getUInt64(15));
    object->setPriority(rset->getUInt64(16));
    object->setId(rset->getUInt64(17));
    object->setStatus((enum castor::stager::SegmentStatusCodes)rset->getInt(19));
    delete rset;
    return object;
  } catch (castor::exception::SQLError& e) {
    castor::exception::InvalidArgument ex;
    ex.getMessage() << "Error in select request :"
                    << std::endl << e.getMessage().str() << std::endl
                    << "Statement was : " << std::endl
                    << s_selectStatementString << std::endl
                    << " and id was " << ad->target() << std::endl;;
    throw ex;
  }
}

//------------------------------------------------------------------------------
// bulkCreateObj
//------------------------------------------------------------------------------
std::vector<castor::IObject*>
castor::db::cnv::DbSegmentCnv::bulkCreateObj(castor::IAddress* address)
  throw (castor::exception::Exception) {
  // Prepare result
  std::vector<castor::IObject*> res;
  // check whether something needs to be done
  castor::VectorAddress* ad = 
    dynamic_cast<castor::VectorAddress*>(address);
  int nb = ad->target().size();
  if (0 == nb) return res;
  try {
    // Check whether the statement is ok
    if (0 == m_bulkSelectStatement) {
      m_bulkSelectStatement = createStatement(s_bulkSelectStatementString);
      m_bulkSelectStatement->registerOutParam(2, castor::db::DBTYPE_CURSOR);
    }
    // set the buffer for input ids
    m_bulkSelectStatement->setDataBufferUInt64Array(1, ad->target());
    // Execute statement
    m_bulkSelectStatement->execute();
    // get the result, that is a cursor on the selected rows
    castor::db::IDbResultSet *rset =
      m_bulkSelectStatement->getCursor(2);
    // loop and create the new objects
    bool status = rset->next();
    while (status) {
      // create the new Object
      castor::stager::Segment* object = new castor::stager::Segment();
      // Now retrieve and set members
      object->setFseq(rset->getInt(1));
      object->setOffset(rset->getUInt64(2));
      object->setBytes_in(rset->getUInt64(3));
      object->setBytes_out(rset->getUInt64(4));
      object->setHost_bytes(rset->getUInt64(5));
      object->setSegmCksumAlgorithm(rset->getString(6));
      object->setSegmCksum(rset->getInt(7));
      object->setErrMsgTxt(rset->getString(8));
      object->setErrorCode(rset->getInt(9));
      object->setSeverity(rset->getInt(10));
      object->setBlockId0(rset->getInt(11));
      object->setBlockId1(rset->getInt(12));
      object->setBlockId2(rset->getInt(13));
      object->setBlockId3(rset->getInt(14));
      object->setCreationTime(rset->getUInt64(15));
      object->setPriority(rset->getUInt64(16));
      object->setId(rset->getUInt64(17));
      object->setStatus((enum castor::stager::SegmentStatusCodes)rset->getInt(19));
      // store object in results and loop;
      res.push_back(object);
      status = rset->next();
    }
    delete rset;
    return res;
  } catch (castor::exception::SQLError& e) {
    castor::exception::InvalidArgument ex;
    ex.getMessage() << "Error in bulkSelect request :"
                    << std::endl << e.getMessage().str() << std::endl
                    << " was called in bulk with "
                    << nb << " items." << std::endl;
    throw ex;
  }
}

//------------------------------------------------------------------------------
// updateObj
//------------------------------------------------------------------------------
void castor::db::cnv::DbSegmentCnv::updateObj(castor::IObject* obj)
  throw (castor::exception::Exception) {
  try {
    // Check whether the statement is ok
    if (0 == m_selectStatement) {
      m_selectStatement = createStatement(s_selectStatementString);
    }
    // retrieve the object from the database
    m_selectStatement->setUInt64(1, obj->id());
    castor::db::IDbResultSet *rset = m_selectStatement->executeQuery();
    if (!rset->next()) {
      castor::exception::NoEntry ex;
      ex.getMessage() << "No object found for id :" << obj->id();
      throw ex;
    }
    // Now retrieve and set members
    castor::stager::Segment* object = 
      dynamic_cast<castor::stager::Segment*>(obj);
    object->setFseq(rset->getInt(1));
    object->setOffset(rset->getUInt64(2));
    object->setBytes_in(rset->getUInt64(3));
    object->setBytes_out(rset->getUInt64(4));
    object->setHost_bytes(rset->getUInt64(5));
    object->setSegmCksumAlgorithm(rset->getString(6));
    object->setSegmCksum(rset->getInt(7));
    object->setErrMsgTxt(rset->getString(8));
    object->setErrorCode(rset->getInt(9));
    object->setSeverity(rset->getInt(10));
    object->setBlockId0(rset->getInt(11));
    object->setBlockId1(rset->getInt(12));
    object->setBlockId2(rset->getInt(13));
    object->setBlockId3(rset->getInt(14));
    object->setCreationTime(rset->getUInt64(15));
    object->setPriority(rset->getUInt64(16));
    object->setId(rset->getUInt64(17));
    object->setStatus((enum castor::stager::SegmentStatusCodes)rset->getInt(19));
    delete rset;
  } catch (castor::exception::SQLError& e) {
    castor::exception::InvalidArgument ex;
    ex.getMessage() << "Error in update request :"
                    << std::endl << e.getMessage().str() << std::endl
                    << "Statement was : " << std::endl
                    << s_updateStatementString << std::endl
                    << " and id was " << obj->id() << std::endl;;
    throw ex;
  }
}

