/**** This file has been autogenerated by gencastor from Umbrello UML model ***/

/******************************************************************************
 *                      castor/db/cnv/DbTapeRequestCnv.cpp
 *
 * This file is part of the Castor project.
 * See http://castor.web.cern.ch/castor
 *
 * Copyright (C) 2003  CERN
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 *
 * @author Castor Dev team, castor-dev@cern.ch
 *****************************************************************************/

// Include Files
#include "DbTapeRequestCnv.hpp"
#include "castor/BaseAddress.hpp"
#include "castor/CnvFactory.hpp"
#include "castor/Constants.hpp"
#include "castor/IAddress.hpp"
#include "castor/ICnvSvc.hpp"
#include "castor/IObject.hpp"
#include "castor/VectorAddress.hpp"
#include "castor/db/DbCnvSvc.hpp"
#include "castor/exception/Exception.hpp"
#include "castor/exception/Internal.hpp"
#include "castor/exception/InvalidArgument.hpp"
#include "castor/exception/NoEntry.hpp"
#include "castor/exception/OutOfMemory.hpp"
#include "castor/vdqm/ClientIdentification.hpp"
#include "castor/vdqm/DeviceGroupName.hpp"
#include "castor/vdqm/TapeAccessSpecification.hpp"
#include "castor/vdqm/TapeDrive.hpp"
#include "castor/vdqm/TapeRequest.hpp"
#include "castor/vdqm/TapeRequestStatusCodes.hpp"
#include "castor/vdqm/TapeServer.hpp"
#include "castor/vdqm/VdqmTape.hpp"
#include <stdlib.h>
#include <vector>

//------------------------------------------------------------------------------
// Instantiation of a static factory class - should never be used
//------------------------------------------------------------------------------
static castor::CnvFactory<castor::db::cnv::DbTapeRequestCnv>* s_factoryDbTapeRequestCnv =
  new castor::CnvFactory<castor::db::cnv::DbTapeRequestCnv>();

//------------------------------------------------------------------------------
// Static constants initialization
//------------------------------------------------------------------------------
/// SQL statement for request insertion
const std::string castor::db::cnv::DbTapeRequestCnv::s_insertStatementString =
"INSERT INTO TapeRequest (priority, modificationTime, creationTime, errorCode, errorMessage, remoteCopyType, id, tape, tapeAccessSpecification, requestedSrv, tapeDrive, deviceGroupName, status, client) VALUES (:1,:2,:3,:4,:5,:6,ids_seq.nextval,:7,:8,:9,:10,:11,:12,:13) RETURNING id INTO :14";

/// SQL statement for request deletion
const std::string castor::db::cnv::DbTapeRequestCnv::s_deleteStatementString =
"DELETE FROM TapeRequest WHERE id = :1";

/// SQL statement for request selection
const std::string castor::db::cnv::DbTapeRequestCnv::s_selectStatementString =
"SELECT priority, modificationTime, creationTime, errorCode, errorMessage, remoteCopyType, id, tape, tapeAccessSpecification, requestedSrv, tapeDrive, deviceGroupName, status, client FROM TapeRequest WHERE id = :1";

/// SQL statement for bulk request selection
const std::string castor::db::cnv::DbTapeRequestCnv::s_bulkSelectStatementString =
"DECLARE \
   TYPE RecordType IS RECORD (priority NUMBER, modificationTime INTEGER, creationTime INTEGER, errorCode NUMBER, errorMessage VARCHAR2(2048), remoteCopyType VARCHAR2(2048), id INTEGER, tape INTEGER, tapeAccessSpecification INTEGER, requestedSrv INTEGER, tapeDrive INTEGER, deviceGroupName INTEGER, status INTEGER, client INTEGER); \
   TYPE CurType IS REF CURSOR RETURN RecordType; \
   PROCEDURE bulkSelect(ids IN castor.\"cnumList\", \
                        objs OUT CurType) AS \
   BEGIN \
     FORALL i IN ids.FIRST..ids.LAST \
       INSERT INTO bulkSelectHelper VALUES(ids(i)); \
     OPEN objs FOR SELECT priority, modificationTime, creationTime, errorCode, errorMessage, remoteCopyType, id, tape, tapeAccessSpecification, requestedSrv, tapeDrive, deviceGroupName, status, client \
                     FROM TapeRequest t, bulkSelectHelper h \
                    WHERE t.id = h.objId; \
     DELETE FROM bulkSelectHelper; \
   END; \
 BEGIN \
   bulkSelect(:1, :2); \
 END;";

/// SQL statement for request update
const std::string castor::db::cnv::DbTapeRequestCnv::s_updateStatementString =
"UPDATE TapeRequest SET priority = :1, modificationTime = :2, errorCode = :3, errorMessage = :4, remoteCopyType = :5, status = :6 WHERE id = :7";

/// SQL statement for type storage
const std::string castor::db::cnv::DbTapeRequestCnv::s_storeTypeStatementString =
"INSERT /* TapeRequest class */ INTO Id2Type (id, type) VALUES (:1, :2)";

/// SQL statement for type deletion
const std::string castor::db::cnv::DbTapeRequestCnv::s_deleteTypeStatementString =
"DELETE FROM Id2Type WHERE id = :1";

/// SQL existence statement for member tape
const std::string castor::db::cnv::DbTapeRequestCnv::s_checkVdqmTapeExistStatementString =
"SELECT id FROM VdqmTape WHERE id = :1";

/// SQL update statement for member tape
const std::string castor::db::cnv::DbTapeRequestCnv::s_updateVdqmTapeStatementString =
"UPDATE TapeRequest SET tape = :1 WHERE id = :2";

/// SQL existence statement for member tapeAccessSpecification
const std::string castor::db::cnv::DbTapeRequestCnv::s_checkTapeAccessSpecificationExistStatementString =
"SELECT id FROM TapeAccessSpecification WHERE id = :1";

/// SQL update statement for member tapeAccessSpecification
const std::string castor::db::cnv::DbTapeRequestCnv::s_updateTapeAccessSpecificationStatementString =
"UPDATE TapeRequest SET tapeAccessSpecification = :1 WHERE id = :2";

/// SQL existence statement for member requestedSrv
const std::string castor::db::cnv::DbTapeRequestCnv::s_checkTapeServerExistStatementString =
"SELECT id FROM TapeServer WHERE id = :1";

/// SQL update statement for member requestedSrv
const std::string castor::db::cnv::DbTapeRequestCnv::s_updateTapeServerStatementString =
"UPDATE TapeRequest SET requestedSrv = :1 WHERE id = :2";

/// SQL select statement for member tapeDrive
const std::string castor::db::cnv::DbTapeRequestCnv::s_selectTapeDriveStatementString =
"SELECT id FROM TapeDrive WHERE runningTapeReq = :1 FOR UPDATE";

/// SQL delete statement for member tapeDrive
const std::string castor::db::cnv::DbTapeRequestCnv::s_deleteTapeDriveStatementString =
"UPDATE TapeDrive SET runningTapeReq = 0 WHERE id = :1";

/// SQL remote update statement for member tapeDrive
const std::string castor::db::cnv::DbTapeRequestCnv::s_remoteUpdateTapeDriveStatementString =
"UPDATE TapeDrive SET runningTapeReq = :1 WHERE id = :2";

/// SQL existence statement for member tapeDrive
const std::string castor::db::cnv::DbTapeRequestCnv::s_checkTapeDriveExistStatementString =
"SELECT id FROM TapeDrive WHERE id = :1";

/// SQL update statement for member tapeDrive
const std::string castor::db::cnv::DbTapeRequestCnv::s_updateTapeDriveStatementString =
"UPDATE TapeRequest SET tapeDrive = :1 WHERE id = :2";

/// SQL existence statement for member deviceGroupName
const std::string castor::db::cnv::DbTapeRequestCnv::s_checkDeviceGroupNameExistStatementString =
"SELECT id FROM DeviceGroupName WHERE id = :1";

/// SQL update statement for member deviceGroupName
const std::string castor::db::cnv::DbTapeRequestCnv::s_updateDeviceGroupNameStatementString =
"UPDATE TapeRequest SET deviceGroupName = :1 WHERE id = :2";

/// SQL existence statement for member client
const std::string castor::db::cnv::DbTapeRequestCnv::s_checkClientIdentificationExistStatementString =
"SELECT id FROM ClientIdentification WHERE id = :1";

/// SQL update statement for member client
const std::string castor::db::cnv::DbTapeRequestCnv::s_updateClientIdentificationStatementString =
"UPDATE TapeRequest SET client = :1 WHERE id = :2";

//------------------------------------------------------------------------------
// Constructor
//------------------------------------------------------------------------------
castor::db::cnv::DbTapeRequestCnv::DbTapeRequestCnv(castor::ICnvSvc* cnvSvc) :
  DbBaseCnv(cnvSvc),
  m_insertStatement(0),
  m_deleteStatement(0),
  m_selectStatement(0),
  m_bulkSelectStatement(0),
  m_updateStatement(0),
  m_storeTypeStatement(0),
  m_deleteTypeStatement(0),
  m_checkVdqmTapeExistStatement(0),
  m_updateVdqmTapeStatement(0),
  m_checkTapeAccessSpecificationExistStatement(0),
  m_updateTapeAccessSpecificationStatement(0),
  m_checkTapeServerExistStatement(0),
  m_updateTapeServerStatement(0),
  m_selectTapeDriveStatement(0),
  m_deleteTapeDriveStatement(0),
  m_remoteUpdateTapeDriveStatement(0),
  m_checkTapeDriveExistStatement(0),
  m_updateTapeDriveStatement(0),
  m_checkDeviceGroupNameExistStatement(0),
  m_updateDeviceGroupNameStatement(0),
  m_checkClientIdentificationExistStatement(0),
  m_updateClientIdentificationStatement(0) {}

//------------------------------------------------------------------------------
// Destructor
//------------------------------------------------------------------------------
castor::db::cnv::DbTapeRequestCnv::~DbTapeRequestCnv() throw() {
  reset();
}

//------------------------------------------------------------------------------
// reset
//------------------------------------------------------------------------------
void castor::db::cnv::DbTapeRequestCnv::reset() throw() {
  //Here we attempt to delete the statements correctly
  // If something goes wrong, we just ignore it
  try {
    if(m_insertStatement) delete m_insertStatement;
    if(m_deleteStatement) delete m_deleteStatement;
    if(m_selectStatement) delete m_selectStatement;
    if(m_bulkSelectStatement) delete m_bulkSelectStatement;
    if(m_updateStatement) delete m_updateStatement;
    if(m_storeTypeStatement) delete m_storeTypeStatement;
    if(m_deleteTypeStatement) delete m_deleteTypeStatement;
    if(m_checkVdqmTapeExistStatement) delete m_checkVdqmTapeExistStatement;
    if(m_updateVdqmTapeStatement) delete m_updateVdqmTapeStatement;
    if(m_checkTapeAccessSpecificationExistStatement) delete m_checkTapeAccessSpecificationExistStatement;
    if(m_updateTapeAccessSpecificationStatement) delete m_updateTapeAccessSpecificationStatement;
    if(m_checkTapeServerExistStatement) delete m_checkTapeServerExistStatement;
    if(m_updateTapeServerStatement) delete m_updateTapeServerStatement;
    if(m_deleteTapeDriveStatement) delete m_deleteTapeDriveStatement;
    if(m_selectTapeDriveStatement) delete m_selectTapeDriveStatement;
    if(m_remoteUpdateTapeDriveStatement) delete m_remoteUpdateTapeDriveStatement;
    if(m_checkTapeDriveExistStatement) delete m_checkTapeDriveExistStatement;
    if(m_updateTapeDriveStatement) delete m_updateTapeDriveStatement;
    if(m_checkDeviceGroupNameExistStatement) delete m_checkDeviceGroupNameExistStatement;
    if(m_updateDeviceGroupNameStatement) delete m_updateDeviceGroupNameStatement;
    if(m_checkClientIdentificationExistStatement) delete m_checkClientIdentificationExistStatement;
    if(m_updateClientIdentificationStatement) delete m_updateClientIdentificationStatement;
  } catch (castor::exception::Exception& ignored) {};
  // Now reset all pointers to 0
  m_insertStatement = 0;
  m_deleteStatement = 0;
  m_selectStatement = 0;
  m_bulkSelectStatement = 0;
  m_updateStatement = 0;
  m_storeTypeStatement = 0;
  m_deleteTypeStatement = 0;
  m_checkVdqmTapeExistStatement = 0;
  m_updateVdqmTapeStatement = 0;
  m_checkTapeAccessSpecificationExistStatement = 0;
  m_updateTapeAccessSpecificationStatement = 0;
  m_checkTapeServerExistStatement = 0;
  m_updateTapeServerStatement = 0;
  m_selectTapeDriveStatement = 0;
  m_deleteTapeDriveStatement = 0;
  m_remoteUpdateTapeDriveStatement = 0;
  m_checkTapeDriveExistStatement = 0;
  m_updateTapeDriveStatement = 0;
  m_checkDeviceGroupNameExistStatement = 0;
  m_updateDeviceGroupNameStatement = 0;
  m_checkClientIdentificationExistStatement = 0;
  m_updateClientIdentificationStatement = 0;
  // Call upper level reset
  this->DbBaseCnv::reset();
}

//------------------------------------------------------------------------------
// ObjType
//------------------------------------------------------------------------------
unsigned int castor::db::cnv::DbTapeRequestCnv::ObjType() {
  return castor::vdqm::TapeRequest::TYPE();
}

//------------------------------------------------------------------------------
// objType
//------------------------------------------------------------------------------
unsigned int castor::db::cnv::DbTapeRequestCnv::objType() const {
  return ObjType();
}

//------------------------------------------------------------------------------
// fillRep
//------------------------------------------------------------------------------
void castor::db::cnv::DbTapeRequestCnv::fillRep(castor::IAddress*,
                                                castor::IObject* object,
                                                unsigned int type,
                                                bool endTransaction)
  throw (castor::exception::Exception) {
  castor::vdqm::TapeRequest* obj = 
    dynamic_cast<castor::vdqm::TapeRequest*>(object);
  try {
    switch (type) {
    case castor::OBJ_VdqmTape :
      fillRepVdqmTape(obj);
      break;
    case castor::OBJ_TapeAccessSpecification :
      fillRepTapeAccessSpecification(obj);
      break;
    case castor::OBJ_TapeServer :
      fillRepTapeServer(obj);
      break;
    case castor::OBJ_TapeDrive :
      fillRepTapeDrive(obj);
      break;
    case castor::OBJ_DeviceGroupName :
      fillRepDeviceGroupName(obj);
      break;
    case castor::OBJ_ClientIdentification :
      fillRepClientIdentification(obj);
      break;
    default :
      castor::exception::InvalidArgument ex;
      ex.getMessage() << "fillRep called for type " << type 
                      << " on object of type " << obj->type() 
                      << ". This is meaningless.";
      throw ex;
    }
    if (endTransaction) {
      cnvSvc()->commit();
    }
  } catch (castor::exception::SQLError& e) {
    castor::exception::Internal ex;
    ex.getMessage() << "Error in fillRep for type " << type
                    << std::endl << e.getMessage().str() << std::endl;
    throw ex;
  }
}

//------------------------------------------------------------------------------
// fillRepVdqmTape
//------------------------------------------------------------------------------
void castor::db::cnv::DbTapeRequestCnv::fillRepVdqmTape(castor::vdqm::TapeRequest* obj)
  throw (castor::exception::Exception) {
  if (0 != obj->tape()) {
    // Check checkVdqmTapeExist statement
    if (0 == m_checkVdqmTapeExistStatement) {
      m_checkVdqmTapeExistStatement = createStatement(s_checkVdqmTapeExistStatementString);
    }
    // retrieve the object from the database
    m_checkVdqmTapeExistStatement->setUInt64(1, obj->tape()->id());
    castor::db::IDbResultSet *rset = m_checkVdqmTapeExistStatement->executeQuery();
    if (!rset->next()) {
      castor::BaseAddress ad;
      ad.setCnvSvcName("DbCnvSvc");
      ad.setCnvSvcType(castor::SVC_DBCNV);
      cnvSvc()->createRep(&ad, obj->tape(), false);
    }
    // Close resultset
    delete rset;
  }
  // Check update statement
  if (0 == m_updateVdqmTapeStatement) {
    m_updateVdqmTapeStatement = createStatement(s_updateVdqmTapeStatementString);
  }
  // Update local object
  m_updateVdqmTapeStatement->setUInt64(1, 0 == obj->tape() ? 0 : obj->tape()->id());
  m_updateVdqmTapeStatement->setUInt64(2, obj->id());
  m_updateVdqmTapeStatement->execute();
}

//------------------------------------------------------------------------------
// fillRepTapeAccessSpecification
//------------------------------------------------------------------------------
void castor::db::cnv::DbTapeRequestCnv::fillRepTapeAccessSpecification(castor::vdqm::TapeRequest* obj)
  throw (castor::exception::Exception) {
  if (0 != obj->tapeAccessSpecification()) {
    // Check checkTapeAccessSpecificationExist statement
    if (0 == m_checkTapeAccessSpecificationExistStatement) {
      m_checkTapeAccessSpecificationExistStatement = createStatement(s_checkTapeAccessSpecificationExistStatementString);
    }
    // retrieve the object from the database
    m_checkTapeAccessSpecificationExistStatement->setUInt64(1, obj->tapeAccessSpecification()->id());
    castor::db::IDbResultSet *rset = m_checkTapeAccessSpecificationExistStatement->executeQuery();
    if (!rset->next()) {
      castor::BaseAddress ad;
      ad.setCnvSvcName("DbCnvSvc");
      ad.setCnvSvcType(castor::SVC_DBCNV);
      cnvSvc()->createRep(&ad, obj->tapeAccessSpecification(), false);
    }
    // Close resultset
    delete rset;
  }
  // Check update statement
  if (0 == m_updateTapeAccessSpecificationStatement) {
    m_updateTapeAccessSpecificationStatement = createStatement(s_updateTapeAccessSpecificationStatementString);
  }
  // Update local object
  m_updateTapeAccessSpecificationStatement->setUInt64(1, 0 == obj->tapeAccessSpecification() ? 0 : obj->tapeAccessSpecification()->id());
  m_updateTapeAccessSpecificationStatement->setUInt64(2, obj->id());
  m_updateTapeAccessSpecificationStatement->execute();
}

//------------------------------------------------------------------------------
// fillRepTapeServer
//------------------------------------------------------------------------------
void castor::db::cnv::DbTapeRequestCnv::fillRepTapeServer(castor::vdqm::TapeRequest* obj)
  throw (castor::exception::Exception) {
  if (0 != obj->requestedSrv()) {
    // Check checkTapeServerExist statement
    if (0 == m_checkTapeServerExistStatement) {
      m_checkTapeServerExistStatement = createStatement(s_checkTapeServerExistStatementString);
    }
    // retrieve the object from the database
    m_checkTapeServerExistStatement->setUInt64(1, obj->requestedSrv()->id());
    castor::db::IDbResultSet *rset = m_checkTapeServerExistStatement->executeQuery();
    if (!rset->next()) {
      castor::BaseAddress ad;
      ad.setCnvSvcName("DbCnvSvc");
      ad.setCnvSvcType(castor::SVC_DBCNV);
      cnvSvc()->createRep(&ad, obj->requestedSrv(), false);
    }
    // Close resultset
    delete rset;
  }
  // Check update statement
  if (0 == m_updateTapeServerStatement) {
    m_updateTapeServerStatement = createStatement(s_updateTapeServerStatementString);
  }
  // Update local object
  m_updateTapeServerStatement->setUInt64(1, 0 == obj->requestedSrv() ? 0 : obj->requestedSrv()->id());
  m_updateTapeServerStatement->setUInt64(2, obj->id());
  m_updateTapeServerStatement->execute();
}

//------------------------------------------------------------------------------
// fillRepTapeDrive
//------------------------------------------------------------------------------
void castor::db::cnv::DbTapeRequestCnv::fillRepTapeDrive(castor::vdqm::TapeRequest* obj)
  throw (castor::exception::Exception) {
  // Check selectTapeDrive statement
  if (0 == m_selectTapeDriveStatement) {
    m_selectTapeDriveStatement = createStatement(s_selectTapeDriveStatementString);
  }
  // retrieve the object from the database
  m_selectTapeDriveStatement->setUInt64(1, obj->id());
  castor::db::IDbResultSet *rset = m_selectTapeDriveStatement->executeQuery();
  if (rset->next()) {
    u_signed64 tapeDriveId = rset->getInt64(1);
    if (0 != tapeDriveId &&
        (0 == obj->tapeDrive() ||
         obj->tapeDrive()->id() != tapeDriveId)) {
      if (0 == m_deleteTapeDriveStatement) {
        m_deleteTapeDriveStatement = createStatement(s_deleteTapeDriveStatementString);
      }
      m_deleteTapeDriveStatement->setUInt64(1, tapeDriveId);
      m_deleteTapeDriveStatement->execute();
    }
  }
  // Close resultset
  delete rset;
  if (0 != obj->tapeDrive()) {
    // Check checkTapeDriveExist statement
    if (0 == m_checkTapeDriveExistStatement) {
      m_checkTapeDriveExistStatement = createStatement(s_checkTapeDriveExistStatementString);
    }
    // retrieve the object from the database
    m_checkTapeDriveExistStatement->setUInt64(1, obj->tapeDrive()->id());
    castor::db::IDbResultSet *rset = m_checkTapeDriveExistStatement->executeQuery();
    if (!rset->next()) {
      castor::BaseAddress ad;
      ad.setCnvSvcName("DbCnvSvc");
      ad.setCnvSvcType(castor::SVC_DBCNV);
      cnvSvc()->createRep(&ad, obj->tapeDrive(), false, OBJ_TapeRequest);
    } else {
      // Check remote update statement
      if (0 == m_remoteUpdateTapeDriveStatement) {
        m_remoteUpdateTapeDriveStatement = createStatement(s_remoteUpdateTapeDriveStatementString);
      }
      // Update remote object
      m_remoteUpdateTapeDriveStatement->setUInt64(1, obj->id());
      m_remoteUpdateTapeDriveStatement->setUInt64(2, obj->tapeDrive()->id());
      m_remoteUpdateTapeDriveStatement->execute();
    }
    // Close resultset
    delete rset;
  }
  // Check update statement
  if (0 == m_updateTapeDriveStatement) {
    m_updateTapeDriveStatement = createStatement(s_updateTapeDriveStatementString);
  }
  // Update local object
  m_updateTapeDriveStatement->setUInt64(1, 0 == obj->tapeDrive() ? 0 : obj->tapeDrive()->id());
  m_updateTapeDriveStatement->setUInt64(2, obj->id());
  m_updateTapeDriveStatement->execute();
}

//------------------------------------------------------------------------------
// fillRepDeviceGroupName
//------------------------------------------------------------------------------
void castor::db::cnv::DbTapeRequestCnv::fillRepDeviceGroupName(castor::vdqm::TapeRequest* obj)
  throw (castor::exception::Exception) {
  if (0 != obj->deviceGroupName()) {
    // Check checkDeviceGroupNameExist statement
    if (0 == m_checkDeviceGroupNameExistStatement) {
      m_checkDeviceGroupNameExistStatement = createStatement(s_checkDeviceGroupNameExistStatementString);
    }
    // retrieve the object from the database
    m_checkDeviceGroupNameExistStatement->setUInt64(1, obj->deviceGroupName()->id());
    castor::db::IDbResultSet *rset = m_checkDeviceGroupNameExistStatement->executeQuery();
    if (!rset->next()) {
      castor::BaseAddress ad;
      ad.setCnvSvcName("DbCnvSvc");
      ad.setCnvSvcType(castor::SVC_DBCNV);
      cnvSvc()->createRep(&ad, obj->deviceGroupName(), false);
    }
    // Close resultset
    delete rset;
  }
  // Check update statement
  if (0 == m_updateDeviceGroupNameStatement) {
    m_updateDeviceGroupNameStatement = createStatement(s_updateDeviceGroupNameStatementString);
  }
  // Update local object
  m_updateDeviceGroupNameStatement->setUInt64(1, 0 == obj->deviceGroupName() ? 0 : obj->deviceGroupName()->id());
  m_updateDeviceGroupNameStatement->setUInt64(2, obj->id());
  m_updateDeviceGroupNameStatement->execute();
}

//------------------------------------------------------------------------------
// fillRepClientIdentification
//------------------------------------------------------------------------------
void castor::db::cnv::DbTapeRequestCnv::fillRepClientIdentification(castor::vdqm::TapeRequest* obj)
  throw (castor::exception::Exception) {
  if (0 != obj->client()) {
    // Check checkClientIdentificationExist statement
    if (0 == m_checkClientIdentificationExistStatement) {
      m_checkClientIdentificationExistStatement = createStatement(s_checkClientIdentificationExistStatementString);
    }
    // retrieve the object from the database
    m_checkClientIdentificationExistStatement->setUInt64(1, obj->client()->id());
    castor::db::IDbResultSet *rset = m_checkClientIdentificationExistStatement->executeQuery();
    if (!rset->next()) {
      castor::BaseAddress ad;
      ad.setCnvSvcName("DbCnvSvc");
      ad.setCnvSvcType(castor::SVC_DBCNV);
      cnvSvc()->createRep(&ad, obj->client(), false);
    }
    // Close resultset
    delete rset;
  }
  // Check update statement
  if (0 == m_updateClientIdentificationStatement) {
    m_updateClientIdentificationStatement = createStatement(s_updateClientIdentificationStatementString);
  }
  // Update local object
  m_updateClientIdentificationStatement->setUInt64(1, 0 == obj->client() ? 0 : obj->client()->id());
  m_updateClientIdentificationStatement->setUInt64(2, obj->id());
  m_updateClientIdentificationStatement->execute();
}

//------------------------------------------------------------------------------
// fillObj
//------------------------------------------------------------------------------
void castor::db::cnv::DbTapeRequestCnv::fillObj(castor::IAddress*,
                                                castor::IObject* object,
                                                unsigned int type,
                                                bool endTransaction)
  throw (castor::exception::Exception) {
  castor::vdqm::TapeRequest* obj = 
    dynamic_cast<castor::vdqm::TapeRequest*>(object);
  switch (type) {
  case castor::OBJ_VdqmTape :
    fillObjVdqmTape(obj);
    break;
  case castor::OBJ_TapeAccessSpecification :
    fillObjTapeAccessSpecification(obj);
    break;
  case castor::OBJ_TapeServer :
    fillObjTapeServer(obj);
    break;
  case castor::OBJ_TapeDrive :
    fillObjTapeDrive(obj);
    break;
  case castor::OBJ_DeviceGroupName :
    fillObjDeviceGroupName(obj);
    break;
  case castor::OBJ_ClientIdentification :
    fillObjClientIdentification(obj);
    break;
  default :
    castor::exception::InvalidArgument ex;
    ex.getMessage() << "fillObj called on type " << type 
                    << " on object of type " << obj->type() 
                    << ". This is meaningless.";
    throw ex;
  }
  if (endTransaction) {
    cnvSvc()->commit();
  }
}

//------------------------------------------------------------------------------
// fillObjVdqmTape
//------------------------------------------------------------------------------
void castor::db::cnv::DbTapeRequestCnv::fillObjVdqmTape(castor::vdqm::TapeRequest* obj)
  throw (castor::exception::Exception) {
  // Check whether the statement is ok
  if (0 == m_selectStatement) {
    m_selectStatement = createStatement(s_selectStatementString);
  }
  // retrieve the object from the database
  m_selectStatement->setUInt64(1, obj->id());
  castor::db::IDbResultSet *rset = m_selectStatement->executeQuery();
  if (!rset->next()) {
    castor::exception::NoEntry ex;
    ex.getMessage() << "No object found for id :" << obj->id();
    throw ex;
  }
  u_signed64 tapeId = rset->getInt64(8);
  // Close ResultSet
  delete rset;
  // Check whether something should be deleted
  if (0 != obj->tape() &&
      (0 == tapeId ||
       obj->tape()->id() != tapeId)) {
    obj->setTape(0);
  }
  // Update object or create new one
  if (0 != tapeId) {
    if (0 == obj->tape()) {
      obj->setTape
        (dynamic_cast<castor::vdqm::VdqmTape*>
         (cnvSvc()->getObjFromId(tapeId)));
    } else {
      cnvSvc()->updateObj(obj->tape());
    }
  }
}

//------------------------------------------------------------------------------
// fillObjTapeAccessSpecification
//------------------------------------------------------------------------------
void castor::db::cnv::DbTapeRequestCnv::fillObjTapeAccessSpecification(castor::vdqm::TapeRequest* obj)
  throw (castor::exception::Exception) {
  // Check whether the statement is ok
  if (0 == m_selectStatement) {
    m_selectStatement = createStatement(s_selectStatementString);
  }
  // retrieve the object from the database
  m_selectStatement->setUInt64(1, obj->id());
  castor::db::IDbResultSet *rset = m_selectStatement->executeQuery();
  if (!rset->next()) {
    castor::exception::NoEntry ex;
    ex.getMessage() << "No object found for id :" << obj->id();
    throw ex;
  }
  u_signed64 tapeAccessSpecificationId = rset->getInt64(9);
  // Close ResultSet
  delete rset;
  // Check whether something should be deleted
  if (0 != obj->tapeAccessSpecification() &&
      (0 == tapeAccessSpecificationId ||
       obj->tapeAccessSpecification()->id() != tapeAccessSpecificationId)) {
    obj->setTapeAccessSpecification(0);
  }
  // Update object or create new one
  if (0 != tapeAccessSpecificationId) {
    if (0 == obj->tapeAccessSpecification()) {
      obj->setTapeAccessSpecification
        (dynamic_cast<castor::vdqm::TapeAccessSpecification*>
         (cnvSvc()->getObjFromId(tapeAccessSpecificationId)));
    } else {
      cnvSvc()->updateObj(obj->tapeAccessSpecification());
    }
  }
}

//------------------------------------------------------------------------------
// fillObjTapeServer
//------------------------------------------------------------------------------
void castor::db::cnv::DbTapeRequestCnv::fillObjTapeServer(castor::vdqm::TapeRequest* obj)
  throw (castor::exception::Exception) {
  // Check whether the statement is ok
  if (0 == m_selectStatement) {
    m_selectStatement = createStatement(s_selectStatementString);
  }
  // retrieve the object from the database
  m_selectStatement->setUInt64(1, obj->id());
  castor::db::IDbResultSet *rset = m_selectStatement->executeQuery();
  if (!rset->next()) {
    castor::exception::NoEntry ex;
    ex.getMessage() << "No object found for id :" << obj->id();
    throw ex;
  }
  u_signed64 requestedSrvId = rset->getInt64(10);
  // Close ResultSet
  delete rset;
  // Check whether something should be deleted
  if (0 != obj->requestedSrv() &&
      (0 == requestedSrvId ||
       obj->requestedSrv()->id() != requestedSrvId)) {
    obj->setRequestedSrv(0);
  }
  // Update object or create new one
  if (0 != requestedSrvId) {
    if (0 == obj->requestedSrv()) {
      obj->setRequestedSrv
        (dynamic_cast<castor::vdqm::TapeServer*>
         (cnvSvc()->getObjFromId(requestedSrvId)));
    } else {
      cnvSvc()->updateObj(obj->requestedSrv());
    }
  }
}

//------------------------------------------------------------------------------
// fillObjTapeDrive
//------------------------------------------------------------------------------
void castor::db::cnv::DbTapeRequestCnv::fillObjTapeDrive(castor::vdqm::TapeRequest* obj)
  throw (castor::exception::Exception) {
  // Check whether the statement is ok
  if (0 == m_selectStatement) {
    m_selectStatement = createStatement(s_selectStatementString);
  }
  // retrieve the object from the database
  m_selectStatement->setUInt64(1, obj->id());
  castor::db::IDbResultSet *rset = m_selectStatement->executeQuery();
  if (!rset->next()) {
    castor::exception::NoEntry ex;
    ex.getMessage() << "No object found for id :" << obj->id();
    throw ex;
  }
  u_signed64 tapeDriveId = rset->getInt64(11);
  // Close ResultSet
  delete rset;
  // Check whether something should be deleted
  if (0 != obj->tapeDrive() &&
      (0 == tapeDriveId ||
       obj->tapeDrive()->id() != tapeDriveId)) {
    obj->tapeDrive()->setRunningTapeReq(0);
    obj->setTapeDrive(0);
  }
  // Update object or create new one
  if (0 != tapeDriveId) {
    if (0 == obj->tapeDrive()) {
      obj->setTapeDrive
        (dynamic_cast<castor::vdqm::TapeDrive*>
         (cnvSvc()->getObjFromId(tapeDriveId)));
    } else {
      cnvSvc()->updateObj(obj->tapeDrive());
    }
    obj->tapeDrive()->setRunningTapeReq(obj);
  }
}

//------------------------------------------------------------------------------
// fillObjDeviceGroupName
//------------------------------------------------------------------------------
void castor::db::cnv::DbTapeRequestCnv::fillObjDeviceGroupName(castor::vdqm::TapeRequest* obj)
  throw (castor::exception::Exception) {
  // Check whether the statement is ok
  if (0 == m_selectStatement) {
    m_selectStatement = createStatement(s_selectStatementString);
  }
  // retrieve the object from the database
  m_selectStatement->setUInt64(1, obj->id());
  castor::db::IDbResultSet *rset = m_selectStatement->executeQuery();
  if (!rset->next()) {
    castor::exception::NoEntry ex;
    ex.getMessage() << "No object found for id :" << obj->id();
    throw ex;
  }
  u_signed64 deviceGroupNameId = rset->getInt64(12);
  // Close ResultSet
  delete rset;
  // Check whether something should be deleted
  if (0 != obj->deviceGroupName() &&
      (0 == deviceGroupNameId ||
       obj->deviceGroupName()->id() != deviceGroupNameId)) {
    obj->setDeviceGroupName(0);
  }
  // Update object or create new one
  if (0 != deviceGroupNameId) {
    if (0 == obj->deviceGroupName()) {
      obj->setDeviceGroupName
        (dynamic_cast<castor::vdqm::DeviceGroupName*>
         (cnvSvc()->getObjFromId(deviceGroupNameId)));
    } else {
      cnvSvc()->updateObj(obj->deviceGroupName());
    }
  }
}

//------------------------------------------------------------------------------
// fillObjClientIdentification
//------------------------------------------------------------------------------
void castor::db::cnv::DbTapeRequestCnv::fillObjClientIdentification(castor::vdqm::TapeRequest* obj)
  throw (castor::exception::Exception) {
  // Check whether the statement is ok
  if (0 == m_selectStatement) {
    m_selectStatement = createStatement(s_selectStatementString);
  }
  // retrieve the object from the database
  m_selectStatement->setUInt64(1, obj->id());
  castor::db::IDbResultSet *rset = m_selectStatement->executeQuery();
  if (!rset->next()) {
    castor::exception::NoEntry ex;
    ex.getMessage() << "No object found for id :" << obj->id();
    throw ex;
  }
  u_signed64 clientId = rset->getInt64(14);
  // Close ResultSet
  delete rset;
  // Check whether something should be deleted
  if (0 != obj->client() &&
      (0 == clientId ||
       obj->client()->id() != clientId)) {
    obj->setClient(0);
  }
  // Update object or create new one
  if (0 != clientId) {
    if (0 == obj->client()) {
      obj->setClient
        (dynamic_cast<castor::vdqm::ClientIdentification*>
         (cnvSvc()->getObjFromId(clientId)));
    } else {
      cnvSvc()->updateObj(obj->client());
    }
  }
}

//------------------------------------------------------------------------------
// createRep
//------------------------------------------------------------------------------
void castor::db::cnv::DbTapeRequestCnv::createRep(castor::IAddress*,
                                                  castor::IObject* object,
                                                  bool endTransaction,
                                                  unsigned int type)
  throw (castor::exception::Exception) {
  castor::vdqm::TapeRequest* obj = 
    dynamic_cast<castor::vdqm::TapeRequest*>(object);
  // check whether something needs to be done
  if (0 == obj) return;
  if (0 != obj->id()) return;
  try {
    // Check whether the statements are ok
    if (0 == m_insertStatement) {
      m_insertStatement = createStatement(s_insertStatementString);
      m_insertStatement->registerOutParam(14, castor::db::DBTYPE_UINT64);
    }
    if (0 == m_storeTypeStatement) {
      m_storeTypeStatement = createStatement(s_storeTypeStatementString);
    }
    // Now Save the current object
    m_insertStatement->setInt(1, obj->priority());
    m_insertStatement->setUInt64(2, obj->modificationTime());
    m_insertStatement->setInt(3, time(0));
    m_insertStatement->setInt(4, obj->errorCode());
    m_insertStatement->setString(5, obj->errorMessage());
    m_insertStatement->setString(6, obj->remoteCopyType());
    m_insertStatement->setUInt64(7, (type == OBJ_VdqmTape && obj->tape() != 0) ? obj->tape()->id() : 0);
    m_insertStatement->setUInt64(8, (type == OBJ_TapeAccessSpecification && obj->tapeAccessSpecification() != 0) ? obj->tapeAccessSpecification()->id() : 0);
    m_insertStatement->setUInt64(9, (type == OBJ_TapeServer && obj->requestedSrv() != 0) ? obj->requestedSrv()->id() : 0);
    m_insertStatement->setUInt64(10, (type == OBJ_TapeDrive && obj->tapeDrive() != 0) ? obj->tapeDrive()->id() : 0);
    m_insertStatement->setUInt64(11, (type == OBJ_DeviceGroupName && obj->deviceGroupName() != 0) ? obj->deviceGroupName()->id() : 0);
    m_insertStatement->setInt(12, (int)obj->status());
    m_insertStatement->setUInt64(13, (type == OBJ_ClientIdentification && obj->client() != 0) ? obj->client()->id() : 0);
    m_insertStatement->execute();
    obj->setId(m_insertStatement->getUInt64(14));
    m_storeTypeStatement->setUInt64(1, obj->id());
    m_storeTypeStatement->setUInt64(2, obj->type());
    m_storeTypeStatement->execute();
    if (endTransaction) {
      cnvSvc()->commit();
    }
  } catch (castor::exception::SQLError& e) {
    // Always try to rollback
    try {
      if (endTransaction) cnvSvc()->rollback();
    } catch (castor::exception::Exception& ignored) {}
    castor::exception::InvalidArgument ex;
    ex.getMessage() << "Error in insert request :"
                    << std::endl << e.getMessage().str() << std::endl
                    << "Statement was : " << std::endl
                    << s_insertStatementString << std::endl
                    << " and parameters' values were :" << std::endl
                    << "  priority : " << obj->priority() << std::endl
                    << "  modificationTime : " << obj->modificationTime() << std::endl
                    << "  creationTime : " << obj->creationTime() << std::endl
                    << "  errorCode : " << obj->errorCode() << std::endl
                    << "  errorMessage : " << obj->errorMessage() << std::endl
                    << "  remoteCopyType : " << obj->remoteCopyType() << std::endl
                    << "  id : " << obj->id() << std::endl
                    << "  tape : " << (obj->tape() ? obj->tape()->id() : 0) << std::endl
                    << "  tapeAccessSpecification : " << (obj->tapeAccessSpecification() ? obj->tapeAccessSpecification()->id() : 0) << std::endl
                    << "  requestedSrv : " << (obj->requestedSrv() ? obj->requestedSrv()->id() : 0) << std::endl
                    << "  tapeDrive : " << (obj->tapeDrive() ? obj->tapeDrive()->id() : 0) << std::endl
                    << "  deviceGroupName : " << (obj->deviceGroupName() ? obj->deviceGroupName()->id() : 0) << std::endl
                    << "  status : " << obj->status() << std::endl
                    << "  client : " << (obj->client() ? obj->client()->id() : 0) << std::endl;
    throw ex;
  }
}

//------------------------------------------------------------------------------
// bulkCreateRep
//------------------------------------------------------------------------------
void castor::db::cnv::DbTapeRequestCnv::bulkCreateRep(castor::IAddress*,
                                                      std::vector<castor::IObject*> &objects,
                                                      bool endTransaction,
                                                      unsigned int type)
  throw (castor::exception::Exception) {
  // check whether something needs to be done
  int nb = objects.size();
  if (0 == nb) return;
  // Casts all objects
  std::vector<castor::vdqm::TapeRequest*> objs;
  for (int i = 0; i < nb; i++) {
    objs.push_back(dynamic_cast<castor::vdqm::TapeRequest*>(objects[i]));
  }
  std::vector<void *> allocMem;
  try {
    // Check whether the statements are ok
    if (0 == m_insertStatement) {
      m_insertStatement = createStatement(s_insertStatementString);
      m_insertStatement->registerOutParam(14, castor::db::DBTYPE_UINT64);
    }
    if (0 == m_storeTypeStatement) {
      m_storeTypeStatement = createStatement(s_storeTypeStatementString);
    }
    // build the buffers for priority
    int* priorityBuffer = (int*) malloc(nb * sizeof(int));
    if (priorityBuffer == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(priorityBuffer);
    unsigned short* priorityBufLens = (unsigned short*) malloc(nb * sizeof(unsigned short));
    if (priorityBufLens == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(priorityBufLens);
    for (int i = 0; i < nb; i++) {
      priorityBuffer[i] = objs[i]->priority();
      priorityBufLens[i] = sizeof(int);
    }
    m_insertStatement->setDataBuffer
      (1, priorityBuffer, castor::db::DBTYPE_INT, sizeof(priorityBuffer[0]), priorityBufLens);
    // build the buffers for modificationTime
    double* modificationTimeBuffer = (double*) malloc(nb * sizeof(double));
    if (modificationTimeBuffer == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(modificationTimeBuffer);
    unsigned short* modificationTimeBufLens = (unsigned short*) malloc(nb * sizeof(unsigned short));
    if (modificationTimeBufLens == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(modificationTimeBufLens);
    for (int i = 0; i < nb; i++) {
      modificationTimeBuffer[i] = objs[i]->modificationTime();
      modificationTimeBufLens[i] = sizeof(double);
    }
    m_insertStatement->setDataBuffer
      (2, modificationTimeBuffer, castor::db::DBTYPE_UINT64, sizeof(modificationTimeBuffer[0]), modificationTimeBufLens);
    // build the buffers for creationTime
    double* creationTimeBuffer = (double*) malloc(nb * sizeof(double));
    if (creationTimeBuffer == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(creationTimeBuffer);
    unsigned short* creationTimeBufLens = (unsigned short*) malloc(nb * sizeof(unsigned short));
    if (creationTimeBufLens == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(creationTimeBufLens);
    for (int i = 0; i < nb; i++) {
      creationTimeBuffer[i] = time(0);
      creationTimeBufLens[i] = sizeof(double);
    }
    m_insertStatement->setDataBuffer
      (3, creationTimeBuffer, castor::db::DBTYPE_UINT64, sizeof(creationTimeBuffer[0]), creationTimeBufLens);
    // build the buffers for errorCode
    int* errorCodeBuffer = (int*) malloc(nb * sizeof(int));
    if (errorCodeBuffer == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(errorCodeBuffer);
    unsigned short* errorCodeBufLens = (unsigned short*) malloc(nb * sizeof(unsigned short));
    if (errorCodeBufLens == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(errorCodeBufLens);
    for (int i = 0; i < nb; i++) {
      errorCodeBuffer[i] = objs[i]->errorCode();
      errorCodeBufLens[i] = sizeof(int);
    }
    m_insertStatement->setDataBuffer
      (4, errorCodeBuffer, castor::db::DBTYPE_INT, sizeof(errorCodeBuffer[0]), errorCodeBufLens);
    // build the buffers for errorMessage
    unsigned int errorMessageMaxLen = 0;
    for (int i = 0; i < nb; i++) {
      if (objs[i]->errorMessage().length()+1 > errorMessageMaxLen)
        errorMessageMaxLen = objs[i]->errorMessage().length()+1;
    }
    char* errorMessageBuffer = (char*) calloc(nb, errorMessageMaxLen);
    if (errorMessageBuffer == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(errorMessageBuffer);
    unsigned short* errorMessageBufLens = (unsigned short*) malloc(nb * sizeof(unsigned short));
    if (errorMessageBufLens == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(errorMessageBufLens);
    for (int i = 0; i < nb; i++) {
      strncpy(errorMessageBuffer+(i*errorMessageMaxLen), objs[i]->errorMessage().c_str(), errorMessageMaxLen);
      errorMessageBufLens[i] = objs[i]->errorMessage().length()+1; // + 1 for the trailing \0
    }
    m_insertStatement->setDataBuffer
      (5, errorMessageBuffer, castor::db::DBTYPE_STRING, errorMessageMaxLen, errorMessageBufLens);
    // build the buffers for remoteCopyType
    unsigned int remoteCopyTypeMaxLen = 0;
    for (int i = 0; i < nb; i++) {
      if (objs[i]->remoteCopyType().length()+1 > remoteCopyTypeMaxLen)
        remoteCopyTypeMaxLen = objs[i]->remoteCopyType().length()+1;
    }
    char* remoteCopyTypeBuffer = (char*) calloc(nb, remoteCopyTypeMaxLen);
    if (remoteCopyTypeBuffer == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(remoteCopyTypeBuffer);
    unsigned short* remoteCopyTypeBufLens = (unsigned short*) malloc(nb * sizeof(unsigned short));
    if (remoteCopyTypeBufLens == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(remoteCopyTypeBufLens);
    for (int i = 0; i < nb; i++) {
      strncpy(remoteCopyTypeBuffer+(i*remoteCopyTypeMaxLen), objs[i]->remoteCopyType().c_str(), remoteCopyTypeMaxLen);
      remoteCopyTypeBufLens[i] = objs[i]->remoteCopyType().length()+1; // + 1 for the trailing \0
    }
    m_insertStatement->setDataBuffer
      (6, remoteCopyTypeBuffer, castor::db::DBTYPE_STRING, remoteCopyTypeMaxLen, remoteCopyTypeBufLens);
    // build the buffers for tape
    double* tapeBuffer = (double*) malloc(nb * sizeof(double));
    if (tapeBuffer == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(tapeBuffer);
    unsigned short* tapeBufLens = (unsigned short*) malloc(nb * sizeof(unsigned short));
    if (tapeBufLens == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(tapeBufLens);
    for (int i = 0; i < nb; i++) {
      tapeBuffer[i] = (type == OBJ_VdqmTape && objs[i]->tape() != 0) ? objs[i]->tape()->id() : 0;
      tapeBufLens[i] = sizeof(double);
    }
    m_insertStatement->setDataBuffer
      (7, tapeBuffer, castor::db::DBTYPE_UINT64, sizeof(tapeBuffer[0]), tapeBufLens);
    // build the buffers for tapeAccessSpecification
    double* tapeAccessSpecificationBuffer = (double*) malloc(nb * sizeof(double));
    if (tapeAccessSpecificationBuffer == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(tapeAccessSpecificationBuffer);
    unsigned short* tapeAccessSpecificationBufLens = (unsigned short*) malloc(nb * sizeof(unsigned short));
    if (tapeAccessSpecificationBufLens == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(tapeAccessSpecificationBufLens);
    for (int i = 0; i < nb; i++) {
      tapeAccessSpecificationBuffer[i] = (type == OBJ_TapeAccessSpecification && objs[i]->tapeAccessSpecification() != 0) ? objs[i]->tapeAccessSpecification()->id() : 0;
      tapeAccessSpecificationBufLens[i] = sizeof(double);
    }
    m_insertStatement->setDataBuffer
      (8, tapeAccessSpecificationBuffer, castor::db::DBTYPE_UINT64, sizeof(tapeAccessSpecificationBuffer[0]), tapeAccessSpecificationBufLens);
    // build the buffers for requestedSrv
    double* requestedSrvBuffer = (double*) malloc(nb * sizeof(double));
    if (requestedSrvBuffer == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(requestedSrvBuffer);
    unsigned short* requestedSrvBufLens = (unsigned short*) malloc(nb * sizeof(unsigned short));
    if (requestedSrvBufLens == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(requestedSrvBufLens);
    for (int i = 0; i < nb; i++) {
      requestedSrvBuffer[i] = (type == OBJ_TapeServer && objs[i]->requestedSrv() != 0) ? objs[i]->requestedSrv()->id() : 0;
      requestedSrvBufLens[i] = sizeof(double);
    }
    m_insertStatement->setDataBuffer
      (9, requestedSrvBuffer, castor::db::DBTYPE_UINT64, sizeof(requestedSrvBuffer[0]), requestedSrvBufLens);
    // build the buffers for tapeDrive
    double* tapeDriveBuffer = (double*) malloc(nb * sizeof(double));
    if (tapeDriveBuffer == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(tapeDriveBuffer);
    unsigned short* tapeDriveBufLens = (unsigned short*) malloc(nb * sizeof(unsigned short));
    if (tapeDriveBufLens == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(tapeDriveBufLens);
    for (int i = 0; i < nb; i++) {
      tapeDriveBuffer[i] = (type == OBJ_TapeDrive && objs[i]->tapeDrive() != 0) ? objs[i]->tapeDrive()->id() : 0;
      tapeDriveBufLens[i] = sizeof(double);
    }
    m_insertStatement->setDataBuffer
      (10, tapeDriveBuffer, castor::db::DBTYPE_UINT64, sizeof(tapeDriveBuffer[0]), tapeDriveBufLens);
    // build the buffers for deviceGroupName
    double* deviceGroupNameBuffer = (double*) malloc(nb * sizeof(double));
    if (deviceGroupNameBuffer == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(deviceGroupNameBuffer);
    unsigned short* deviceGroupNameBufLens = (unsigned short*) malloc(nb * sizeof(unsigned short));
    if (deviceGroupNameBufLens == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(deviceGroupNameBufLens);
    for (int i = 0; i < nb; i++) {
      deviceGroupNameBuffer[i] = (type == OBJ_DeviceGroupName && objs[i]->deviceGroupName() != 0) ? objs[i]->deviceGroupName()->id() : 0;
      deviceGroupNameBufLens[i] = sizeof(double);
    }
    m_insertStatement->setDataBuffer
      (11, deviceGroupNameBuffer, castor::db::DBTYPE_UINT64, sizeof(deviceGroupNameBuffer[0]), deviceGroupNameBufLens);
    // build the buffers for status
    int* statusBuffer = (int*) malloc(nb * sizeof(int));
    if (statusBuffer == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(statusBuffer);
    unsigned short* statusBufLens = (unsigned short*) malloc(nb * sizeof(unsigned short));
    if (statusBufLens == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(statusBufLens);
    for (int i = 0; i < nb; i++) {
      statusBuffer[i] = objs[i]->status();
      statusBufLens[i] = sizeof(int);
    }
    m_insertStatement->setDataBuffer
      (12, statusBuffer, castor::db::DBTYPE_INT, sizeof(statusBuffer[0]), statusBufLens);
    // build the buffers for client
    double* clientBuffer = (double*) malloc(nb * sizeof(double));
    if (clientBuffer == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(clientBuffer);
    unsigned short* clientBufLens = (unsigned short*) malloc(nb * sizeof(unsigned short));
    if (clientBufLens == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(clientBufLens);
    for (int i = 0; i < nb; i++) {
      clientBuffer[i] = (type == OBJ_ClientIdentification && objs[i]->client() != 0) ? objs[i]->client()->id() : 0;
      clientBufLens[i] = sizeof(double);
    }
    m_insertStatement->setDataBuffer
      (13, clientBuffer, castor::db::DBTYPE_UINT64, sizeof(clientBuffer[0]), clientBufLens);
    // build the buffers for returned ids
    double* idBuffer = (double*) calloc(nb, sizeof(double));
    if (idBuffer == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(idBuffer);
    unsigned short* idBufLens = (unsigned short*) calloc(nb, sizeof(unsigned short));
    if (idBufLens == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(idBufLens);
    m_insertStatement->setDataBuffer
      (14, idBuffer, castor::db::DBTYPE_UINT64, sizeof(double), idBufLens);
    m_insertStatement->execute(nb);
    for (int i = 0; i < nb; i++) {
      objects[i]->setId((u_signed64)idBuffer[i]);
    }
    // reuse idBuffer for bulk insertion into Id2Type
    m_storeTypeStatement->setDataBuffer
      (1, idBuffer, castor::db::DBTYPE_UINT64, sizeof(idBuffer[0]), idBufLens);
    // build the buffers for type
    int* typeBuffer = (int*) malloc(nb * sizeof(int));
    if (typeBuffer == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(typeBuffer);
    unsigned short* typeBufLens = (unsigned short*) malloc(nb * sizeof(unsigned short));
    if (typeBufLens == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(typeBufLens);
    for (int i = 0; i < nb; i++) {
      typeBuffer[i] = objs[i]->type();
      typeBufLens[i] = sizeof(int);
    }
    m_storeTypeStatement->setDataBuffer
      (2, typeBuffer, castor::db::DBTYPE_INT, sizeof(typeBuffer[0]), typeBufLens);
    m_storeTypeStatement->execute(nb);
    // release the buffers
    for (unsigned int i = 0; i < allocMem.size(); i++) {
      free(allocMem[i]);
    }
    if (endTransaction) {
      cnvSvc()->commit();
    }
  } catch (castor::exception::SQLError& e) {
    // release the buffers
    for (unsigned int i = 0; i < allocMem.size(); i++) {
      free(allocMem[i]);
    }
    // Always try to rollback
    try {
      if (endTransaction) cnvSvc()->rollback();
    } catch (castor::exception::Exception& ignored) {}
    castor::exception::InvalidArgument ex;
    ex.getMessage() << "Error in bulkInsert request :"
                    << std::endl << e.getMessage().str() << std::endl
                    << " was called in bulk with "
                    << nb << " items." << std::endl;
    throw ex;
  }
}

//------------------------------------------------------------------------------
// updateRep
//------------------------------------------------------------------------------
void castor::db::cnv::DbTapeRequestCnv::updateRep(castor::IAddress*,
                                                  castor::IObject* object,
                                                  bool endTransaction)
  throw (castor::exception::Exception) {
  castor::vdqm::TapeRequest* obj = 
    dynamic_cast<castor::vdqm::TapeRequest*>(object);
  // check whether something needs to be done
  if (0 == obj) return;
  try {
    // Check whether the statements are ok
    if (0 == m_updateStatement) {
      m_updateStatement = createStatement(s_updateStatementString);
    }
    // Update the current object
    m_updateStatement->setInt(1, obj->priority());
    m_updateStatement->setUInt64(2, obj->modificationTime());
    m_updateStatement->setInt(3, obj->errorCode());
    m_updateStatement->setString(4, obj->errorMessage());
    m_updateStatement->setString(5, obj->remoteCopyType());
    m_updateStatement->setInt(6, (int)obj->status());
    m_updateStatement->setUInt64(7, obj->id());
    m_updateStatement->execute();
    if (endTransaction) {
      cnvSvc()->commit();
    }
  } catch (castor::exception::SQLError& e) {
    // Always try to rollback
    try {
      if (endTransaction) cnvSvc()->rollback();
    } catch (castor::exception::Exception& ignored) {}
    castor::exception::InvalidArgument ex;
    ex.getMessage() << "Error in update request :"
                    << std::endl << e.getMessage().str() << std::endl
                    << "Statement was : " << std::endl
                    << s_updateStatementString << std::endl
                    << " and id was " << obj->id() << std::endl;;
    throw ex;
  }
}

//------------------------------------------------------------------------------
// deleteRep
//------------------------------------------------------------------------------
void castor::db::cnv::DbTapeRequestCnv::deleteRep(castor::IAddress*,
                                                  castor::IObject* object,
                                                  bool endTransaction)
  throw (castor::exception::Exception) {
  castor::vdqm::TapeRequest* obj = 
    dynamic_cast<castor::vdqm::TapeRequest*>(object);
  // check whether something needs to be done
  if (0 == obj) return;
  try {
    // Check whether the statements are ok
    if (0 == m_deleteStatement) {
      m_deleteStatement = createStatement(s_deleteStatementString);
    }
    if (0 == m_deleteTypeStatement) {
      m_deleteTypeStatement = createStatement(s_deleteTypeStatementString);
    }
    // Now Delete the object
    m_deleteTypeStatement->setUInt64(1, obj->id());
    m_deleteTypeStatement->execute();
    m_deleteStatement->setUInt64(1, obj->id());
    m_deleteStatement->execute();
    if (obj->client() != 0) {
      cnvSvc()->deleteRep(0, obj->client(), false);
    }
    if (endTransaction) {
      cnvSvc()->commit();
    }
  } catch (castor::exception::SQLError& e) {
    // Always try to rollback
    try {
      if (endTransaction) cnvSvc()->rollback();
    } catch (castor::exception::Exception& ignored) {}
    castor::exception::InvalidArgument ex;
    ex.getMessage() << "Error in delete request :"
                    << std::endl << e.getMessage().str() << std::endl
                    << "Statement was : " << std::endl
                    << s_deleteStatementString << std::endl
                    << " and id was " << obj->id() << std::endl;;
    throw ex;
  }
}

//------------------------------------------------------------------------------
// createObj
//------------------------------------------------------------------------------
castor::IObject* castor::db::cnv::DbTapeRequestCnv::createObj(castor::IAddress* address)
  throw (castor::exception::Exception) {
  castor::BaseAddress* ad = 
    dynamic_cast<castor::BaseAddress*>(address);
  try {
    // Check whether the statement is ok
    if (0 == m_selectStatement) {
      m_selectStatement = createStatement(s_selectStatementString);
    }
    // retrieve the object from the database
    m_selectStatement->setUInt64(1, ad->target());
    castor::db::IDbResultSet *rset = m_selectStatement->executeQuery();
    if (!rset->next()) {
      castor::exception::NoEntry ex;
      ex.getMessage() << "No object found for id :" << ad->target();
      throw ex;
    }
    // create the new Object
    castor::vdqm::TapeRequest* object = new castor::vdqm::TapeRequest();
    // Now retrieve and set members
    object->setPriority(rset->getInt(1));
    object->setModificationTime(rset->getUInt64(2));
    object->setCreationTime(rset->getUInt64(3));
    object->setErrorCode(rset->getInt(4));
    object->setErrorMessage(rset->getString(5));
    object->setRemoteCopyType(rset->getString(6));
    object->setId(rset->getUInt64(7));
    object->setStatus((enum castor::vdqm::TapeRequestStatusCodes)rset->getInt(13));
    delete rset;
    return object;
  } catch (castor::exception::SQLError& e) {
    castor::exception::InvalidArgument ex;
    ex.getMessage() << "Error in select request :"
                    << std::endl << e.getMessage().str() << std::endl
                    << "Statement was : " << std::endl
                    << s_selectStatementString << std::endl
                    << " and id was " << ad->target() << std::endl;;
    throw ex;
  }
}

//------------------------------------------------------------------------------
// bulkCreateObj
//------------------------------------------------------------------------------
std::vector<castor::IObject*>
castor::db::cnv::DbTapeRequestCnv::bulkCreateObj(castor::IAddress* address)
  throw (castor::exception::Exception) {
  // Prepare result
  std::vector<castor::IObject*> res;
  // check whether something needs to be done
  castor::VectorAddress* ad = 
    dynamic_cast<castor::VectorAddress*>(address);
  int nb = ad->target().size();
  if (0 == nb) return res;
  try {
    // Check whether the statement is ok
    if (0 == m_bulkSelectStatement) {
      m_bulkSelectStatement = createStatement(s_bulkSelectStatementString);
      m_bulkSelectStatement->registerOutParam(2, castor::db::DBTYPE_CURSOR);
    }
    // set the buffer for input ids
    m_bulkSelectStatement->setDataBufferUInt64Array(1, ad->target());
    // Execute statement
    m_bulkSelectStatement->execute();
    // get the result, that is a cursor on the selected rows
    castor::db::IDbResultSet *rset =
      m_bulkSelectStatement->getCursor(2);
    // loop and create the new objects
    bool status = rset->next();
    while (status) {
      // create the new Object
      castor::vdqm::TapeRequest* object = new castor::vdqm::TapeRequest();
      // Now retrieve and set members
      object->setPriority(rset->getInt(1));
      object->setModificationTime(rset->getUInt64(2));
      object->setCreationTime(rset->getUInt64(3));
      object->setErrorCode(rset->getInt(4));
      object->setErrorMessage(rset->getString(5));
      object->setRemoteCopyType(rset->getString(6));
      object->setId(rset->getUInt64(7));
      object->setStatus((enum castor::vdqm::TapeRequestStatusCodes)rset->getInt(13));
      // store object in results and loop;
      res.push_back(object);
      status = rset->next();
    }
    delete rset;
    return res;
  } catch (castor::exception::SQLError& e) {
    castor::exception::InvalidArgument ex;
    ex.getMessage() << "Error in bulkSelect request :"
                    << std::endl << e.getMessage().str() << std::endl
                    << " was called in bulk with "
                    << nb << " items." << std::endl;
    throw ex;
  }
}

//------------------------------------------------------------------------------
// updateObj
//------------------------------------------------------------------------------
void castor::db::cnv::DbTapeRequestCnv::updateObj(castor::IObject* obj)
  throw (castor::exception::Exception) {
  try {
    // Check whether the statement is ok
    if (0 == m_selectStatement) {
      m_selectStatement = createStatement(s_selectStatementString);
    }
    // retrieve the object from the database
    m_selectStatement->setUInt64(1, obj->id());
    castor::db::IDbResultSet *rset = m_selectStatement->executeQuery();
    if (!rset->next()) {
      castor::exception::NoEntry ex;
      ex.getMessage() << "No object found for id :" << obj->id();
      throw ex;
    }
    // Now retrieve and set members
    castor::vdqm::TapeRequest* object = 
      dynamic_cast<castor::vdqm::TapeRequest*>(obj);
    object->setPriority(rset->getInt(1));
    object->setModificationTime(rset->getUInt64(2));
    object->setCreationTime(rset->getUInt64(3));
    object->setErrorCode(rset->getInt(4));
    object->setErrorMessage(rset->getString(5));
    object->setRemoteCopyType(rset->getString(6));
    object->setId(rset->getUInt64(7));
    object->setStatus((enum castor::vdqm::TapeRequestStatusCodes)rset->getInt(13));
    delete rset;
  } catch (castor::exception::SQLError& e) {
    castor::exception::InvalidArgument ex;
    ex.getMessage() << "Error in update request :"
                    << std::endl << e.getMessage().str() << std::endl
                    << "Statement was : " << std::endl
                    << s_updateStatementString << std::endl
                    << " and id was " << obj->id() << std::endl;;
    throw ex;
  }
}

