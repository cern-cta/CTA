/**** This file has been autogenerated by gencastor from Umbrello UML model ***/

/******************************************************************************
 *                      castor/db/cnv/DbTapeDriveCnv.cpp
 *
 * This file is part of the Castor project.
 * See http://castor.web.cern.ch/castor
 *
 * Copyright (C) 2003  CERN
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 *
 * @author Castor Dev team, castor-dev@cern.ch
 *****************************************************************************/

// Include Files
#include "DbTapeDriveCnv.hpp"
#include "castor/BaseAddress.hpp"
#include "castor/CnvFactory.hpp"
#include "castor/Constants.hpp"
#include "castor/IAddress.hpp"
#include "castor/ICnvSvc.hpp"
#include "castor/IObject.hpp"
#include "castor/VectorAddress.hpp"
#include "castor/db/DbCnvSvc.hpp"
#include "castor/exception/Exception.hpp"
#include "castor/exception/Internal.hpp"
#include "castor/exception/InvalidArgument.hpp"
#include "castor/exception/NoEntry.hpp"
#include "castor/exception/OutOfMemory.hpp"
#include "castor/vdqm/DeviceGroupName.hpp"
#include "castor/vdqm/TapeDrive.hpp"
#include "castor/vdqm/TapeDriveCompatibility.hpp"
#include "castor/vdqm/TapeDriveDedication.hpp"
#include "castor/vdqm/TapeDriveStatusCodes.hpp"
#include "castor/vdqm/TapeRequest.hpp"
#include "castor/vdqm/TapeServer.hpp"
#include "castor/vdqm/VdqmTape.hpp"
#include <algorithm>
#include <set>
#include <stdlib.h>
#include <vector>

//------------------------------------------------------------------------------
// Instantiation of a static factory class - should never be used
//------------------------------------------------------------------------------
static castor::CnvFactory<castor::db::cnv::DbTapeDriveCnv>* s_factoryDbTapeDriveCnv =
  new castor::CnvFactory<castor::db::cnv::DbTapeDriveCnv>();

//------------------------------------------------------------------------------
// Static constants initialization
//------------------------------------------------------------------------------
/// SQL statement for request insertion
const std::string castor::db::cnv::DbTapeDriveCnv::s_insertStatementString =
"INSERT INTO TapeDrive (jobID, modificationTime, resettime, usecount, errcount, transferredMB, totalMB, driveName, id, tape, runningTapeReq, deviceGroupName, status, tapeServer) VALUES (:1,:2,:3,:4,:5,:6,:7,:8,ids_seq.nextval,:9,:10,:11,:12,:13) RETURNING id INTO :14";

/// SQL statement for request deletion
const std::string castor::db::cnv::DbTapeDriveCnv::s_deleteStatementString =
"DELETE FROM TapeDrive WHERE id = :1";

/// SQL statement for request selection
const std::string castor::db::cnv::DbTapeDriveCnv::s_selectStatementString =
"SELECT jobID, modificationTime, resettime, usecount, errcount, transferredMB, totalMB, driveName, id, tape, runningTapeReq, deviceGroupName, status, tapeServer FROM TapeDrive WHERE id = :1";

/// SQL statement for bulk request selection
const std::string castor::db::cnv::DbTapeDriveCnv::s_bulkSelectStatementString =
"DECLARE \
   TYPE RecordType IS RECORD (jobID NUMBER, modificationTime INTEGER, resettime INTEGER, usecount NUMBER, errcount NUMBER, transferredMB NUMBER, totalMB INTEGER, driveName VARCHAR2(2048), id INTEGER, tape INTEGER, runningTapeReq INTEGER, deviceGroupName INTEGER, status INTEGER, tapeServer INTEGER); \
   TYPE CurType IS REF CURSOR RETURN RecordType; \
   PROCEDURE bulkSelect(ids IN castor.\"cnumList\", \
                        objs OUT CurType) AS \
   BEGIN \
     FORALL i IN ids.FIRST..ids.LAST \
       INSERT INTO bulkSelectHelper VALUES(ids(i)); \
     OPEN objs FOR SELECT jobID, modificationTime, resettime, usecount, errcount, transferredMB, totalMB, driveName, id, tape, runningTapeReq, deviceGroupName, status, tapeServer \
                     FROM TapeDrive t, bulkSelectHelper h \
                    WHERE t.id = h.objId; \
     DELETE FROM bulkSelectHelper; \
   END; \
 BEGIN \
   bulkSelect(:1, :2); \
 END;";

/// SQL statement for request update
const std::string castor::db::cnv::DbTapeDriveCnv::s_updateStatementString =
"UPDATE TapeDrive SET jobID = :1, modificationTime = :2, resettime = :3, usecount = :4, errcount = :5, transferredMB = :6, totalMB = :7, driveName = :8, status = :9 WHERE id = :10";

/// SQL statement for type storage
const std::string castor::db::cnv::DbTapeDriveCnv::s_storeTypeStatementString =
"INSERT /* TapeDrive class */ INTO Id2Type (id, type) VALUES (:1, :2)";

/// SQL statement for type deletion
const std::string castor::db::cnv::DbTapeDriveCnv::s_deleteTypeStatementString =
"DELETE FROM Id2Type WHERE id = :1";

/// SQL existence statement for member tape
const std::string castor::db::cnv::DbTapeDriveCnv::s_checkVdqmTapeExistStatementString =
"SELECT id FROM VdqmTape WHERE id = :1";

/// SQL update statement for member tape
const std::string castor::db::cnv::DbTapeDriveCnv::s_updateVdqmTapeStatementString =
"UPDATE TapeDrive SET tape = :1 WHERE id = :2";

/// SQL select statement for member runningTapeReq
const std::string castor::db::cnv::DbTapeDriveCnv::s_selectTapeRequestStatementString =
"SELECT id FROM TapeRequest WHERE tapeDrive = :1 FOR UPDATE";

/// SQL delete statement for member runningTapeReq
const std::string castor::db::cnv::DbTapeDriveCnv::s_deleteTapeRequestStatementString =
"UPDATE TapeRequest SET tapeDrive = 0 WHERE id = :1";

/// SQL remote update statement for member runningTapeReq
const std::string castor::db::cnv::DbTapeDriveCnv::s_remoteUpdateTapeRequestStatementString =
"UPDATE TapeRequest SET tapeDrive = :1 WHERE id = :2";

/// SQL existence statement for member runningTapeReq
const std::string castor::db::cnv::DbTapeDriveCnv::s_checkTapeRequestExistStatementString =
"SELECT id FROM TapeRequest WHERE id = :1";

/// SQL update statement for member runningTapeReq
const std::string castor::db::cnv::DbTapeDriveCnv::s_updateTapeRequestStatementString =
"UPDATE TapeDrive SET runningTapeReq = :1 WHERE id = :2";

/// SQL select statement for member tapeDriveDedication
const std::string castor::db::cnv::DbTapeDriveCnv::s_selectTapeDriveDedicationStatementString =
"SELECT id FROM TapeDriveDedication WHERE tapeDrive = :1 FOR UPDATE";

/// SQL delete statement for member tapeDriveDedication
const std::string castor::db::cnv::DbTapeDriveCnv::s_deleteTapeDriveDedicationStatementString =
"UPDATE TapeDriveDedication SET tapeDrive = 0 WHERE id = :1";

/// SQL remote update statement for member tapeDriveDedication
const std::string castor::db::cnv::DbTapeDriveCnv::s_remoteUpdateTapeDriveDedicationStatementString =
"UPDATE TapeDriveDedication SET tapeDrive = :1 WHERE id = :2";

/// SQL insert statement for member tapeDriveCompatibilities
const std::string castor::db::cnv::DbTapeDriveCnv::s_insertTapeDriveCompatibilityStatementString =
"INSERT INTO TapeDrive2TapeDriveComp (Parent, Child) VALUES (:1, :2)";

/// SQL delete statement for member tapeDriveCompatibilities
const std::string castor::db::cnv::DbTapeDriveCnv::s_deleteTapeDriveCompatibilityStatementString =
"DELETE FROM TapeDrive2TapeDriveComp WHERE Parent = :1 AND Child = :2";

/// SQL select statement for member tapeDriveCompatibilities
// The FOR UPDATE is needed in order to avoid deletion
// of a segment after listing and before update/remove
const std::string castor::db::cnv::DbTapeDriveCnv::s_selectTapeDriveCompatibilityStatementString =
"SELECT Child FROM TapeDrive2TapeDriveComp WHERE Parent = :1 FOR UPDATE";

/// SQL existence statement for member deviceGroupName
const std::string castor::db::cnv::DbTapeDriveCnv::s_checkDeviceGroupNameExistStatementString =
"SELECT id FROM DeviceGroupName WHERE id = :1";

/// SQL update statement for member deviceGroupName
const std::string castor::db::cnv::DbTapeDriveCnv::s_updateDeviceGroupNameStatementString =
"UPDATE TapeDrive SET deviceGroupName = :1 WHERE id = :2";

/// SQL existence statement for member tapeServer
const std::string castor::db::cnv::DbTapeDriveCnv::s_checkTapeServerExistStatementString =
"SELECT id FROM TapeServer WHERE id = :1";

/// SQL update statement for member tapeServer
const std::string castor::db::cnv::DbTapeDriveCnv::s_updateTapeServerStatementString =
"UPDATE TapeDrive SET tapeServer = :1 WHERE id = :2";

//------------------------------------------------------------------------------
// Constructor
//------------------------------------------------------------------------------
castor::db::cnv::DbTapeDriveCnv::DbTapeDriveCnv(castor::ICnvSvc* cnvSvc) :
  DbBaseCnv(cnvSvc),
  m_insertStatement(0),
  m_deleteStatement(0),
  m_selectStatement(0),
  m_bulkSelectStatement(0),
  m_updateStatement(0),
  m_storeTypeStatement(0),
  m_deleteTypeStatement(0),
  m_checkVdqmTapeExistStatement(0),
  m_updateVdqmTapeStatement(0),
  m_selectTapeRequestStatement(0),
  m_deleteTapeRequestStatement(0),
  m_remoteUpdateTapeRequestStatement(0),
  m_checkTapeRequestExistStatement(0),
  m_updateTapeRequestStatement(0),
  m_selectTapeDriveDedicationStatement(0),
  m_deleteTapeDriveDedicationStatement(0),
  m_remoteUpdateTapeDriveDedicationStatement(0),
  m_insertTapeDriveCompatibilityStatement(0),
  m_deleteTapeDriveCompatibilityStatement(0),
  m_selectTapeDriveCompatibilityStatement(0),
  m_checkDeviceGroupNameExistStatement(0),
  m_updateDeviceGroupNameStatement(0),
  m_checkTapeServerExistStatement(0),
  m_updateTapeServerStatement(0) {}

//------------------------------------------------------------------------------
// Destructor
//------------------------------------------------------------------------------
castor::db::cnv::DbTapeDriveCnv::~DbTapeDriveCnv() throw() {
  //Here we attempt to delete the statements correctly
  // If something goes wrong, we just ignore it
  try {
    if(m_insertStatement) delete m_insertStatement;
    if(m_deleteStatement) delete m_deleteStatement;
    if(m_selectStatement) delete m_selectStatement;
    if(m_bulkSelectStatement) delete m_bulkSelectStatement;
    if(m_updateStatement) delete m_updateStatement;
    if(m_storeTypeStatement) delete m_storeTypeStatement;
    if(m_deleteTypeStatement) delete m_deleteTypeStatement;
    if(m_checkVdqmTapeExistStatement) delete m_checkVdqmTapeExistStatement;
    if(m_updateVdqmTapeStatement) delete m_updateVdqmTapeStatement;
    if(m_deleteTapeRequestStatement) delete m_deleteTapeRequestStatement;
    if(m_selectTapeRequestStatement) delete m_selectTapeRequestStatement;
    if(m_remoteUpdateTapeRequestStatement) delete m_remoteUpdateTapeRequestStatement;
    if(m_checkTapeRequestExistStatement) delete m_checkTapeRequestExistStatement;
    if(m_updateTapeRequestStatement) delete m_updateTapeRequestStatement;
    if(m_deleteTapeDriveDedicationStatement) delete m_deleteTapeDriveDedicationStatement;
    if(m_selectTapeDriveDedicationStatement) delete m_selectTapeDriveDedicationStatement;
    if(m_remoteUpdateTapeDriveDedicationStatement) delete m_remoteUpdateTapeDriveDedicationStatement;
    if(m_insertTapeDriveCompatibilityStatement) delete m_insertTapeDriveCompatibilityStatement;
    if(m_deleteTapeDriveCompatibilityStatement) delete m_deleteTapeDriveCompatibilityStatement;
    if(m_selectTapeDriveCompatibilityStatement) delete m_selectTapeDriveCompatibilityStatement;
    if(m_checkDeviceGroupNameExistStatement) delete m_checkDeviceGroupNameExistStatement;
    if(m_updateDeviceGroupNameStatement) delete m_updateDeviceGroupNameStatement;
    if(m_checkTapeServerExistStatement) delete m_checkTapeServerExistStatement;
    if(m_updateTapeServerStatement) delete m_updateTapeServerStatement;
  } catch (castor::exception::Exception& ignored) {};
}

//------------------------------------------------------------------------------
// ObjType
//------------------------------------------------------------------------------
unsigned int castor::db::cnv::DbTapeDriveCnv::ObjType() {
  return castor::vdqm::TapeDrive::TYPE();
}

//------------------------------------------------------------------------------
// objType
//------------------------------------------------------------------------------
unsigned int castor::db::cnv::DbTapeDriveCnv::objType() const {
  return ObjType();
}

//------------------------------------------------------------------------------
// fillRep
//------------------------------------------------------------------------------
void castor::db::cnv::DbTapeDriveCnv::fillRep(castor::IAddress*,
                                              castor::IObject* object,
                                              unsigned int type,
                                              bool endTransaction)
  throw (castor::exception::Exception) {
  castor::vdqm::TapeDrive* obj = 
    dynamic_cast<castor::vdqm::TapeDrive*>(object);
  try {
    switch (type) {
    case castor::OBJ_VdqmTape :
      fillRepVdqmTape(obj);
      break;
    case castor::OBJ_TapeRequest :
      fillRepTapeRequest(obj);
      break;
    case castor::OBJ_TapeDriveDedication :
      fillRepTapeDriveDedication(obj);
      break;
    case castor::OBJ_TapeDriveCompatibility :
      fillRepTapeDriveCompatibility(obj);
      break;
    case castor::OBJ_DeviceGroupName :
      fillRepDeviceGroupName(obj);
      break;
    case castor::OBJ_TapeServer :
      fillRepTapeServer(obj);
      break;
    default :
      castor::exception::InvalidArgument ex;
      ex.getMessage() << "fillRep called for type " << type 
                      << " on object of type " << obj->type() 
                      << ". This is meaningless.";
      throw ex;
    }
    if (endTransaction) {
      cnvSvc()->commit();
    }
  } catch (castor::exception::SQLError& e) {
    castor::exception::Internal ex;
    ex.getMessage() << "Error in fillRep for type " << type
                    << std::endl << e.getMessage().str() << std::endl;
    throw ex;
  }
}

//------------------------------------------------------------------------------
// fillRepVdqmTape
//------------------------------------------------------------------------------
void castor::db::cnv::DbTapeDriveCnv::fillRepVdqmTape(castor::vdqm::TapeDrive* obj)
  throw (castor::exception::Exception) {
  if (0 != obj->tape()) {
    // Check checkVdqmTapeExist statement
    if (0 == m_checkVdqmTapeExistStatement) {
      m_checkVdqmTapeExistStatement = createStatement(s_checkVdqmTapeExistStatementString);
    }
    // retrieve the object from the database
    m_checkVdqmTapeExistStatement->setUInt64(1, obj->tape()->id());
    castor::db::IDbResultSet *rset = m_checkVdqmTapeExistStatement->executeQuery();
    if (!rset->next()) {
      castor::BaseAddress ad;
      ad.setCnvSvcName("DbCnvSvc");
      ad.setCnvSvcType(castor::SVC_DBCNV);
      cnvSvc()->createRep(&ad, obj->tape(), false, OBJ_TapeDrive);
    }
    // Close resultset
    delete rset;
  }
  // Check update statement
  if (0 == m_updateVdqmTapeStatement) {
    m_updateVdqmTapeStatement = createStatement(s_updateVdqmTapeStatementString);
  }
  // Update local object
  m_updateVdqmTapeStatement->setUInt64(1, 0 == obj->tape() ? 0 : obj->tape()->id());
  m_updateVdqmTapeStatement->setUInt64(2, obj->id());
  m_updateVdqmTapeStatement->execute();
}

//------------------------------------------------------------------------------
// fillRepTapeRequest
//------------------------------------------------------------------------------
void castor::db::cnv::DbTapeDriveCnv::fillRepTapeRequest(castor::vdqm::TapeDrive* obj)
  throw (castor::exception::Exception) {
  // Check selectTapeRequest statement
  if (0 == m_selectTapeRequestStatement) {
    m_selectTapeRequestStatement = createStatement(s_selectTapeRequestStatementString);
  }
  // retrieve the object from the database
  m_selectTapeRequestStatement->setUInt64(1, obj->id());
  castor::db::IDbResultSet *rset = m_selectTapeRequestStatement->executeQuery();
  if (rset->next()) {
    u_signed64 runningTapeReqId = rset->getInt64(1);
    if (0 != runningTapeReqId &&
        (0 == obj->runningTapeReq() ||
         obj->runningTapeReq()->id() != runningTapeReqId)) {
      if (0 == m_deleteTapeRequestStatement) {
        m_deleteTapeRequestStatement = createStatement(s_deleteTapeRequestStatementString);
      }
      m_deleteTapeRequestStatement->setUInt64(1, runningTapeReqId);
      m_deleteTapeRequestStatement->execute();
    }
  }
  // Close resultset
  delete rset;
  if (0 != obj->runningTapeReq()) {
    // Check checkTapeRequestExist statement
    if (0 == m_checkTapeRequestExistStatement) {
      m_checkTapeRequestExistStatement = createStatement(s_checkTapeRequestExistStatementString);
    }
    // retrieve the object from the database
    m_checkTapeRequestExistStatement->setUInt64(1, obj->runningTapeReq()->id());
    castor::db::IDbResultSet *rset = m_checkTapeRequestExistStatement->executeQuery();
    if (!rset->next()) {
      castor::BaseAddress ad;
      ad.setCnvSvcName("DbCnvSvc");
      ad.setCnvSvcType(castor::SVC_DBCNV);
      cnvSvc()->createRep(&ad, obj->runningTapeReq(), false, OBJ_TapeDrive);
    } else {
      // Check remote update statement
      if (0 == m_remoteUpdateTapeRequestStatement) {
        m_remoteUpdateTapeRequestStatement = createStatement(s_remoteUpdateTapeRequestStatementString);
      }
      // Update remote object
      m_remoteUpdateTapeRequestStatement->setUInt64(1, obj->id());
      m_remoteUpdateTapeRequestStatement->setUInt64(2, obj->runningTapeReq()->id());
      m_remoteUpdateTapeRequestStatement->execute();
    }
    // Close resultset
    delete rset;
  }
  // Check update statement
  if (0 == m_updateTapeRequestStatement) {
    m_updateTapeRequestStatement = createStatement(s_updateTapeRequestStatementString);
  }
  // Update local object
  m_updateTapeRequestStatement->setUInt64(1, 0 == obj->runningTapeReq() ? 0 : obj->runningTapeReq()->id());
  m_updateTapeRequestStatement->setUInt64(2, obj->id());
  m_updateTapeRequestStatement->execute();
}

//------------------------------------------------------------------------------
// fillRepTapeDriveDedication
//------------------------------------------------------------------------------
void castor::db::cnv::DbTapeDriveCnv::fillRepTapeDriveDedication(castor::vdqm::TapeDrive* obj)
  throw (castor::exception::Exception) {
  // check select statement
  if (0 == m_selectTapeDriveDedicationStatement) {
    m_selectTapeDriveDedicationStatement = createStatement(s_selectTapeDriveDedicationStatementString);
  }
  // Get current database data
  std::set<u_signed64> tapeDriveDedicationList;
  m_selectTapeDriveDedicationStatement->setUInt64(1, obj->id());
  castor::db::IDbResultSet *rset = m_selectTapeDriveDedicationStatement->executeQuery();
  while (rset->next()) {
    tapeDriveDedicationList.insert(rset->getUInt64(1));
  }
  delete rset;
  // update tapeDriveDedication and create new ones
  std::vector<castor::IObject*> toBeCreated;
  for (std::vector<castor::vdqm::TapeDriveDedication*>::iterator it = obj->tapeDriveDedication().begin();
       it != obj->tapeDriveDedication().end();
       it++) {
    if (0 == (*it)->id()) {
      toBeCreated.push_back(*it);
    } else {
      // Check remote update statement
      if (0 == m_remoteUpdateTapeDriveDedicationStatement) {
        m_remoteUpdateTapeDriveDedicationStatement = createStatement(s_remoteUpdateTapeDriveDedicationStatementString);
      }
      // Update remote object
      m_remoteUpdateTapeDriveDedicationStatement->setUInt64(1, obj->id());
      m_remoteUpdateTapeDriveDedicationStatement->setUInt64(2, (*it)->id());
      m_remoteUpdateTapeDriveDedicationStatement->execute();
      std::set<u_signed64>::iterator item;
      if ((item = tapeDriveDedicationList.find((*it)->id())) != tapeDriveDedicationList.end()) {
        tapeDriveDedicationList.erase(item);
      }
    }
  }
  // create new objects
  cnvSvc()->bulkCreateRep(0, toBeCreated, false, OBJ_TapeDrive);
  // Delete old links
  for (std::set<u_signed64>::iterator it = tapeDriveDedicationList.begin();
       it != tapeDriveDedicationList.end();
       it++) {
    if (0 == m_deleteTapeDriveDedicationStatement) {
      m_deleteTapeDriveDedicationStatement = createStatement(s_deleteTapeDriveDedicationStatementString);
    }
    m_deleteTapeDriveDedicationStatement->setUInt64(1, *it);
    m_deleteTapeDriveDedicationStatement->execute();
  }
}

//------------------------------------------------------------------------------
// fillRepTapeDriveCompatibility
//------------------------------------------------------------------------------
void castor::db::cnv::DbTapeDriveCnv::fillRepTapeDriveCompatibility(castor::vdqm::TapeDrive* obj)
  throw (castor::exception::Exception) {
  // check select statement
  if (0 == m_selectTapeDriveCompatibilityStatement) {
    m_selectTapeDriveCompatibilityStatement = createStatement(s_selectTapeDriveCompatibilityStatementString);
  }
  // Get current database data
  std::set<u_signed64> tapeDriveCompatibilitiesList;
  m_selectTapeDriveCompatibilityStatement->setUInt64(1, obj->id());
  castor::db::IDbResultSet *rset = m_selectTapeDriveCompatibilityStatement->executeQuery();
  while (rset->next()) {
    tapeDriveCompatibilitiesList.insert(rset->getUInt64(1));
  }
  delete rset;
  // update tapeDriveCompatibilities and create new ones
  for (std::vector<castor::vdqm::TapeDriveCompatibility*>::iterator it = obj->tapeDriveCompatibilities().begin();
       it != obj->tapeDriveCompatibilities().end();
       it++) {
    if (0 == (*it)->id()) {
      cnvSvc()->createRep(0, *it, false);
    }
    std::set<u_signed64>::iterator item;
    if ((item = tapeDriveCompatibilitiesList.find((*it)->id())) != tapeDriveCompatibilitiesList.end()) {
      tapeDriveCompatibilitiesList.erase(item);
    } else {
      if (0 == m_insertTapeDriveCompatibilityStatement) {
        m_insertTapeDriveCompatibilityStatement = createStatement(s_insertTapeDriveCompatibilityStatementString);
      }
      m_insertTapeDriveCompatibilityStatement->setUInt64(1, obj->id());
      m_insertTapeDriveCompatibilityStatement->setUInt64(2, (*it)->id());
      m_insertTapeDriveCompatibilityStatement->execute();
    }
  }
  // Delete old links
  for (std::set<u_signed64>::iterator it = tapeDriveCompatibilitiesList.begin();
       it != tapeDriveCompatibilitiesList.end();
       it++) {
    if (0 == m_deleteTapeDriveCompatibilityStatement) {
      m_deleteTapeDriveCompatibilityStatement = createStatement(s_deleteTapeDriveCompatibilityStatementString);
    }
    m_deleteTapeDriveCompatibilityStatement->setUInt64(1, obj->id());
    m_deleteTapeDriveCompatibilityStatement->setUInt64(2, *it);
    m_deleteTapeDriveCompatibilityStatement->execute();
  }
}

//------------------------------------------------------------------------------
// fillRepDeviceGroupName
//------------------------------------------------------------------------------
void castor::db::cnv::DbTapeDriveCnv::fillRepDeviceGroupName(castor::vdqm::TapeDrive* obj)
  throw (castor::exception::Exception) {
  if (0 != obj->deviceGroupName()) {
    // Check checkDeviceGroupNameExist statement
    if (0 == m_checkDeviceGroupNameExistStatement) {
      m_checkDeviceGroupNameExistStatement = createStatement(s_checkDeviceGroupNameExistStatementString);
    }
    // retrieve the object from the database
    m_checkDeviceGroupNameExistStatement->setUInt64(1, obj->deviceGroupName()->id());
    castor::db::IDbResultSet *rset = m_checkDeviceGroupNameExistStatement->executeQuery();
    if (!rset->next()) {
      castor::BaseAddress ad;
      ad.setCnvSvcName("DbCnvSvc");
      ad.setCnvSvcType(castor::SVC_DBCNV);
      cnvSvc()->createRep(&ad, obj->deviceGroupName(), false);
    }
    // Close resultset
    delete rset;
  }
  // Check update statement
  if (0 == m_updateDeviceGroupNameStatement) {
    m_updateDeviceGroupNameStatement = createStatement(s_updateDeviceGroupNameStatementString);
  }
  // Update local object
  m_updateDeviceGroupNameStatement->setUInt64(1, 0 == obj->deviceGroupName() ? 0 : obj->deviceGroupName()->id());
  m_updateDeviceGroupNameStatement->setUInt64(2, obj->id());
  m_updateDeviceGroupNameStatement->execute();
}

//------------------------------------------------------------------------------
// fillRepTapeServer
//------------------------------------------------------------------------------
void castor::db::cnv::DbTapeDriveCnv::fillRepTapeServer(castor::vdqm::TapeDrive* obj)
  throw (castor::exception::Exception) {
  if (0 != obj->tapeServer()) {
    // Check checkTapeServerExist statement
    if (0 == m_checkTapeServerExistStatement) {
      m_checkTapeServerExistStatement = createStatement(s_checkTapeServerExistStatementString);
    }
    // retrieve the object from the database
    m_checkTapeServerExistStatement->setUInt64(1, obj->tapeServer()->id());
    castor::db::IDbResultSet *rset = m_checkTapeServerExistStatement->executeQuery();
    if (!rset->next()) {
      castor::BaseAddress ad;
      ad.setCnvSvcName("DbCnvSvc");
      ad.setCnvSvcType(castor::SVC_DBCNV);
      cnvSvc()->createRep(&ad, obj->tapeServer(), false);
    }
    // Close resultset
    delete rset;
  }
  // Check update statement
  if (0 == m_updateTapeServerStatement) {
    m_updateTapeServerStatement = createStatement(s_updateTapeServerStatementString);
  }
  // Update local object
  m_updateTapeServerStatement->setUInt64(1, 0 == obj->tapeServer() ? 0 : obj->tapeServer()->id());
  m_updateTapeServerStatement->setUInt64(2, obj->id());
  m_updateTapeServerStatement->execute();
}

//------------------------------------------------------------------------------
// fillObj
//------------------------------------------------------------------------------
void castor::db::cnv::DbTapeDriveCnv::fillObj(castor::IAddress*,
                                              castor::IObject* object,
                                              unsigned int type,
                                              bool endTransaction)
  throw (castor::exception::Exception) {
  castor::vdqm::TapeDrive* obj = 
    dynamic_cast<castor::vdqm::TapeDrive*>(object);
  switch (type) {
  case castor::OBJ_VdqmTape :
    fillObjVdqmTape(obj);
    break;
  case castor::OBJ_TapeRequest :
    fillObjTapeRequest(obj);
    break;
  case castor::OBJ_TapeDriveDedication :
    fillObjTapeDriveDedication(obj);
    break;
  case castor::OBJ_TapeDriveCompatibility :
    fillObjTapeDriveCompatibility(obj);
    break;
  case castor::OBJ_DeviceGroupName :
    fillObjDeviceGroupName(obj);
    break;
  case castor::OBJ_TapeServer :
    fillObjTapeServer(obj);
    break;
  default :
    castor::exception::InvalidArgument ex;
    ex.getMessage() << "fillObj called on type " << type 
                    << " on object of type " << obj->type() 
                    << ". This is meaningless.";
    throw ex;
  }
  if (endTransaction) {
    cnvSvc()->commit();
  }
}

//------------------------------------------------------------------------------
// fillObjVdqmTape
//------------------------------------------------------------------------------
void castor::db::cnv::DbTapeDriveCnv::fillObjVdqmTape(castor::vdqm::TapeDrive* obj)
  throw (castor::exception::Exception) {
  // Check whether the statement is ok
  if (0 == m_selectStatement) {
    m_selectStatement = createStatement(s_selectStatementString);
  }
  // retrieve the object from the database
  m_selectStatement->setUInt64(1, obj->id());
  castor::db::IDbResultSet *rset = m_selectStatement->executeQuery();
  if (!rset->next()) {
    castor::exception::NoEntry ex;
    ex.getMessage() << "No object found for id :" << obj->id();
    throw ex;
  }
  u_signed64 tapeId = rset->getInt64(10);
  // Close ResultSet
  delete rset;
  // Check whether something should be deleted
  if (0 != obj->tape() &&
      (0 == tapeId ||
       obj->tape()->id() != tapeId)) {
    obj->setTape(0);
  }
  // Update object or create new one
  if (0 != tapeId) {
    if (0 == obj->tape()) {
      obj->setTape
        (dynamic_cast<castor::vdqm::VdqmTape*>
         (cnvSvc()->getObjFromId(tapeId)));
    } else {
      cnvSvc()->updateObj(obj->tape());
    }
  }
}

//------------------------------------------------------------------------------
// fillObjTapeRequest
//------------------------------------------------------------------------------
void castor::db::cnv::DbTapeDriveCnv::fillObjTapeRequest(castor::vdqm::TapeDrive* obj)
  throw (castor::exception::Exception) {
  // Check whether the statement is ok
  if (0 == m_selectStatement) {
    m_selectStatement = createStatement(s_selectStatementString);
  }
  // retrieve the object from the database
  m_selectStatement->setUInt64(1, obj->id());
  castor::db::IDbResultSet *rset = m_selectStatement->executeQuery();
  if (!rset->next()) {
    castor::exception::NoEntry ex;
    ex.getMessage() << "No object found for id :" << obj->id();
    throw ex;
  }
  u_signed64 runningTapeReqId = rset->getInt64(11);
  // Close ResultSet
  delete rset;
  // Check whether something should be deleted
  if (0 != obj->runningTapeReq() &&
      (0 == runningTapeReqId ||
       obj->runningTapeReq()->id() != runningTapeReqId)) {
    obj->runningTapeReq()->setTapeDrive(0);
    obj->setRunningTapeReq(0);
  }
  // Update object or create new one
  if (0 != runningTapeReqId) {
    if (0 == obj->runningTapeReq()) {
      obj->setRunningTapeReq
        (dynamic_cast<castor::vdqm::TapeRequest*>
         (cnvSvc()->getObjFromId(runningTapeReqId)));
    } else {
      cnvSvc()->updateObj(obj->runningTapeReq());
    }
    obj->runningTapeReq()->setTapeDrive(obj);
  }
}

//------------------------------------------------------------------------------
// fillObjTapeDriveDedication
//------------------------------------------------------------------------------
void castor::db::cnv::DbTapeDriveCnv::fillObjTapeDriveDedication(castor::vdqm::TapeDrive* obj)
  throw (castor::exception::Exception) {
  // Check select statement
  if (0 == m_selectTapeDriveDedicationStatement) {
    m_selectTapeDriveDedicationStatement = createStatement(s_selectTapeDriveDedicationStatementString);
  }
  // retrieve the object from the database
  std::vector<u_signed64> tapeDriveDedicationList;
  m_selectTapeDriveDedicationStatement->setUInt64(1, obj->id());
  castor::db::IDbResultSet *rset = m_selectTapeDriveDedicationStatement->executeQuery();
  while (rset->next()) {
    tapeDriveDedicationList.push_back(rset->getUInt64(1));
  }
  // Close ResultSet
  delete rset;
  // Update objects and mark old ones for deletion
  std::vector<castor::vdqm::TapeDriveDedication*> toBeDeleted;
  for (std::vector<castor::vdqm::TapeDriveDedication*>::iterator it = obj->tapeDriveDedication().begin();
       it != obj->tapeDriveDedication().end();
       it++) {
    std::vector<u_signed64>::iterator item =
      std::find(tapeDriveDedicationList.begin(), tapeDriveDedicationList.end(), (*it)->id());
    if (item == tapeDriveDedicationList.end()) {
      toBeDeleted.push_back(*it);
    } else {
      tapeDriveDedicationList.erase(item);
      cnvSvc()->updateObj((*it));
    }
  }
  // Delete old objects
  for (std::vector<castor::vdqm::TapeDriveDedication*>::iterator it = toBeDeleted.begin();
       it != toBeDeleted.end();
       it++) {
    obj->removeTapeDriveDedication(*it);
    (*it)->setTapeDrive(0);
  }
  // Create new objects
  std::vector<castor::IObject*> newTapeDriveDedication =
    cnvSvc()->getObjsFromIds(tapeDriveDedicationList, OBJ_TapeDriveDedication);
  for (std::vector<castor::IObject*>::iterator it = newTapeDriveDedication.begin();
       it != newTapeDriveDedication.end();
       it++) {
    castor::vdqm::TapeDriveDedication* remoteObj = 
      dynamic_cast<castor::vdqm::TapeDriveDedication*>(*it);
    obj->addTapeDriveDedication(remoteObj);
    remoteObj->setTapeDrive(obj);
  }
}

//------------------------------------------------------------------------------
// fillObjTapeDriveCompatibility
//------------------------------------------------------------------------------
void castor::db::cnv::DbTapeDriveCnv::fillObjTapeDriveCompatibility(castor::vdqm::TapeDrive* obj)
  throw (castor::exception::Exception) {
  // Check select statement
  if (0 == m_selectTapeDriveCompatibilityStatement) {
    m_selectTapeDriveCompatibilityStatement = createStatement(s_selectTapeDriveCompatibilityStatementString);
  }
  // retrieve the object from the database
  std::vector<u_signed64> tapeDriveCompatibilitiesList;
  m_selectTapeDriveCompatibilityStatement->setUInt64(1, obj->id());
  castor::db::IDbResultSet *rset = m_selectTapeDriveCompatibilityStatement->executeQuery();
  while (rset->next()) {
    tapeDriveCompatibilitiesList.push_back(rset->getUInt64(1));
  }
  // Close ResultSet
  delete rset;
  // Update objects and mark old ones for deletion
  std::vector<castor::vdqm::TapeDriveCompatibility*> toBeDeleted;
  for (std::vector<castor::vdqm::TapeDriveCompatibility*>::iterator it = obj->tapeDriveCompatibilities().begin();
       it != obj->tapeDriveCompatibilities().end();
       it++) {
    std::vector<u_signed64>::iterator item =
      std::find(tapeDriveCompatibilitiesList.begin(), tapeDriveCompatibilitiesList.end(), (*it)->id());
    if (item == tapeDriveCompatibilitiesList.end()) {
      toBeDeleted.push_back(*it);
    } else {
      tapeDriveCompatibilitiesList.erase(item);
      cnvSvc()->updateObj((*it));
    }
  }
  // Delete old objects
  for (std::vector<castor::vdqm::TapeDriveCompatibility*>::iterator it = toBeDeleted.begin();
       it != toBeDeleted.end();
       it++) {
    obj->removeTapeDriveCompatibilities(*it);
  }
  // Create new objects
  std::vector<castor::IObject*> newTapeDriveCompatibilities =
    cnvSvc()->getObjsFromIds(tapeDriveCompatibilitiesList, OBJ_TapeDriveCompatibility);
  for (std::vector<castor::IObject*>::iterator it = newTapeDriveCompatibilities.begin();
       it != newTapeDriveCompatibilities.end();
       it++) {
    castor::vdqm::TapeDriveCompatibility* remoteObj = 
      dynamic_cast<castor::vdqm::TapeDriveCompatibility*>(*it);
    obj->addTapeDriveCompatibilities(remoteObj);
  }
}

//------------------------------------------------------------------------------
// fillObjDeviceGroupName
//------------------------------------------------------------------------------
void castor::db::cnv::DbTapeDriveCnv::fillObjDeviceGroupName(castor::vdqm::TapeDrive* obj)
  throw (castor::exception::Exception) {
  // Check whether the statement is ok
  if (0 == m_selectStatement) {
    m_selectStatement = createStatement(s_selectStatementString);
  }
  // retrieve the object from the database
  m_selectStatement->setUInt64(1, obj->id());
  castor::db::IDbResultSet *rset = m_selectStatement->executeQuery();
  if (!rset->next()) {
    castor::exception::NoEntry ex;
    ex.getMessage() << "No object found for id :" << obj->id();
    throw ex;
  }
  u_signed64 deviceGroupNameId = rset->getInt64(12);
  // Close ResultSet
  delete rset;
  // Check whether something should be deleted
  if (0 != obj->deviceGroupName() &&
      (0 == deviceGroupNameId ||
       obj->deviceGroupName()->id() != deviceGroupNameId)) {
    obj->setDeviceGroupName(0);
  }
  // Update object or create new one
  if (0 != deviceGroupNameId) {
    if (0 == obj->deviceGroupName()) {
      obj->setDeviceGroupName
        (dynamic_cast<castor::vdqm::DeviceGroupName*>
         (cnvSvc()->getObjFromId(deviceGroupNameId)));
    } else {
      cnvSvc()->updateObj(obj->deviceGroupName());
    }
  }
}

//------------------------------------------------------------------------------
// fillObjTapeServer
//------------------------------------------------------------------------------
void castor::db::cnv::DbTapeDriveCnv::fillObjTapeServer(castor::vdqm::TapeDrive* obj)
  throw (castor::exception::Exception) {
  // Check whether the statement is ok
  if (0 == m_selectStatement) {
    m_selectStatement = createStatement(s_selectStatementString);
  }
  // retrieve the object from the database
  m_selectStatement->setUInt64(1, obj->id());
  castor::db::IDbResultSet *rset = m_selectStatement->executeQuery();
  if (!rset->next()) {
    castor::exception::NoEntry ex;
    ex.getMessage() << "No object found for id :" << obj->id();
    throw ex;
  }
  u_signed64 tapeServerId = rset->getInt64(14);
  // Close ResultSet
  delete rset;
  // Check whether something should be deleted
  if (0 != obj->tapeServer() &&
      (0 == tapeServerId ||
       obj->tapeServer()->id() != tapeServerId)) {
    obj->tapeServer()->removeTapeDrives(obj);
    obj->setTapeServer(0);
  }
  // Update object or create new one
  if (0 != tapeServerId) {
    if (0 == obj->tapeServer()) {
      obj->setTapeServer
        (dynamic_cast<castor::vdqm::TapeServer*>
         (cnvSvc()->getObjFromId(tapeServerId)));
    } else {
      cnvSvc()->updateObj(obj->tapeServer());
    }
    obj->tapeServer()->addTapeDrives(obj);
  }
}

//------------------------------------------------------------------------------
// createRep
//------------------------------------------------------------------------------
void castor::db::cnv::DbTapeDriveCnv::createRep(castor::IAddress*,
                                                castor::IObject* object,
                                                bool endTransaction,
                                                unsigned int type)
  throw (castor::exception::Exception) {
  castor::vdqm::TapeDrive* obj = 
    dynamic_cast<castor::vdqm::TapeDrive*>(object);
  // check whether something needs to be done
  if (0 == obj) return;
  if (0 != obj->id()) return;
  try {
    // Check whether the statements are ok
    if (0 == m_insertStatement) {
      m_insertStatement = createStatement(s_insertStatementString);
      m_insertStatement->registerOutParam(14, castor::db::DBTYPE_UINT64);
    }
    if (0 == m_storeTypeStatement) {
      m_storeTypeStatement = createStatement(s_storeTypeStatementString);
    }
    // Now Save the current object
    m_insertStatement->setInt(1, obj->jobID());
    m_insertStatement->setUInt64(2, obj->modificationTime());
    m_insertStatement->setUInt64(3, obj->resettime());
    m_insertStatement->setInt(4, obj->usecount());
    m_insertStatement->setInt(5, obj->errcount());
    m_insertStatement->setInt(6, obj->transferredMB());
    m_insertStatement->setUInt64(7, obj->totalMB());
    m_insertStatement->setString(8, obj->driveName());
    m_insertStatement->setUInt64(9, (type == OBJ_VdqmTape && obj->tape() != 0) ? obj->tape()->id() : 0);
    m_insertStatement->setUInt64(10, (type == OBJ_TapeRequest && obj->runningTapeReq() != 0) ? obj->runningTapeReq()->id() : 0);
    m_insertStatement->setUInt64(11, (type == OBJ_DeviceGroupName && obj->deviceGroupName() != 0) ? obj->deviceGroupName()->id() : 0);
    m_insertStatement->setInt(12, (int)obj->status());
    m_insertStatement->setUInt64(13, (type == OBJ_TapeServer && obj->tapeServer() != 0) ? obj->tapeServer()->id() : 0);
    m_insertStatement->execute();
    obj->setId(m_insertStatement->getUInt64(14));
    m_storeTypeStatement->setUInt64(1, obj->id());
    m_storeTypeStatement->setUInt64(2, obj->type());
    m_storeTypeStatement->execute();
    if (endTransaction) {
      cnvSvc()->commit();
    }
  } catch (castor::exception::SQLError& e) {
    // Always try to rollback
    try {
      if (endTransaction) cnvSvc()->rollback();
    } catch (castor::exception::Exception& ignored) {}
    castor::exception::InvalidArgument ex;
    ex.getMessage() << "Error in insert request :"
                    << std::endl << e.getMessage().str() << std::endl
                    << "Statement was : " << std::endl
                    << s_insertStatementString << std::endl
                    << " and parameters' values were :" << std::endl
                    << "  jobID : " << obj->jobID() << std::endl
                    << "  modificationTime : " << obj->modificationTime() << std::endl
                    << "  resettime : " << obj->resettime() << std::endl
                    << "  usecount : " << obj->usecount() << std::endl
                    << "  errcount : " << obj->errcount() << std::endl
                    << "  transferredMB : " << obj->transferredMB() << std::endl
                    << "  totalMB : " << obj->totalMB() << std::endl
                    << "  driveName : " << obj->driveName() << std::endl
                    << "  id : " << obj->id() << std::endl
                    << "  tape : " << (obj->tape() ? obj->tape()->id() : 0) << std::endl
                    << "  runningTapeReq : " << (obj->runningTapeReq() ? obj->runningTapeReq()->id() : 0) << std::endl
                    << "  deviceGroupName : " << (obj->deviceGroupName() ? obj->deviceGroupName()->id() : 0) << std::endl
                    << "  status : " << obj->status() << std::endl
                    << "  tapeServer : " << (obj->tapeServer() ? obj->tapeServer()->id() : 0) << std::endl;
    throw ex;
  }
}

//------------------------------------------------------------------------------
// bulkCreateRep
//------------------------------------------------------------------------------
void castor::db::cnv::DbTapeDriveCnv::bulkCreateRep(castor::IAddress*,
                                                    std::vector<castor::IObject*> &objects,
                                                    bool endTransaction,
                                                    unsigned int type)
  throw (castor::exception::Exception) {
  // check whether something needs to be done
  int nb = objects.size();
  if (0 == nb) return;
  // Casts all objects
  std::vector<castor::vdqm::TapeDrive*> objs;
  for (int i = 0; i < nb; i++) {
    objs.push_back(dynamic_cast<castor::vdqm::TapeDrive*>(objects[i]));
  }
  std::vector<void *> allocMem;
  try {
    // Check whether the statements are ok
    if (0 == m_insertStatement) {
      m_insertStatement = createStatement(s_insertStatementString);
      m_insertStatement->registerOutParam(14, castor::db::DBTYPE_UINT64);
    }
    if (0 == m_storeTypeStatement) {
      m_storeTypeStatement = createStatement(s_storeTypeStatementString);
    }
    // build the buffers for jobID
    int* jobIDBuffer = (int*) malloc(nb * sizeof(int));
    if (jobIDBuffer == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(jobIDBuffer);
    unsigned short* jobIDBufLens = (unsigned short*) malloc(nb * sizeof(unsigned short));
    if (jobIDBufLens == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(jobIDBufLens);
    for (int i = 0; i < nb; i++) {
      jobIDBuffer[i] = objs[i]->jobID();
      jobIDBufLens[i] = sizeof(int);
    }
    m_insertStatement->setDataBuffer
      (1, jobIDBuffer, castor::db::DBTYPE_INT, sizeof(jobIDBuffer[0]), jobIDBufLens);
    // build the buffers for modificationTime
    double* modificationTimeBuffer = (double*) malloc(nb * sizeof(double));
    if (modificationTimeBuffer == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(modificationTimeBuffer);
    unsigned short* modificationTimeBufLens = (unsigned short*) malloc(nb * sizeof(unsigned short));
    if (modificationTimeBufLens == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(modificationTimeBufLens);
    for (int i = 0; i < nb; i++) {
      modificationTimeBuffer[i] = objs[i]->modificationTime();
      modificationTimeBufLens[i] = sizeof(double);
    }
    m_insertStatement->setDataBuffer
      (2, modificationTimeBuffer, castor::db::DBTYPE_UINT64, sizeof(modificationTimeBuffer[0]), modificationTimeBufLens);
    // build the buffers for resettime
    double* resettimeBuffer = (double*) malloc(nb * sizeof(double));
    if (resettimeBuffer == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(resettimeBuffer);
    unsigned short* resettimeBufLens = (unsigned short*) malloc(nb * sizeof(unsigned short));
    if (resettimeBufLens == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(resettimeBufLens);
    for (int i = 0; i < nb; i++) {
      resettimeBuffer[i] = objs[i]->resettime();
      resettimeBufLens[i] = sizeof(double);
    }
    m_insertStatement->setDataBuffer
      (3, resettimeBuffer, castor::db::DBTYPE_UINT64, sizeof(resettimeBuffer[0]), resettimeBufLens);
    // build the buffers for usecount
    int* usecountBuffer = (int*) malloc(nb * sizeof(int));
    if (usecountBuffer == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(usecountBuffer);
    unsigned short* usecountBufLens = (unsigned short*) malloc(nb * sizeof(unsigned short));
    if (usecountBufLens == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(usecountBufLens);
    for (int i = 0; i < nb; i++) {
      usecountBuffer[i] = objs[i]->usecount();
      usecountBufLens[i] = sizeof(int);
    }
    m_insertStatement->setDataBuffer
      (4, usecountBuffer, castor::db::DBTYPE_INT, sizeof(usecountBuffer[0]), usecountBufLens);
    // build the buffers for errcount
    int* errcountBuffer = (int*) malloc(nb * sizeof(int));
    if (errcountBuffer == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(errcountBuffer);
    unsigned short* errcountBufLens = (unsigned short*) malloc(nb * sizeof(unsigned short));
    if (errcountBufLens == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(errcountBufLens);
    for (int i = 0; i < nb; i++) {
      errcountBuffer[i] = objs[i]->errcount();
      errcountBufLens[i] = sizeof(int);
    }
    m_insertStatement->setDataBuffer
      (5, errcountBuffer, castor::db::DBTYPE_INT, sizeof(errcountBuffer[0]), errcountBufLens);
    // build the buffers for transferredMB
    int* transferredMBBuffer = (int*) malloc(nb * sizeof(int));
    if (transferredMBBuffer == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(transferredMBBuffer);
    unsigned short* transferredMBBufLens = (unsigned short*) malloc(nb * sizeof(unsigned short));
    if (transferredMBBufLens == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(transferredMBBufLens);
    for (int i = 0; i < nb; i++) {
      transferredMBBuffer[i] = objs[i]->transferredMB();
      transferredMBBufLens[i] = sizeof(int);
    }
    m_insertStatement->setDataBuffer
      (6, transferredMBBuffer, castor::db::DBTYPE_INT, sizeof(transferredMBBuffer[0]), transferredMBBufLens);
    // build the buffers for totalMB
    double* totalMBBuffer = (double*) malloc(nb * sizeof(double));
    if (totalMBBuffer == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(totalMBBuffer);
    unsigned short* totalMBBufLens = (unsigned short*) malloc(nb * sizeof(unsigned short));
    if (totalMBBufLens == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(totalMBBufLens);
    for (int i = 0; i < nb; i++) {
      totalMBBuffer[i] = objs[i]->totalMB();
      totalMBBufLens[i] = sizeof(double);
    }
    m_insertStatement->setDataBuffer
      (7, totalMBBuffer, castor::db::DBTYPE_UINT64, sizeof(totalMBBuffer[0]), totalMBBufLens);
    // build the buffers for driveName
    unsigned int driveNameMaxLen = 0;
    for (int i = 0; i < nb; i++) {
      if (objs[i]->driveName().length()+1 > driveNameMaxLen)
        driveNameMaxLen = objs[i]->driveName().length()+1;
    }
    char* driveNameBuffer = (char*) calloc(nb, driveNameMaxLen);
    if (driveNameBuffer == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(driveNameBuffer);
    unsigned short* driveNameBufLens = (unsigned short*) malloc(nb * sizeof(unsigned short));
    if (driveNameBufLens == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(driveNameBufLens);
    for (int i = 0; i < nb; i++) {
      strncpy(driveNameBuffer+(i*driveNameMaxLen), objs[i]->driveName().c_str(), driveNameMaxLen);
      driveNameBufLens[i] = objs[i]->driveName().length()+1; // + 1 for the trailing \0
    }
    m_insertStatement->setDataBuffer
      (8, driveNameBuffer, castor::db::DBTYPE_STRING, driveNameMaxLen, driveNameBufLens);
    // build the buffers for tape
    double* tapeBuffer = (double*) malloc(nb * sizeof(double));
    if (tapeBuffer == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(tapeBuffer);
    unsigned short* tapeBufLens = (unsigned short*) malloc(nb * sizeof(unsigned short));
    if (tapeBufLens == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(tapeBufLens);
    for (int i = 0; i < nb; i++) {
      tapeBuffer[i] = (type == OBJ_VdqmTape && objs[i]->tape() != 0) ? objs[i]->tape()->id() : 0;
      tapeBufLens[i] = sizeof(double);
    }
    m_insertStatement->setDataBuffer
      (9, tapeBuffer, castor::db::DBTYPE_UINT64, sizeof(tapeBuffer[0]), tapeBufLens);
    // build the buffers for runningTapeReq
    double* runningTapeReqBuffer = (double*) malloc(nb * sizeof(double));
    if (runningTapeReqBuffer == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(runningTapeReqBuffer);
    unsigned short* runningTapeReqBufLens = (unsigned short*) malloc(nb * sizeof(unsigned short));
    if (runningTapeReqBufLens == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(runningTapeReqBufLens);
    for (int i = 0; i < nb; i++) {
      runningTapeReqBuffer[i] = (type == OBJ_TapeRequest && objs[i]->runningTapeReq() != 0) ? objs[i]->runningTapeReq()->id() : 0;
      runningTapeReqBufLens[i] = sizeof(double);
    }
    m_insertStatement->setDataBuffer
      (10, runningTapeReqBuffer, castor::db::DBTYPE_UINT64, sizeof(runningTapeReqBuffer[0]), runningTapeReqBufLens);
    // build the buffers for deviceGroupName
    double* deviceGroupNameBuffer = (double*) malloc(nb * sizeof(double));
    if (deviceGroupNameBuffer == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(deviceGroupNameBuffer);
    unsigned short* deviceGroupNameBufLens = (unsigned short*) malloc(nb * sizeof(unsigned short));
    if (deviceGroupNameBufLens == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(deviceGroupNameBufLens);
    for (int i = 0; i < nb; i++) {
      deviceGroupNameBuffer[i] = (type == OBJ_DeviceGroupName && objs[i]->deviceGroupName() != 0) ? objs[i]->deviceGroupName()->id() : 0;
      deviceGroupNameBufLens[i] = sizeof(double);
    }
    m_insertStatement->setDataBuffer
      (11, deviceGroupNameBuffer, castor::db::DBTYPE_UINT64, sizeof(deviceGroupNameBuffer[0]), deviceGroupNameBufLens);
    // build the buffers for status
    int* statusBuffer = (int*) malloc(nb * sizeof(int));
    if (statusBuffer == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(statusBuffer);
    unsigned short* statusBufLens = (unsigned short*) malloc(nb * sizeof(unsigned short));
    if (statusBufLens == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(statusBufLens);
    for (int i = 0; i < nb; i++) {
      statusBuffer[i] = objs[i]->status();
      statusBufLens[i] = sizeof(int);
    }
    m_insertStatement->setDataBuffer
      (12, statusBuffer, castor::db::DBTYPE_INT, sizeof(statusBuffer[0]), statusBufLens);
    // build the buffers for tapeServer
    double* tapeServerBuffer = (double*) malloc(nb * sizeof(double));
    if (tapeServerBuffer == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(tapeServerBuffer);
    unsigned short* tapeServerBufLens = (unsigned short*) malloc(nb * sizeof(unsigned short));
    if (tapeServerBufLens == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(tapeServerBufLens);
    for (int i = 0; i < nb; i++) {
      tapeServerBuffer[i] = (type == OBJ_TapeServer && objs[i]->tapeServer() != 0) ? objs[i]->tapeServer()->id() : 0;
      tapeServerBufLens[i] = sizeof(double);
    }
    m_insertStatement->setDataBuffer
      (13, tapeServerBuffer, castor::db::DBTYPE_UINT64, sizeof(tapeServerBuffer[0]), tapeServerBufLens);
    // build the buffers for returned ids
    double* idBuffer = (double*) calloc(nb, sizeof(double));
    if (idBuffer == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(idBuffer);
    unsigned short* idBufLens = (unsigned short*) calloc(nb, sizeof(unsigned short));
    if (idBufLens == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(idBufLens);
    m_insertStatement->setDataBuffer
      (14, idBuffer, castor::db::DBTYPE_UINT64, sizeof(double), idBufLens);
    m_insertStatement->execute(nb);
    for (int i = 0; i < nb; i++) {
      objects[i]->setId((u_signed64)idBuffer[i]);
    }
    // reuse idBuffer for bulk insertion into Id2Type
    m_storeTypeStatement->setDataBuffer
      (1, idBuffer, castor::db::DBTYPE_UINT64, sizeof(idBuffer[0]), idBufLens);
    // build the buffers for type
    int* typeBuffer = (int*) malloc(nb * sizeof(int));
    if (typeBuffer == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(typeBuffer);
    unsigned short* typeBufLens = (unsigned short*) malloc(nb * sizeof(unsigned short));
    if (typeBufLens == 0) {
      castor::exception::OutOfMemory e;
      throw e;
    }
    allocMem.push_back(typeBufLens);
    for (int i = 0; i < nb; i++) {
      typeBuffer[i] = objs[i]->type();
      typeBufLens[i] = sizeof(int);
    }
    m_storeTypeStatement->setDataBuffer
      (2, typeBuffer, castor::db::DBTYPE_INT, sizeof(typeBuffer[0]), typeBufLens);
    m_storeTypeStatement->execute(nb);
    // release the buffers
    for (unsigned int i = 0; i < allocMem.size(); i++) {
      free(allocMem[i]);
    }
    if (endTransaction) {
      cnvSvc()->commit();
    }
  } catch (castor::exception::SQLError& e) {
    // release the buffers
    for (unsigned int i = 0; i < allocMem.size(); i++) {
      free(allocMem[i]);
    }
    // Always try to rollback
    try {
      if (endTransaction) cnvSvc()->rollback();
    } catch (castor::exception::Exception& ignored) {}
    castor::exception::InvalidArgument ex;
    ex.getMessage() << "Error in bulkInsert request :"
                    << std::endl << e.getMessage().str() << std::endl
                    << " was called in bulk with "
                    << nb << " items." << std::endl;
    throw ex;
  }
}

//------------------------------------------------------------------------------
// updateRep
//------------------------------------------------------------------------------
void castor::db::cnv::DbTapeDriveCnv::updateRep(castor::IAddress*,
                                                castor::IObject* object,
                                                bool endTransaction)
  throw (castor::exception::Exception) {
  castor::vdqm::TapeDrive* obj = 
    dynamic_cast<castor::vdqm::TapeDrive*>(object);
  // check whether something needs to be done
  if (0 == obj) return;
  try {
    // Check whether the statements are ok
    if (0 == m_updateStatement) {
      m_updateStatement = createStatement(s_updateStatementString);
    }
    // Update the current object
    m_updateStatement->setInt(1, obj->jobID());
    m_updateStatement->setUInt64(2, obj->modificationTime());
    m_updateStatement->setUInt64(3, obj->resettime());
    m_updateStatement->setInt(4, obj->usecount());
    m_updateStatement->setInt(5, obj->errcount());
    m_updateStatement->setInt(6, obj->transferredMB());
    m_updateStatement->setUInt64(7, obj->totalMB());
    m_updateStatement->setString(8, obj->driveName());
    m_updateStatement->setInt(9, (int)obj->status());
    m_updateStatement->setUInt64(10, obj->id());
    m_updateStatement->execute();
    if (endTransaction) {
      cnvSvc()->commit();
    }
  } catch (castor::exception::SQLError& e) {
    // Always try to rollback
    try {
      if (endTransaction) cnvSvc()->rollback();
    } catch (castor::exception::Exception& ignored) {}
    castor::exception::InvalidArgument ex;
    ex.getMessage() << "Error in update request :"
                    << std::endl << e.getMessage().str() << std::endl
                    << "Statement was : " << std::endl
                    << s_updateStatementString << std::endl
                    << " and id was " << obj->id() << std::endl;;
    throw ex;
  }
}

//------------------------------------------------------------------------------
// deleteRep
//------------------------------------------------------------------------------
void castor::db::cnv::DbTapeDriveCnv::deleteRep(castor::IAddress*,
                                                castor::IObject* object,
                                                bool endTransaction)
  throw (castor::exception::Exception) {
  castor::vdqm::TapeDrive* obj = 
    dynamic_cast<castor::vdqm::TapeDrive*>(object);
  // check whether something needs to be done
  if (0 == obj) return;
  try {
    // Check whether the statements are ok
    if (0 == m_deleteStatement) {
      m_deleteStatement = createStatement(s_deleteStatementString);
    }
    if (0 == m_deleteTypeStatement) {
      m_deleteTypeStatement = createStatement(s_deleteTypeStatementString);
    }
    // Now Delete the object
    m_deleteTypeStatement->setUInt64(1, obj->id());
    m_deleteTypeStatement->execute();
    m_deleteStatement->setUInt64(1, obj->id());
    m_deleteStatement->execute();
    if (endTransaction) {
      cnvSvc()->commit();
    }
  } catch (castor::exception::SQLError& e) {
    // Always try to rollback
    try {
      if (endTransaction) cnvSvc()->rollback();
    } catch (castor::exception::Exception& ignored) {}
    castor::exception::InvalidArgument ex;
    ex.getMessage() << "Error in delete request :"
                    << std::endl << e.getMessage().str() << std::endl
                    << "Statement was : " << std::endl
                    << s_deleteStatementString << std::endl
                    << " and id was " << obj->id() << std::endl;;
    throw ex;
  }
}

//------------------------------------------------------------------------------
// createObj
//------------------------------------------------------------------------------
castor::IObject* castor::db::cnv::DbTapeDriveCnv::createObj(castor::IAddress* address)
  throw (castor::exception::Exception) {
  castor::BaseAddress* ad = 
    dynamic_cast<castor::BaseAddress*>(address);
  try {
    // Check whether the statement is ok
    if (0 == m_selectStatement) {
      m_selectStatement = createStatement(s_selectStatementString);
    }
    // retrieve the object from the database
    m_selectStatement->setUInt64(1, ad->target());
    castor::db::IDbResultSet *rset = m_selectStatement->executeQuery();
    if (!rset->next()) {
      castor::exception::NoEntry ex;
      ex.getMessage() << "No object found for id :" << ad->target();
      throw ex;
    }
    // create the new Object
    castor::vdqm::TapeDrive* object = new castor::vdqm::TapeDrive();
    // Now retrieve and set members
    object->setJobID(rset->getInt(1));
    object->setModificationTime(rset->getUInt64(2));
    object->setResettime(rset->getUInt64(3));
    object->setUsecount(rset->getInt(4));
    object->setErrcount(rset->getInt(5));
    object->setTransferredMB(rset->getInt(6));
    object->setTotalMB(rset->getUInt64(7));
    object->setDriveName(rset->getString(8));
    object->setId(rset->getUInt64(9));
    object->setStatus((enum castor::vdqm::TapeDriveStatusCodes)rset->getInt(13));
    delete rset;
    return object;
  } catch (castor::exception::SQLError& e) {
    castor::exception::InvalidArgument ex;
    ex.getMessage() << "Error in select request :"
                    << std::endl << e.getMessage().str() << std::endl
                    << "Statement was : " << std::endl
                    << s_selectStatementString << std::endl
                    << " and id was " << ad->target() << std::endl;;
    throw ex;
  }
}

//------------------------------------------------------------------------------
// bulkCreateObj
//------------------------------------------------------------------------------
std::vector<castor::IObject*>
castor::db::cnv::DbTapeDriveCnv::bulkCreateObj(castor::IAddress* address)
  throw (castor::exception::Exception) {
  // Prepare result
  std::vector<castor::IObject*> res;
  // check whether something needs to be done
  castor::VectorAddress* ad = 
    dynamic_cast<castor::VectorAddress*>(address);
  int nb = ad->target().size();
  if (0 == nb) return res;
  try {
    // Check whether the statement is ok
    if (0 == m_bulkSelectStatement) {
      m_bulkSelectStatement = createStatement(s_bulkSelectStatementString);
      m_bulkSelectStatement->registerOutParam(2, castor::db::DBTYPE_CURSOR);
    }
    // set the buffer for input ids
    m_bulkSelectStatement->setDataBufferUInt64Array(1, ad->target());
    // Execute statement
    m_bulkSelectStatement->execute();
    // get the result, that is a cursor on the selected rows
    castor::db::IDbResultSet *rset =
      m_bulkSelectStatement->getCursor(2);
    // loop and create the new objects
    bool status = rset->next();
    while (status) {
      // create the new Object
      castor::vdqm::TapeDrive* object = new castor::vdqm::TapeDrive();
      // Now retrieve and set members
      object->setJobID(rset->getInt(1));
      object->setModificationTime(rset->getUInt64(2));
      object->setResettime(rset->getUInt64(3));
      object->setUsecount(rset->getInt(4));
      object->setErrcount(rset->getInt(5));
      object->setTransferredMB(rset->getInt(6));
      object->setTotalMB(rset->getUInt64(7));
      object->setDriveName(rset->getString(8));
      object->setId(rset->getUInt64(9));
      object->setStatus((enum castor::vdqm::TapeDriveStatusCodes)rset->getInt(13));
      // store object in results and loop;
      res.push_back(object);
      status = rset->next();
    }
    delete rset;
    return res;
  } catch (castor::exception::SQLError& e) {
    castor::exception::InvalidArgument ex;
    ex.getMessage() << "Error in bulkSelect request :"
                    << std::endl << e.getMessage().str() << std::endl
                    << " was called in bulk with "
                    << nb << " items." << std::endl;
    throw ex;
  }
}

//------------------------------------------------------------------------------
// updateObj
//------------------------------------------------------------------------------
void castor::db::cnv::DbTapeDriveCnv::updateObj(castor::IObject* obj)
  throw (castor::exception::Exception) {
  try {
    // Check whether the statement is ok
    if (0 == m_selectStatement) {
      m_selectStatement = createStatement(s_selectStatementString);
    }
    // retrieve the object from the database
    m_selectStatement->setUInt64(1, obj->id());
    castor::db::IDbResultSet *rset = m_selectStatement->executeQuery();
    if (!rset->next()) {
      castor::exception::NoEntry ex;
      ex.getMessage() << "No object found for id :" << obj->id();
      throw ex;
    }
    // Now retrieve and set members
    castor::vdqm::TapeDrive* object = 
      dynamic_cast<castor::vdqm::TapeDrive*>(obj);
    object->setJobID(rset->getInt(1));
    object->setModificationTime(rset->getUInt64(2));
    object->setResettime(rset->getUInt64(3));
    object->setUsecount(rset->getInt(4));
    object->setErrcount(rset->getInt(5));
    object->setTransferredMB(rset->getInt(6));
    object->setTotalMB(rset->getUInt64(7));
    object->setDriveName(rset->getString(8));
    object->setId(rset->getUInt64(9));
    object->setStatus((enum castor::vdqm::TapeDriveStatusCodes)rset->getInt(13));
    delete rset;
  } catch (castor::exception::SQLError& e) {
    castor::exception::InvalidArgument ex;
    ex.getMessage() << "Error in update request :"
                    << std::endl << e.getMessage().str() << std::endl
                    << "Statement was : " << std::endl
                    << s_updateStatementString << std::endl
                    << " and id was " << obj->id() << std::endl;;
    throw ex;
  }
}

