#!/usr/bin/perl -w
#
# This test script will install the SQL schema scripts of castor and return
# an error if any of them does not compile properly
#

use strict;
use IPC::Open2;

sub main();
main;

sub connString ( $ ) {
  my $schema = shift;
  open(CONF, "< /etc/castor/SQLSchemaTests.conf")
    or die "Could not open /etc/castor/SQLSchemaTests.conf for reading: $!";
  while(<CONF>) {
    if ( /^${schema}=(.+\/.+\@.+)$/ ) {
      close CONF;
      return $1;
  }
  close CONF;
  die "Could not find connection string for schema ${schema}";
}

sub connParams ( $ ) {
  my $schema = shift;
  open(CONF, "< /etc/castor/SQLSchemaTests.conf")
    or die "Could not open /etc/castor/SQLSchemaTests.conf for reading: $!";
  while(<CONF>) {
    if ( /^${schema}=(.+)\/(.+)\@(.+)$/ ) {
      close CONF;
      return ( $1, $2, $3 );
    }
  }
  close CONF;
  die "Could not find connection string for schema ${schema}";
}

sub filterSQL ( $ ) {
  my $line = shift;
  my ( $NsDbUser, $NsDbPasswd, $NsDbName ) =  ( shift, shift, shift );
  $line=~ s/^ACCEPT/--ACCEPT/;
  $line=~ s/^PROMPT/--PROMPT/;
  $line=~ s/^UNDEF/--UNDEF/;
  $line=~ s/\&stageUid/123/g;
  $line=~ s/\&stageGid/456/g;
  $line=~ s/\&adminList/noadmin/g;
  $line=~ s/\&instanceName/SQLtestInstance/g;
  $line=~ s/\&stagerNsHost/SQLTestNameServer/g;
  $line=~ s/\&cnsUser/$NsDbUser/g;
  $line=~ s/\&cnsPasswd/$NsDbPasswd/g;
  $line=~ s/\&cnsDbName/$NsDbName/g;
  return $line;
}

my $check_complation = "
declare
  nerrorrs NUMBER;
  newnerros NUMBER;
begin
  select count(*) 
    into nerrors
    from user_objects
   where object_type = 'PROCEDURE' 
     and status = 'INVALID';
  while nerrors != 0
    for proc in (
      select object_name 
       from user_objects 
      where object_type = 'PROCEDURE' 
        and status = 'INVALID')
    loop
      begin
        execute immediate 'ALTER PROCEDURE ' || proc.object_name || ' COMPILE';
        DBMS_OUTPUT.put_line('successfully compiled ' || proc.object_name);
      exception when others then
        DBMS_OUTPUT.put_line('failed to compile ' || proc.object_name);
      end;
    end loop;
    select count(*) 
      into newnerrors
      from user_objects
     where object_type = 'PROCEDURE' 
       and status = 'INVALID';
    if newnerrors = nerrors then
      exit 1;
    else
      nerrors := newerrors;
    end if;
  end loop;
  exit 0;
end;
/
";

sub main () {
  my @SQLTests = ( "cns", "vmgr", "cupv", "vdqm", "stager");
  my ( $NsDbUser, $NsDbPasswd, $NsDbName ) =  connParams( "cns" );
  foreach my $st ( @SQLTests ) {
    my $pid = open ( SQP_OUT, SQP_IN, 'sqlplus /nolog' );
    write ( IN, "connect " . ( connParams($st) ) );
    open ( DROP, "< /usr/share/castor-@castorVersion@-@castorRelease@/sql/drop_oracle_schema.sql" ) 
      or die "Failed to open  for reading: $!";
    while (<DROP>) { write ( SQP_IN, $_ ); }
    close (DROP);
    my $sqlScript = "/usr/share/castor-@castorVersion@-@castorRelease@/sql/".$st."_oracle_create.sql";
    open ( SQL, "< ".$sqlScript ) or die "Failed to open $sqlScript for reading: $!";
    while (<SQL>) { write ( SQP_IN, filterSQL ( $_, $NsDbUser, $NsDbPasswd, $NsDbName ) ) }
    close ( SQL );
    write ( SQP, $check_complation );
    my $ret = waitpid ( $pid, 0 );
    if ($ret >> 8) die "The compilation of $sqlScript failed.";
  }
}


