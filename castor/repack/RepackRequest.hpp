/**** This file has been autogenerated by gencastor from Umbrello UML model ***/

/******************************************************************************
 *                      castor/repack/RepackRequest.hpp
 *
 * This file is part of the Castor project.
 * See http://castor.web.cern.ch/castor
 *
 * Copyright (C) 2003  CERN
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 *
 * @(#)$RCSfile$ $Revision$ $Release$ $Date$ $Author$
 *
 * 
 *
 * @author Castor Dev team, castor-dev@cern.ch
 *****************************************************************************/

#ifndef CASTOR_REPACK_REPACKREQUEST_HPP
#define CASTOR_REPACK_REPACKREQUEST_HPP

// Include Files
#include "castor/IObject.hpp"
#include "osdep.h"
#include <iostream>
#include <string>
#include <vector>

namespace castor {

  // Forward declarations
  class ObjectSet;

  namespace repack {

    // Forward declarations
    class RepackSubRequest;

    /**
     * class RepackRequest
     */
    class RepackRequest : public virtual castor::IObject {

    public:

      /**
       * Empty Constructor
       */
      RepackRequest() throw();

      /**
       * Empty Destructor
       */
      virtual ~RepackRequest() throw();

      /**
       * Outputs this object in a human readable format
       * @param stream The stream where to print this object
       * @param indent The indentation to use
       * @param alreadyPrinted The set of objects already printed.
       * This is to avoid looping when printing circular dependencies
       */
      virtual void print(std::ostream& stream,
                         std::string indent,
                         castor::ObjectSet& alreadyPrinted) const;

      /**
       * Outputs this object in a human readable format
       */
      virtual void print() const;

      /**
       * Gets the type of this kind of objects
       */
      static int TYPE();

      /********************************************/
      /* Implementation of IObject abstract class */
      /********************************************/
      /**
       * Gets the type of the object
       */
      virtual int type() const;

      /**
       * virtual method to clone any object
       */
      virtual castor::IObject* clone();

      /*********************************/
      /* End of IObject abstract class */
      /*********************************/
      /**
       * Get the value of m_machine
       * The machine name from which the request is send.
       * @return the value of m_machine
       */
      std::string machine() const {
        return m_machine;
      }

      /**
       * Set the value of m_machine
       * The machine name from which the request is send.
       * @param new_var the new value of m_machine
       */
      void setMachine(std::string new_var) {
        m_machine = new_var;
      }

      /**
       * Get the value of m_userName
       * The username of the user, who submits the request.
       * @return the value of m_userName
       */
      std::string userName() const {
        return m_userName;
      }

      /**
       * Set the value of m_userName
       * The username of the user, who submits the request.
       * @param new_var the new value of m_userName
       */
      void setUserName(std::string new_var) {
        m_userName = new_var;
      }

      /**
       * Get the value of m_creationTime
       * The creation time of the request
       * @return the value of m_creationTime
       */
      unsigned long creationTime() const {
        return m_creationTime;
      }

      /**
       * Set the value of m_creationTime
       * The creation time of the request
       * @param new_var the new value of m_creationTime
       */
      void setCreationTime(unsigned long new_var) {
        m_creationTime = new_var;
      }

      /**
       * Get the value of m_serviceclass
       * The service class to where the file have to be written. It is not possible to
       * specify directly the target tapes or tapepools. By default, the files are written
       * to the tapepool belonging to the repack service class specified in the castor
       * @return the value of m_serviceclass
       */
      std::string serviceclass() const {
        return m_serviceclass;
      }

      /**
       * Set the value of m_serviceclass
       * The service class to where the file have to be written. It is not possible to
       * specify directly the target tapes or tapepools. By default, the files are written
       * to the tapepool belonging to the repack service class specified in the castor
       * @param new_var the new value of m_serviceclass
       */
      void setServiceclass(std::string new_var) {
        m_serviceclass = new_var;
      }

      /**
       * Get the value of m_pid
       * @return the value of m_pid
       */
      u_signed64 pid() const {
        return m_pid;
      }

      /**
       * Set the value of m_pid
       * @param new_var the new value of m_pid
       */
      void setPid(u_signed64 new_var) {
        m_pid = new_var;
      }

      /**
       * Get the value of m_command
       * @return the value of m_command
       */
      int command() const {
        return m_command;
      }

      /**
       * Set the value of m_command
       * @param new_var the new value of m_command
       */
      void setCommand(int new_var) {
        m_command = new_var;
      }

      /**
       * Get the value of m_id
       * The id of this object
       * @return the value of m_id
       */
      u_signed64 id() const {
        return m_id;
      }

      /**
       * Set the value of m_id
       * The id of this object
       * @param new_var the new value of m_id
       */
      void setId(u_signed64 new_var) {
        m_id = new_var;
      }

      /**
       * Add a RepackSubRequest* object to the m_subRequestVector list
       */
      void addSubRequest(RepackSubRequest* add_object) {
        m_subRequestVector.push_back(add_object);
      }

      /**
       * Remove a RepackSubRequest* object from m_subRequestVector
       */
      void removeSubRequest(RepackSubRequest* remove_object) {
        for (unsigned int i = 0; i < m_subRequestVector.size(); i++) {
          RepackSubRequest* item = m_subRequestVector[i];
          if (item == remove_object) {
            std::vector<RepackSubRequest*>::iterator it = m_subRequestVector.begin() + i;
            m_subRequestVector.erase(it);
            return;
          }
        }
      }

      /**
       * Get the list of RepackSubRequest* objects held by m_subRequestVector
       * @return list of RepackSubRequest* objects held by m_subRequestVector
       */
      std::vector<RepackSubRequest*>& subRequest() {
        return m_subRequestVector;
      }

    private:

      /// The machine name from which the request is send.
      std::string m_machine;

      /// The username of the user, who submits the request.
      std::string m_userName;

      /// The creation time of the request
      unsigned long m_creationTime;

      /// The service class to where the file have to be written. It is not possible to specify directly the target tapes or tapepools. By default, the files are written to the tapepool belonging to the repack service class specified in the castor config file.
      std::string m_serviceclass;

      u_signed64 m_pid;

      int m_command;

      /// The id of this object
      u_signed64 m_id;

      std::vector<RepackSubRequest*> m_subRequestVector;

    }; // end of class RepackRequest

  }; // end of namespace repack

}; // end of namespace castor

#endif // CASTOR_REPACK_REPACKREQUEST_HPP
