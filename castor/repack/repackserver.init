#/******************************************************************************
#                      cleaning.init
#
# This file is part of the Castor project.
# See http://castor.web.cern.ch/castor
#
# Copyright (C) 2003  CERN
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
#
# @(#)$RCSfile: repackserver.init,v $ $Revision: 1.1 $ $Release$ $Date: 2006/09/06 12:27:53 $ $Author: sponcec3 $
#
# init script for the repack daemon
#
# chkconfig: 345 70 35
# description: repack daemon
#
# @author castor dev team
#*****************************************************************************/

#
## Oracle environment not needed if cern-instantclient is used
#
if [ -r /etc/sysconfig/castor ]; then
    . /etc/sysconfig/castor
fi

sysname=`uname -s`

# source function library
if [ -r /etc/rc.d/init.d/functions ]; then
    . /etc/rc.d/init.d/functions
    DAEMON=daemon
    FAILURE=failure
    ECHO_FAILURE=failure
    SUCCESS=success
    ECHO_SUCCESS=echo_success
    ECHO_END=echo
    if [ $sysname = "Linux" ]; then
        ECHOOPT=-n
    fi
else
    DAEMON=
    FAILURE=
    ECHO_FAILURE=
    SUCCESS=
    ECHO_SUCCESS=
    ECHOOPT=
    ECHO_END=
fi

RETVAL=0
prog="repackserver"
PIDFILE=/var/run/repackserver.pid
PIDDIR=/var/run
SUBSYS=/var/lock/subsys/repackserver
SUBSYSDIR=/var/lock/subsys
[ -z "$SILENTSTOP" ] && SILENTSTOP=0
REPACK=/usr/bin/repackserver
REPACKLOGDIR=/var/spool/repack
# Maui mode
OPTIONS=""
SYSCONFIGREPACK=/etc/sysconfig/repack

#
## Blindly attempt to create useful directories
#
[ ! -d $PIDDIR ] && mkdir -p $PIDDIR >& /dev/null
[ ! -d $SUBSYSDIR ] && mkdir -p $SUBSYSDIR >& /dev/null

if [ $sysname = "HP-UX" ]; then
    export UNIX95=1
fi
if [ $sysname = "SunOS" ]; then
    format4comm="fname"
else
    format4comm="comm"
fi

#
## Unless sysconfig says no the default is to run the server
#
RUN_REPACK=yes

case "$1" in
    start)
    echo $ECHOOPT "Starting $prog: "
    if [ -r $SYSCONFIGREPACK ]; then
            #
            ## Source the configuration
            #
        . $SYSCONFIGREPACK
        if [ "${RUN_REPACK}" != "yes" ]; then
            echo $ECHOOPT "$SYSCONFIGREPACK says NO: "
            [ -n "$FAILURE" ] && $FAILURE "$SYSCONFIGREPACK says NO: "
            RETVAL=1
        fi
        if [ -n "${ULIMIT_N}" ]; then
            ulimit -n ${ULIMIT_N}
        fi
        if [ -n "${ULIMIT_C}" ]; then
            ulimit -c ${ULIMIT_C}
        fi
    fi
    if [ $RETVAL -eq 0 ]; then
            #
            ## Because we might generate a core file
            ## We explicitely chdir in the workdir
            #
        cd $REPACKLOGDIR
        $DAEMON $REPACK $OPTIONS
        if [ $? -eq 0 ]; then
            [ -d $SUBSYSDIR ] && touch $SUBSYS
            if [ -d $PIDDIR ]; then
                pid=`ps -eo pid,ppid,$format4comm | egrep " 1 repackserver\$" | awk '{print $1}'`
                    # The point of $PIDFILE is that it kills only
                    # the master daemon.
                rm -f $PIDFILE
                if [ -n "$pid" ]; then
                    echo $pid > $PIDFILE
                    RETVAL=0
                else
                    echo $ECHOOPT "repackserver not started: "
                    [ -n "$FAILURE" ] && $FAILURE "repackserver not started: "
                    RETVAL=1
                fi
            else
                RETVAL=0
            fi
        else
            echo $ECHOOPT "repackserver not started: "
            [ -n "$FAILURE" ] && $FAILURE "repackserver not started: "
            RETVAL=1
        fi
    fi
    fi
    $ECHO_END
    ;;
    stop)
    if [ -f $PIDFILE ]; then
        [ $SILENTSTOP -eq 0 ] && echo $ECHOOPT "Stopping $prog: "
        kill -2 -`cat $PIDFILE` >& /dev/null
        #
        ## Wait 60 seconds maximum
        #
        stopped=0
        for i in 0 10 20 30 40 50; do
            for j in 0 1 2 3 4 5 6 7 8 9; do
                sleep 1
                mycheckpid `cat $PIDFILE`
                if [ $? -eq 0 ]; then
                    stopped=1
                    break
                fi
                [ $stopped -eq 1 ] && break
            done
        done
        if [ $stopped -ne 1 ]; then
            [ $SILENTSTOP -eq 0 ] && echo $ECHOOPT "Using kill -9 `cat $PIDFILE` "
            kill -9 -`cat $PIDFILE` >& /dev/null
            RETVAL=$?
        else
            RETVAL=0
        fi
        if [ $RETVAL -eq 0 ]; then
            rm -f $PIDFILE
        fi
    else
        # repackserver might have been started by hand
        pid=`ps -eo pid,ppid,$format4comm | egrep " 1 repackserver\$" | awk '{print $1}'`
        if [ -n "$pid" ]; then
            [ $SILENTSTOP -eq 0 ] && echo $ECHOOPT "Stopping $prog: "
            kill -2 -$pid >& /dev/null
            #
            ## Wait 60 seconds maximum
            #
            stopped=0
            for i in 0 10 20 30 40 50; do
                for j in 0 1 2 3 4 5 6 7 8 9; do
                    sleep 1
                    mycheckpid $pid
                    if [ $? -eq 0 ]; then
                        stopped=1
                        break
                    fi
                    [ $stopped -eq 1 ] && break
                done
            done
            if [ $stopped -ne 1 ]; then
                [ $SILENTSTOP -eq 0 ] && echo $ECHOOPT "Using kill -9 `cat $PIDFILE` "
                kill -9 -`cat $PIDFILE` >& /dev/null
                RETVAL=$?
            else
                RETVAL=0
            fi
        else
            [ $SILENTSTOP -eq 0 ] && echo $ECHOOPT "repackserver already stopped: "
            [ $SILENTSTOP -eq 0 -a -n "$FAILURE" ] && $FAILURE "repackserver already stopped: "
            RETVAL=1
        fi
    fi
    if [ $SILENTSTOP -eq 0 -a $sysname = "Linux" ]; then
        if [ $RETVAL -eq 0 ]; then
            $ECHO_SUCCESS
        else
            $ECHO_FAILURE
        fi
    fi
    [ -d $SUBSYSDIR ] && rm -f $SUBSYS
    [ $SILENTSTOP -eq 0 -a -n "$ECHO_END" ] && $ECHO_END
    #
    ## Basically: if SILENTSTOP is not 0 when we never print something
    ## But if the stop is successful... One might want to see stop: OK
    ## anyway ?
    #
    if [ $SILENTSTOP -ne 0 -a $RETVAL -eq 0 ]; then
        echo $ECHOOPT "Stopping $prog: "
        [ $sysname = "Linux" ] && $ECHO_SUCCESS
        [ -n "$ECHO_END" ] && $ECHO_END
    fi
    ;;
    restart)
    $0 stop
    if [ $? -eq 0 -o $SILENTSTOP -eq 0 ]; then
        $0 start
        RETVAL=$?
    else
        #
        ## It is legal to return zero it if was
        ## a conditional restart
        #
        if [ $SILENTSTOP -eq 0 ]; then
            RETVAL=1
        else
            RETVAL=0
        fi
    fi
    ;;
    condrestart)
    SILENTSTOP=1
    export SILENTSTOP
    $0 restart
    RETVAL=$?
    ;;
    status)
    pid=`ps -eo pid,ppid,$format4comm | egrep " 1 repackserver\$" | awk '{print $1}'`
    if [ -n "$pid" ]; then
        echo $ECHOOPT "repackserver (pid $pid) is running..."
        $ECHO_SUCCESS
        $ECHO_END
    else
        if [ -f $PIDFILE ]; then
            pid=`head -1 $PIDFILE`
            if [ "$pid" != "" ] ; then
                echo $ECHOOPT "repack dead but pid file exists"
                $ECHO_FAILURE
                $ECHO_END
            fi
        else
            if [ -f $SUBSYS ]; then
                echo $ECHOOPT "repack dead but subsys ($SUBSYS) locked"
            else
                echo $ECHOOPT "repack is stopped"
            fi
            $ECHO_FAILURE
            $ECHO_END
        fi
    fi
    ;;
    *)
    echo "Usage: $0 {start|stop|status|restart|condrestart}"
    RETVAL=1
    ;;
esac

exit $RETVAL
