/**** This file has been autogenerated by gencastor from Umbrello UML model ***/

/******************************************************************************
 *
 * This file is part of the Castor project.
 * See http://castor.web.cern.ch/castor
 *
 * Copyright (C) 2003  CERN
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 *
 * @author Castor Dev team, castor-dev@cern.ch
 *****************************************************************************/

#pragma once

// Include Files
#include "castor/IObject.hpp"
#include "osdep.h"
#include <iostream>
#include <string>

namespace castor {

  // Forward declarations
  class ObjectSet;

  namespace stager {

    // Forward declarations
    class FileClass;

    /**
     * class SvcClass
     * A service, as seen by the user.
     * A SvcClass is a container of resources and may be given as parameter of the
     * request.
     */
    class SvcClass : public virtual castor::IObject {

    public:

      /**
       * Empty Constructor
       */
      SvcClass() throw();

      /**
       * Empty Destructor
       */
      virtual ~SvcClass() throw();

      /**
       * Outputs this object in a human readable format
       * @param stream The stream where to print this object
       * @param indent The indentation to use
       * @param alreadyPrinted The set of objects already printed.
       * This is to avoid looping when printing circular dependencies
       */
      virtual void print(std::ostream& stream,
                         std::string indent,
                         castor::ObjectSet& alreadyPrinted) const;

      /**
       * Outputs this object in a human readable format
       */
      virtual void print() const;

      /**
       * Gets the type of this kind of objects
       */
      static int TYPE();

      /********************************************/
      /* Implementation of IObject abstract class */
      /********************************************/
      /**
       * Gets the type of the object
       */
      virtual int type() const;

      /**
       * virtual method to clone any object
       */
      virtual castor::IObject* clone();

      /*********************************/
      /* End of IObject abstract class */
      /*********************************/
      /**
       * Get the value of m_name
       * The name of this SvcClass.
       * @return the value of m_name
       */
      std::string name() const {
        return m_name;
      }

      /**
       * Set the value of m_name
       * The name of this SvcClass.
       * @param new_var the new value of m_name
       */
      void setName(std::string new_var) {
        m_name = new_var;
      }

      /**
       * Get the value of m_defaultFileSize
       * Default size used for space allocation in the case of a stage put with no size
       * explicitely given (ie size given was 0).
       * @return the value of m_defaultFileSize
       */
      u_signed64 defaultFileSize() const {
        return m_defaultFileSize;
      }

      /**
       * Set the value of m_defaultFileSize
       * Default size used for space allocation in the case of a stage put with no size
       * explicitely given (ie size given was 0).
       * @param new_var the new value of m_defaultFileSize
       */
      void setDefaultFileSize(u_signed64 new_var) {
        m_defaultFileSize = new_var;
      }

      /**
       * Get the value of m_replicaNb
       * Number of replicas for a file created with this service class
       * @return the value of m_replicaNb
       */
      int replicaNb() const {
        return m_replicaNb;
      }

      /**
       * Set the value of m_replicaNb
       * Number of replicas for a file created with this service class
       * @param new_var the new value of m_replicaNb
       */
      void setReplicaNb(int new_var) {
        m_replicaNb = new_var;
      }

      /**
       * Get the value of m_gcPolicy
       * Policy ruling the behavior of the garbage collector, when enabled.
       * @return the value of m_gcPolicy
       */
      std::string gcPolicy() const {
        return m_gcPolicy;
      }

      /**
       * Set the value of m_gcPolicy
       * Policy ruling the behavior of the garbage collector, when enabled.
       * @param new_var the new value of m_gcPolicy
       */
      void setGcPolicy(std::string new_var) {
        m_gcPolicy = new_var;
      }

      /**
       * Get the value of m_disk1Behavior
       * Flag to indicate whether the diskpools under this service class should behave as
       * Disk1 pools. This means no automatic GC, and failJobsWhenNoSpace set to true.
       * @return the value of m_disk1Behavior
       */
      bool disk1Behavior() const {
        return m_disk1Behavior;
      }

      /**
       * Set the value of m_disk1Behavior
       * Flag to indicate whether the diskpools under this service class should behave as
       * Disk1 pools. This means no automatic GC, and failJobsWhenNoSpace set to true.
       * @param new_var the new value of m_disk1Behavior
       */
      void setDisk1Behavior(bool new_var) {
        m_disk1Behavior = new_var;
      }

      /**
       * Get the value of m_failJobsWhenNoSpace
       * Flag to indicate whether jobs that require new space on disk shall be failed
       * when the diskpools under this service class have run out of space. This flag is
       * enabled by default, if disabled jobs are left pending in the scheduler.
       * @return the value of m_failJobsWhenNoSpace
       */
      bool failJobsWhenNoSpace() const {
        return m_failJobsWhenNoSpace;
      }

      /**
       * Set the value of m_failJobsWhenNoSpace
       * Flag to indicate whether jobs that require new space on disk shall be failed
       * when the diskpools under this service class have run out of space. This flag is
       * enabled by default, if disabled jobs are left pending in the scheduler.
       * @param new_var the new value of m_failJobsWhenNoSpace
       */
      void setFailJobsWhenNoSpace(bool new_var) {
        m_failJobsWhenNoSpace = new_var;
      }

      /**
       * Get the value of m_lastEditor
       * Name of the last one that modified this service class.
       * @return the value of m_lastEditor
       */
      std::string lastEditor() const {
        return m_lastEditor;
      }

      /**
       * Set the value of m_lastEditor
       * Name of the last one that modified this service class.
       * @param new_var the new value of m_lastEditor
       */
      void setLastEditor(std::string new_var) {
        m_lastEditor = new_var;
      }

      /**
       * Get the value of m_lastEditionTime
       * Time of the last modification of this service class.
       * @return the value of m_lastEditionTime
       */
      u_signed64 lastEditionTime() const {
        return m_lastEditionTime;
      }

      /**
       * Set the value of m_lastEditionTime
       * Time of the last modification of this service class.
       * @param new_var the new value of m_lastEditionTime
       */
      void setLastEditionTime(u_signed64 new_var) {
        m_lastEditionTime = new_var;
      }

      /**
       * Get the value of m_id
       * The id of this object
       * @return the value of m_id
       */
      u_signed64 id() const {
        return m_id;
      }

      /**
       * Set the value of m_id
       * The id of this object
       * @param new_var the new value of m_id
       */
      void setId(u_signed64 new_var) {
        m_id = new_var;
      }

      /**
       * Get the value of m_forcedFileClass
       * @return the value of m_forcedFileClass
       */
      FileClass* forcedFileClass() const {
        return m_forcedFileClass;
      }

      /**
       * Set the value of m_forcedFileClass
       * @param new_var the new value of m_forcedFileClass
       */
      void setForcedFileClass(FileClass* new_var) {
        m_forcedFileClass = new_var;
      }

    private:

      /// The name of this SvcClass.
      std::string m_name;

      /// Default size used for space allocation in the case of a stage put with no size explicitely given (ie size given was 0).
      u_signed64 m_defaultFileSize;

      /// Number of replicas for a file created with this service class.
      int m_replicaNb;

      /// Policy ruling the behavior of the garbage collector, when enabled.
      std::string m_gcPolicy;

      /// Flag to indicate whether the diskpools under this service class should behave as Disk1 pools. This means no automatic GC, and failJobsWhenNoSpace set to true.
      bool m_disk1Behavior;

      /// Flag to indicate whether jobs that require new space on disk shall be failed when the diskpools under this service class have run out of space. This flag is enabled by default, if disabled jobs are left pending in the scheduler.
      bool m_failJobsWhenNoSpace;

      /// Name of the last one that modified this service class.
      std::string m_lastEditor;

      /// Time of the last modification of this service class.
      u_signed64 m_lastEditionTime;

      /// The id of this object
      u_signed64 m_id;

      /// In case hasDiskOnlyBehavior is set, this is the file class that will be used for all files created in this svcclass, independently of the fileclass of the directory where they are created
      FileClass* m_forcedFileClass;

      /// In case hasDiskOnlyBehavior is set, this is the file class that will be used for all files created in this svcclass, independently of the fileclass of the directory where they are created
      /// In case hasDiskOnlyBehavior is set, this is the file class that will be used for all files created in this svcclass, independently of the fileclass of the directory where they are created
    }; /* end of class SvcClass */

  } /* end of namespace stager */

} /* end of namespace castor */

