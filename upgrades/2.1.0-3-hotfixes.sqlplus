CREATE OR REPLACE PROCEDURE updateFsFileClosed
(fs IN INTEGER, reservation IN INTEGER, fileSize IN INTEGER) AS
  deviation NUMBER;
  ds INTEGER;
  unused "numList";
BEGIN
  /* We have to do this first in order to take locks on all the filesystems
     of the DiskServer in an atomical way. Otherwise, the fact that
     we update the "single" filesystem fs first and then all the others
     leads to a dead lock if 2 threads are running this in parallel :
     they will both lock one filesystem to start with and try to get the
     others locks afterwards. */
  SELECT DiskServer INTO ds FROM FileSystem WHERE id = fs;
  SELECT id BULK COLLECT INTO unused FROM FileSystem WHERE diskServer = ds FOR UPDATE;
  /* now we can safely go */
  UPDATE FileSystem SET fsDeviation = fsdeviation / 2,
                       deltaFree = deltaFree - fileSize,
                       reservedSpace = reservedSpace - reservation
  WHERE id = fs RETURNING fsDeviation INTO deviation;
  UPDATE FileSystem SET deltaWeight = deltaWeight + deviation
   WHERE diskServer = ds;
END;
/


CREATE OR REPLACE PROCEDURE fileRecalled(tapecopyId IN INTEGER) AS
  SubRequestId NUMBER;
  dci NUMBER;
  fsId NUMBER;
  fileSize NUMBER;
  repackVid VARCHAR2(2048);
  cfid NUMBER;
BEGIN
  SELECT SubRequest.id, DiskCopy.id, CastorFile.filesize, SubRequest.repackVid, CastorFile.id
    INTO SubRequestId, dci, fileSize, repackVid, cfid
    FROM TapeCopy, SubRequest, DiskCopy, CastorFile
   WHERE TapeCopy.id = tapecopyId
     AND CastorFile.id = TapeCopy.castorFile
     AND DiskCopy.castorFile = TapeCopy.castorFile
     AND SubRequest.diskcopy(+) = DiskCopy.id
     AND DiskCopy.status = 2;
  UPDATE DiskCopy SET status = decode(repackVid, NULL,0, 6)  -- DISKCOPY_STAGEOUT if repackVid != NULL, else DISKCOPY_STAGED 
   WHERE id = dci RETURNING fileSystem INTO fsid;
  IF repackVid IS NOT NULL THEN
  	putDoneFunc(cfid, fsId, 0);
  END IF;
  IF subRequestId IS NOT NULL THEN
    UPDATE SubRequest SET status = 1, lastModificationTime = getTime(), parent = 0  -- SUBREQUEST_RESTART
     WHERE id = SubRequestId; 
    UPDATE SubRequest SET status = 1, lastModificationTime = getTime(), parent = 0  -- SUBREQUEST_RESTART
     WHERE parent = SubRequestId;
  END IF;
  updateFsFileClosed(fsId, fileSize, fileSize);
END;
/

CREATE OR REPLACE PROCEDURE putFailedProc(srId IN NUMBER) AS
  dcId INTEGER;
  fsId INTEGER;
  cfId INTEGER;
  unused INTEGER;
  reservedSpace INTEGER;
BEGIN
  -- Set SubRequest in FAILED status
  UPDATE SubRequest
     SET status = 7 -- FAILED
   WHERE id = srId
  RETURNING diskCopy, xsize, castorFile
    INTO dcId, reservedSpace, cfId;
  SELECT fileSystem INTO fsId FROM DiskCopy WHERE id = dcId;
  -- free reserved space
  updateFsFileClosed(fsId, reservedSpace, 0);
  -- Determine the context (Put inside PrepareToPut ?)
  BEGIN
    -- check that there is a PrepareToPut going on
    SELECT SubRequest.diskCopy INTO unused
      FROM StagePrepareToPutRequest, SubRequest
     WHERE SubRequest.CastorFile = cfId
       AND StagePrepareToPutRequest.id = SubRequest.request;
    -- the select worked out, so we have a prepareToPut
    -- In such a case, we do not cleanup DiskCopy and CastorFile
  EXCEPTION WHEN NO_DATA_FOUND THEN
    -- this means we are a standalone put
    -- thus cleanup DiskCopy and CastorFile
    DELETE FROM DiskCopy WHERE id = dcId;
    DELETE FROM CastorFile WHERE id = cfId;
  END;   
END;
/


CREATE OR REPLACE PROCEDURE prepareForMigration (srId IN INTEGER,
                                                 fs IN INTEGER,
                                                 fId OUT NUMBER,
                                                 nh OUT VARCHAR2,
                                                 userId OUT INTEGER,
                                                 groupId OUT INTEGER) AS
  cfId INTEGER;
  fsId INTEGER;
  reservedSpace NUMBER;
  unused INTEGER;
  contextPIPP INTEGER;
BEGIN
 -- get CastorFile
 SELECT castorFile INTO cfId FROM SubRequest where id = srId;
 -- update CastorFile. This also takes a lock on it, insuring
 -- with triggers that we are the only ones to deal with its copies
 UPDATE CastorFile set fileSize = fs WHERE id = cfId
  RETURNING fileId, nsHost INTO fId, nh;
 -- Determine the context (Put inside PrepareToPut or not)
 BEGIN
   -- check that we are a Put
   SELECT StagePutRequest.id INTO unused
     FROM StagePutRequest, SubRequest
    WHERE SubRequest.id = srId
      AND StagePutRequest.id = SubRequest.request;
   BEGIN
     -- check that there is a PrepareToPut going on
     SELECT SubRequest.diskCopy INTO unused
       FROM StagePrepareToPutRequest, SubRequest
      WHERE SubRequest.CastorFile = cfId
        AND StagePrepareToPutRequest.id = SubRequest.request
        AND SubRequest.status IN (0, 1, 2, 3, 4, 5, 6, 7, 10);  -- All but FINISHED, FAILED_FINISHED, ARCHIVED
     -- if we got here, we are a Put inside a PrepareToPut
     contextPIPP := 0;
   EXCEPTION WHEN NO_DATA_FOUND THEN
     -- here we are a standalone Put
     contextPIPP := 1;
   END;
 EXCEPTION WHEN NO_DATA_FOUND THEN
   -- here we are a PutDone
   contextPIPP := 2;
 END;
 -- get uid, gid and reserved space from Request
 SELECT euid, egid, xsize INTO userId, groupId, reservedSpace FROM SubRequest,
     (SELECT euid, egid, id from StagePutRequest UNION ALL
      SELECT euid, egid, id from StagePutDoneRequest) Request
  WHERE SubRequest.request = Request.id AND SubRequest.id = srId;
 -- If not a put inside a PrepareToPut, update the FileSystem free space
 IF contextPIPP != 0 THEN
   SELECT fileSystem into fsId from DiskCopy
    WHERE castorFile = cfId AND status = 6;
   updateFsFileClosed(fsId, reservedSpace, fs);
 END IF;
 -- archive Subrequest
 archiveSubReq(srId);
 --  If not a put inside a PrepareToPut, create TapeCopies and update DiskCopy status
 IF contextPIPP != 0 THEN
   putDoneFunc(cfId, fs, contextPIPP);
 END IF;
 -- If put inside PrepareToPut, restart any PutDone currently
 -- waiting on this put
 IF contextPIPP = 0 THEN
   UPDATE SubRequest SET status = 1 -- RESTART
    WHERE id IN
     (SELECT SubRequest.id FROM SubRequest, Id2Type
       WHERE SubRequest.request = Id2Type.id
         AND Id2Type.type = 39       -- PutDone
         AND SubRequest.castorFile = cfId
         AND SubRequest.status = 5); -- WAITSUBREQ
 END IF;
 COMMIT;
END;
/


CREATE OR REPLACE TRIGGER tr_FileSystem_Update
AFTER UPDATE OF free, deltaFree, reservedSpace ON FileSystem
FOR EACH ROW
DECLARE
  freeSpace NUMBER;
  jobid NUMBER;
  gccount INTEGER;
  CONSTRAINT_VIOLATED EXCEPTION;
  PRAGMA EXCEPTION_INIT(CONSTRAINT_VIOLATED, -1);
BEGIN
  -- compute the actual free space taking into account reservations (reservedSpace)
  -- and already running GC processes (spaceToBeFreed)
  freeSpace := :new.free + :new.deltaFree - :new.reservedSpace + :new.spaceToBeFreed;
  -- shall we launch a new GC?
  IF :new.minFreeSpace * :new.totalSize  > freeSpace AND
     -- is it really worth launching it? (some other GCs maybe are already running
     -- so we accept it only if it will free more than 5 Gb)
     :new.maxFreeSpace * :new.totalSize > freeSpace + 5000000000 THEN
    -- ok, we queue this filesystem for being garbage collected
    -- we have to take a lock so that a previous job that would finish right
    -- now will wait for our insert and take the new filesystem
    LOCK TABLE FileSystemGC IN ROW SHARE MODE;
    SELECT count(*) INTO gccount FROM FileSystemGC;
    INSERT INTO FileSystemGC VALUES (:new.id, getTime());
    -- is it the only filesystem waiting for GC?
    IF gccount = 0 THEN
      -- we spawn a job to do the real work. This avoids mutating table error
      -- and ensures that the current update does not fail if GC fails
      DBMS_JOB.SUBMIT(jobid,'garbageCollect();');
    END IF;
    COMMIT;
    -- otherwise, a job is already running and will take over this file system too
  END IF;
  EXCEPTION
    -- the filesystem was already selected for GC, do nothing
    WHEN CONSTRAINT_VIOLATED THEN NULL;
END;
/


