#!/bin/python

# The CERN Tape Archive (CTA) project
# Copyright (C) 2015  CERN
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import argparse
import ConfigParser
import datetime
import getpass
import logging
import logging.config
import os
import re
import socket
import subprocess
import sys
import time

class UserError(Exception):
  pass

class Gc:
  '''Implements the cta-fst-gcd daemon that runs on an EOS FST and garbage
  collects EOS disk copies that have been safely stored to tape.

  The cta-fst-gcd daemon scans across every single EOS disk file on an FST.
  A file is garbage collected if:

  * The amount of free space on the corresponding file system is
    considered too low.

  * The file is considered old enough to be garbage collected.

  The cta-fst-gcd daemon garbage collects an EOS disk file by extracting the
  hexadecimal EOS file identifier from the local disk filename and then
  running eos stagerm fxid:<fid-hex>.'''

  def get_env_mgmhost(self):
    logger = logging.getLogger('gc')

    if "EOS_MGM_URL" in self.env:
      mgm_url = self.env["EOS_MGM_URL"]
      mgmhost = re.sub("^x?root://", "", mgm_url)
      logger.info("Determined MGM host {} from EOS_MGM_URL".format(mgmhost))
      return mgmhost
 
    logger.info("The environment variable EOS_MGM_URL is not set")

  def get_syconfig_mgmhost(self):
    logger = logging.getLogger('gc')
    eos_env = '/etc/sysconfig/eos_env'

    if os.path.isfile(eos_env) and os.access(eos_env, os.W_OK):
      sysconfig_file = open(eos_env, "r")
      for line in sysconfig_file:
        mgmhostline = re.match("^EOS_MGM_HOST=.*", line)
        if mgmhostline:
          splitmgmhostline = mgmhostline.group(0).split('=')
          if 2 == len(splitmgmhostline):
            mgmhost = splitmgmhostline[1]
            logger.info("Extracted MGM host {} from {}".format(mgmhost, eos_env))
            return mgmhost

    logger.info("Could not determine MGM host from {}".format(eos_env))

  def setmgmhost(self):
    self.mgmhost = self.get_env_mgmhost()
    if self.mgmhost:
      return

    self.mgmhost = self.get_syconfig_mgmhost()
    if self.mgmhost:
      return

    raise UserError("Could not determine the MGM host from EOS_MGM_URL or from /etc/sysconfig/eos_env")

  def configuredummylogging(self):
    config = {
      'version': 1,
      'disable_existing_loggers': False,
      'loggers': {
        'gc' : {
          'level': 'INFO'
        }
      }
    }
    logging.config.dictConfig(config)

  def configurereallogging(self):
    if None == self.logfile:
      raise Exception("Cannot configure file based logging because the log file path has not been set")

    loggingdir = os.path.dirname(self.logfile)
    if not os.path.isdir(loggingdir):
      raise UserError("The logging directory {} is not a directory or does not exist".format(loggingdir))
    if not os.access(loggingdir, os.W_OK):
      raise UserError("The logging directory {} cannot be written to by {}".format(loggingdir, self.programname))

    config = {
      'version': 1,
      'disable_existing_loggers': False,
      'formatters': { 
        'stdout': { 
            'format': '%(asctime)s.%(msecs)03d000 %(levelname)s ' + self.programname +
              ': LVL="%(levelname)s" PID="%(process)d" TID="%(process)d" MSG="%(message)s"',
            'datefmt': '%Y/%m/%d %H:%M:%S'
        }
      },
      'handlers': { 
        'logfile': { 
          'level': 'INFO',
          'formatter': 'stdout',
          'class': 'logging.handlers.TimedRotatingFileHandler',
          'filename' : self.logfile,
          'when' : 'midnight'
        }
      },
      'loggers': {
        'gc' : {
          'handlers': ['logfile'],
          'level': 'INFO'
        }
      }
    }
    # Failing to configure the logging system is usually a user error
    try:
      logging.config.dictConfig(config)
    except Exception as err:
      raise UserError(err)

  def configurelogging(self):
    if None == self.logfile:
      self.configuredummylogging()
    else:
      self.configurereallogging()

  def __init__(self, env, logfile):
    self.programname = 'cta-fst-gcd'
    self.env = env
    self.conffilepath = '/etc/cta/cta-fst-gcd.conf'
    self.logfile = logfile
    self.fqdn = socket.getfqdn()
    self.localfilesystempaths = []
    self.nbfilesconsideredsincelastreport = 0
    self.nbfilesbeforereport = 10000
    self.mgmhost = None

  def eosfsls(self):
    logger = logging.getLogger('gc')
    mgmurl = "root://{}".format(self.mgmhost)
    cmd = "eos -r 0 0 {} fs ls -m".format(mgmurl)
    env = os.environ.copy()
    env["XrdSecPROTOCOL"] = "sss"
    process = subprocess.Popen(cmd.split(), stdout=subprocess.PIPE, stderr=subprocess.PIPE, env=env)
    stdout,stderr = process.communicate()

    result = []

    if 0 != process.returncode:
      returncodestr = os.strerror(process.returncode)
      stderrstr = stderr.replace('\n', ' ').replace('\r', '').strip()
      logger.error("Failed to execute {}: returncode={} returncodestr='{}' stderr='{}'"
        .format(cmd, process.returncode, returncodestr, stderrstr))
    else:
      lines = stdout.splitlines();
      for l in lines:
        linedict = {}
        pairs = l.split()
        for p in pairs:
          splitpair = p.split('=')
          if 2 == len(splitpair):
            linedict[splitpair[0]] = splitpair[1]
        if linedict:
          result.append(linedict)

    return result

  def eosstagerrm(self, fxid, subdir, freebytes):
    logger = logging.getLogger('gc')
    mgmurl = "root://{}".format(self.mgmhost)
    cmd = "eos {} stagerrm fxid:{}".format(mgmurl, fxid)
    env = os.environ.copy()
    env["XrdSecPROTOCOL"] = "sss"
    process = subprocess.Popen(cmd.split(), stdout=subprocess.PIPE, stderr=subprocess.PIPE, env=env)
    stdout,stderr = process.communicate()
    if 0 == process.returncode:
      logger.info("minfreebytes={} subdir={} freebytesbefore={} executed='{}'".format(self.minfreebytes, subdir, freebytes, cmd))

  def processfile(self, subdir, fstfile):
    statvfs = os.statvfs(subdir)
    freebytes = statvfs.f_frsize * statvfs.f_bavail
    spaceshouldefreed = freebytes < self.minfreebytes

    if spaceshouldefreed:
      fullpath = os.path.join(subdir,fstfile)
      statinfo = os.stat(fullpath)
      now = time.time()
      agesecs = now - statinfo.st_ctime
      if agesecs > self.gcagesecs:
        self.eosstagerrm(fstfile, subdir, freebytes)

    self.nbfilesconsideredsincelastreport = self.nbfilesconsideredsincelastreport + 1
    if self.nbfilesbeforereport == self.nbfilesconsideredsincelastreport:
      self.nbfilesconsideredsincelastreport = 0
      logger = logging.getLogger('gc')
      logger.info('Considered another {} files'.format(self.nbfilesbeforereport))

  def processfssubdir(self, subdir):
    logger = logging.getLogger('gc')
    fstfiles = [f for f in os.listdir(subdir)
      if re.match('^[0-9A-Fa-f]{8}$', f) and os.path.isfile(os.path.join(subdir, f))]
    for fstfile in fstfiles:
      self.processfile(subdir, fstfile)

  def processfs(self, path):
    fssubdirs = [os.path.join(path, f) for f in os.listdir(path)
      if re.match('^[0-9A-Fa-f]{8}$', f) and os.path.isdir(os.path.join(path, f))]
    for fssubdir in fssubdirs:
      self.processfssubdir(fssubdir)

  def logfilesystempaths(self):
    logger = logging.getLogger('gc')
    logger.info('Number of local file systems is {}'.format(len(self.localfilesystempaths)))
    i = 0
    for path in self.localfilesystempaths:
      statvfs = os.statvfs(path)
      freebytes = statvfs.f_frsize * statvfs.f_bavail
      logger.info('Local file system {}: path={} freebytes={}'.format(i, path, freebytes))
      i = i + 1

  def processallfs(self):
    filesystems = self.eosfsls()
    newlocalfilesystempaths = [fs["path"] for fs in filesystems if "path" in fs and "host" in fs and self.fqdn == fs["host"]]
    if newlocalfilesystempaths != self.localfilesystempaths:
      self.localfilesystempaths = newlocalfilesystempaths
      self.logfilesystempaths();
    for path in self.localfilesystempaths:
      self.processfs(path)

  def logconf(self):
    logger = logging.getLogger('gc')
    if self.mgmhost:
      logger.info("config mgmhost={}".format(self.mgmhost))
    logger.info("config minfreebytes={}".format(self.minfreebytes))
    logger.info("config gcagesecs={}".format(self.gcagesecs))

  def readconf(self):
    if not os.path.isfile(self.conffilepath):
      raise UserError("The configuration file {} is not a directory or does not exist".format(self.conffilepath))
    if not os.access(self.conffilepath, os.R_OK):
      raise UserError("The configuration file {} cannot be read by {}".format(self.conffilepath, self.programname))

    config = ConfigParser.ConfigParser()
    config.read(self.conffilepath)

    try:
      try:
        self.mgmhost = config.get('main', 'mgmhost')
      except ConfigParser.NoOptionError:
        pass
      self.minfreebytes = config.getint('main', 'minfreebytes')
      self.gcagesecs = config.getint('main', 'gcagesecs')
    except ConfigParser.Error as err:
      raise UserError("Error with configuration file {}: {}".format(self.conffilepath, err))

  def run(self):
    username = getpass.getuser()
    if 'daemon' != username:
      raise UserError('{} must be executed as user daemon and not user {}'.format(self.programname, username))

    self.configurelogging()
    logger = logging.getLogger('gc')
    logger.info('{} started'.format(self.programname))
    logger.info('The fqdn of this machine is {}'.format(self.fqdn))
    self.readconf()
    self.logconf()
    if not self.mgmhost:
      self.setmgmhost()
    logger.info('The EOS MGM host is {}'.format(self.mgmhost))

    minperiod = 300 # In seconds

    while True:
      before = time.time()
      self.processallfs()
      after = time.time()
      period = after - before
      if period < minperiod:
        sleeptime = minperiod - period
        logger.debug('Sleeping {} seconds'.format(sleeptime))
        time.sleep(sleeptime)

def main():
  parser = argparse.ArgumentParser()
  parser.add_argument("-l", "--logfile", default="/var/log/eos/fst/cta-fst-gcd.log", help="Log file path")
  args = parser.parse_args()

  gc = Gc(env=os.environ, logfile=args.logfile)

  try:
    gc.run()
  except UserError as err:
    print "User error: {}".format(err)

if __name__ == '__main__':
  main()
