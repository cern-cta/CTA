#!/bin/sh
#
# stager         Start/Stop gcdaemon.
#
# chkconfig: 345 70 35
# description: GCDAEMON server daemon
#
# $Id: castor-gc-server.init,v 1.4 2005/04/16 06:39:17 jdurand Exp $
#
# @(#)$RCSfile: castor-gc-server.init,v $ $Revision: 1.4 $ $Date: 2005/04/16 06:39:17 $ CERN/IT/ADC/CA Jean-Damien Durand
#

sysname=`uname -s`

# source function library
if [ -r /etc/rc.d/init.d/functions ]; then
	. /etc/rc.d/init.d/functions
	DAEMON=daemon
	FAILURE=failure
	ECHO_FAILURE=failure
	SUCCESS=success
	ECHO_SUCCESS=echo_success
	ECHO_END=echo
	if [ $sysname = "Linux" ]; then
		ECHOOPT=-n
	fi
else
	DAEMON=
	FAILURE=
	ECHO_FAILURE=
	SUCCESS=
	ECHO_SUCCESS=
	ECHOOPT=
	ECHO_END=
fi

RETVAL=0
prog="gcDaemon"
PIDFILE=/var/run/gcDaemon.pid
PIDDIR=/var/run
SUBSYS=/var/lock/subsys/gcDaemon
SUBSYSDIR=/var/lock/subsys
[ -z "$SILENTSTOP" ] && SILENTSTOP=0
GCDAEMON=/usr/bin/gcDaemon
OPTIONS=""
SYSCONFIGGCDAEMON=/etc/sysconfig/gcDaemon

#
## Blindly attempt to create useful directories
#
[ ! -d $PIDDIR ] && mkdir -p $PIDDIR >& /dev/null
[ ! -d $SUBSYSDIR ] && mkdir -p $SUBSYSDIR >& /dev/null

if [ $sysname = "HP-UX" ]; then
	export UNIX95=1
fi
if [ $sysname = "SunOS" ]; then
	format4comm="fname"
else
	format4comm="comm"
fi

case "$1" in
  start)
	echo $ECHOOPT "Starting $prog: "
	ps -eo ppid,$format4comm | egrep '^[ \t]+1 gcDaemon' > /dev/null
	if [ $? -eq 0 ]; then
	    echo $ECHOOPT "gcDaemon already started: "
	    [ -n "$FAILURE" ] && $FAILURE "gcDaemon already started: "
	    RETVAL=1
	else
            if [ -r $SYSCONFIGGCDAEMON ]; then
                #
                ## Source the configuration
                #
                . $SYSCONFIGGCDAEMON
                if [ "${RUN_GCDAEMON}" != "yes" ]; then
                    echo $ECHOOPT "$SYSCONFIGGCDAEMON says NO: "
                    [ -n "$FAILURE" ] && $FAILURE "$SYSCONFIGGCDAEMON says NO: "
                    RETVAL=1
                fi
                if [ -n "${ULIMIT_N}" ]; then
                    ulimit -n ${ULIMIT_N}
                fi
                if [ -n "${ULIMIT_C}" ]; then
                    ulimit -c ${ULIMIT_C}
                fi
            fi
            if [ $RETVAL -eq 0 ]; then
                #
                ## Because we might generate a core file (c.f. ULIMIT_C)
                ## We explicitely chdir in /tmp
                #
		mkdir -p /var/spool/gc
                cd /var/spool/gc
                $DAEMON $GCDAEMON $OPTIONS
                if [ $? -eq 0 ]; then
                    [ -d $SUBSYSDIR ] && touch $SUBSYS
		    if [ -d $PIDDIR ]; then
			pid=`ps -eo pid,ppid,$format4comm | grep " 1 gcDaemon" | awk '{print $1}'`
                        # The point of $PIDFILE is that it kills only
                        # the master daemon.
			rm -f $PIDFILE
			if [ -n "$pid" ]; then
			    echo $pid > $PIDFILE
			    RETVAL=0
			else
			    echo $ECHOOPT "gcDaemon not started: "
			    [ -n "$FAILURE" ] && $FAILURE "gcDaemon not started: "
			    RETVAL=1
			fi
		    else
			RETVAL=0
		    fi
                else
                    echo $ECHOOPT "gcDaemon not started: "
                    [ -n "$FAILURE" ] && $FAILURE "gcDaemon not started: "
                    RETVAL=1
                fi
            fi
	fi
	$ECHO_END
	;;
  stop)
    if [ -f $PIDFILE ]; then
	[ $SILENTSTOP -eq 0 ] && echo $ECHOOPT "Stopping $prog: "
	if [ $SILENTSTOP -eq 0 ]; then
	    kill -9 -`cat $PIDFILE`
	else
	    kill -9 -`cat $PIDFILE` >& /dev/null
	fi
	RETVAL=$?
	if [ $RETVAL -eq 0 ]; then
	    rm -f $PIDFILE
	fi
    else
        # gcDaemon might have been started by hand
	pid=`ps -eo pid,ppid,$format4comm | grep " 1 gcDaemon" | awk '{print $1}'`
	if [ -n "$pid" ]; then
	    [ $SILENTSTOP -eq 0 ] && echo $ECHOOPT "Stopping $prog: "
	    if [ $SILENTSTOP -eq 0 ]; then
		kill -9 -$pid
	    else
		kill -9 -$pid >& /dev/null
	    fi
	    RETVAL=$?
	else
	    [ $SILENTSTOP -eq 0 ] && echo $ECHOOPT "gcDaemon already stopped: "
	    [ $SILENTSTOP -eq 0 -a -n "$FAILURE" ] && $FAILURE "gcDaemon already stopped: "
	    RETVAL=1
	fi
    fi
    if [ $SILENTSTOP -eq 0 -a $sysname = "Linux" ]; then
	if [ $RETVAL -eq 0 ]; then
	    $ECHO_SUCCESS
	else
	    $ECHO_FAILURE
	fi
    fi
    [ -d $SUBSYSDIR ] && rm -f $SUBSYS
    [ $SILENTSTOP -eq 0 -a -n "$ECHO_END" ] && $ECHO_END
    #
    ## Basically: if SILENTSTOP is not 0 when we never print something
    ## But if the stop is successful... One might want to see stop: OK
    ## anyway ?
    #
    if [ $SILENTSTOP -ne 0 -a $RETVAL -eq 0 ]; then
	echo $ECHOOPT "Stopping $prog: "
        [ $sysname = "Linux" ] && $ECHO_SUCCESS
        [ -n "$ECHO_END" ] && $ECHO_END
    fi
    ;;
    restart)
	$0 stop
	if [ $? -eq 0 -o $SILENTSTOP -eq 0 ]; then
	    $0 start
	    RETVAL=$?
	else
        #
        ## It is legal to return zero it if was
        ## a conditional restart
        #
	    if [ $SILENTSTOP -eq 0 ]; then
		RETVAL=1
	    else
		RETVAL=0
	    fi
	fi
	;;
    condrestart)
	SILENTSTOP=1
	export SILENTSTOP
	$0 restart
	RETVAL=$?
	;;
    status)
	pid=`ps -eo pid,ppid,$format4comm | grep " 1 gcDaemon" | awk '{print $1}'`
	if [ -n "$pid" ]; then
	    echo $ECHOOPT "gcDaemon (pid $pid) is running..."
	    $ECHO_SUCCESS
	    $ECHO_END
	else
	    if [ -f $PIDFILE ]; then
		pid=`head -1 $PIDFILE`
		if [ "$pid" != "" ] ; then
		    echo $ECHOOPT "gcDaemon dead but pid file exists"
		    $ECHO_FAILURE
		    $ECHO_END
		fi
	    else
		if [ -f $SUBSYS ]; then
		    echo $ECHOOPT "gcDaemon dead but subsys ($SUBSYS) locked"
		else
		    echo $ECHOOPT "gcDaemon is stopped"
		fi
		$ECHO_FAILURE
		$ECHO_END
	    fi
	fi
	;;
    *)
	echo "Usage: $0 {start|stop|status|restart|condrestart}"
	RETVAL=1
	;;
esac

exit $RETVAL
