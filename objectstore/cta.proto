// The CERN Tape Archive (CTA) project
// Copyright (C) 2015  CERN
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

package cta.objectstore.serializers;

// The types of the objects. It will be used to allow introspection
// for the contents.
enum ObjectType {
  RootEntry_t = 0;
  AgentRegister_t = 1;
  Agent_t = 2;
  DriveRegister_t = 3;
  ArchiveToFileRequest_t = 4;
  RetrieveToFileRequest_t = 5;
  SchedulerGlobalLock_t = 6;
  ArchiveRequest_t = 7;
  RetrieveRequest_t = 8;
  ArchiveQueue_t = 9;
  RetrieveQueue_t = 10;
  GenericObject_t = 1000;
}

// The types of mounts
enum MountType {
  NoMount = 0;
  Archive = 1;
  Retrieve = 2;
}

// The drive statuses
enum DriveStatus {
    Down = 0;
    Up = 1;
    Starting = 2;
    Mounting = 3;
    Transfering = 4;
    Unloading = 5;
    Unmounting = 6;
    DrainingToDisk = 7;
    CleaningUp = 8;
};

// The base object header. This will allow introspection and automatic
// "garbage collection", i.e. returning an unprocessed object belonging
// to a dead agent to the right queue or container.
// - The type allows automatic management of the content without knowing its
// payload.
// - The version allows multi schema to be used at the object level (smooth schema 
// evolution, on an object by object basis).
// - The owner is the authoritative source of ownership for the object.
// It allows arbitration of the actual owner in case the object is pointed
// to by several containers (during a transition, or after a failure).
// - The backup owner allows the object to be returned to a previous container
// in case of failure of a owner (when it is an agent).
message ObjectHeader {
  required ObjectType type = 1;
  required uint64 version = 2;
  required string owner = 3;
  required string backupowner = 4;
  required bytes payload = 5;
}

// A placeholder object for the implementation of neutral object handlers
message GenericObject {
}

// ===========================  Root Entry =====================================
// The objects making up the root entry.

// A user information record
message UserIdentity {
  required string name = 10;
  required string group = 11;
}

// The creation log attached to each element
message CreationLog {
  required string username = 20;
  required string host = 21;
  required uint64 time = 22;
  optional string comment = 23;
}

// Pointer to the drive register (register defined further)
message DriveRegisterPointer {
  required string address = 90;
  required CreationLog log = 91;
}

// Pointer to the agent register (register defined further)
message AgentRegisterPointer {
  required string address = 100;
  required CreationLog log = 101;
}

// Pointer to the scheduler global lock
message SchedulerGlobalLockPointer {
  required string address = 110;
  required CreationLog log = 111;
}

// Pointer to the archive queue
message ArchiveQueuePointer {
  required string address = 120;
  required string name = 121;
}

// Pointer to the tape queue
message TapeQueuePointer {
  required string address = 130;
  required string vid = 131;
}

// The root entry. This entry contains all the most static information, i.e.
// the admin handled configuration information
message RootEntry {
  repeated ArchiveQueuePointer archivequeuepointers = 1050;
  repeated TapeQueuePointer tapequeuepointers = 1060; //new queues by tape vid that will replace the old retrieve queues (these are pointers because queues change often and are volatile and we shouldn't lock th root entry for each change)
  optional DriveRegisterPointer driveregisterpointer = 1070;
  optional AgentRegisterPointer agentregisterpointer = 1080;
  optional string agentregisterintent = 1090;
  optional SchedulerGlobalLockPointer schedulerlockpointer = 1100;
}

//=========== Sub-objects ======================================================

// ------------- Agent handling ------------------------------------------------

// The agent object represents a running process. It is a payload to an object
// itself, and it can be owned by a watchdog or a global agent registry, which
// lists the agents not yet watched by a watchdog.
// - The description is a freetext string used for logging.
// - The watchdogs themselves own the agents they are watching, so the agents can
// be returned to the agent registry when they fail.
// - The heartbeat is incremented from time to time by the agent.
// - The timeout_us is the amount of microseconds after which the absence of
// change to the heartbeat can be interpreted as agent failure.
// - The ownedobject list is an ownership intent log that points to the objects
// that the agent is about to create, intends to own, or fully owns.
// The objects in this list can be considered for being returned to a backup
// owner.
message Agent {
  required string description = 2000;
  required uint64 heartbeat = 2001;
  required uint64 timeout_us = 2002;
  repeated string ownedobjects = 2003;
}

message AgentRegister {
  repeated string agents = 2100;
  repeated string untrackedagents = 2101;
}

// ------------- Jobs handling -------------------------------------------------

message ArchiveJobPointer {
  required uint64 fileid = 3000;
  required uint64 size = 3001;
  required string address = 3002;
  required uint32 copynb = 3003;
}

message RetrieveJobPointer {
  required uint64 size = 3101;
  required string address = 3102;
  required uint32 copynb = 3103;
}

// ------------- Mount criteria and quota  -------------------------------------

message MountCriteria {
  required uint64 maxFilesBeforeMount = 3200;
  required uint64 maxBytesBeforeMount = 3201;
  required uint64 maxSecondsBeforeMount = 3202;
  required uint32 quota = 3203;
}

message ArchiveFile {
  required uint64 fileId = 4351;
  required uint64 size = 4352;
  required string diskfileid = 4353;
  required string checksumtype = 4354;
  required string checksumvalue = 4355;
  required uint64 creationtime = 4356;
}

// ------------- Archive Jobs --------------------------------------------------

// The status of the individual archive jobs. The jobs are materialised 
// by table entries in the ArchiveToFileRequest.
// This life cycle represented by the following enum

enum ArchiveJobStatus {
  AJS_PendingNsCreation = 0;
  AJS_LinkingToArchiveQueue = 1;
  AJS_PendingMount = 2;
  AJS_PendingNsDeletion = 99;
  AJS_Selected = 3;
  AJS_Complete = 4;
  AJS_Failed = 999;
}

message FilePathAndStatus {
  required string path = 4450;
  required uint64 mode = 4451;
  required uint64 size = 4452;
  required UserIdentity owner = 4453;
}

message ArchiveJobEntry {
  required uint32 copynb = 4400;
  required string tapepool = 4401;
  required string archivequeueaddress = 4402;
  required string owner = 4403;
  required ArchiveJobStatus status = 4404;
  required uint32 totalretries = 4405;
  required uint32 retrieswithinmount = 4406;
  required uint64 lastmountwithfailure = 4407;
  required uint32 maxtotalretries = 4408;
  required uint32 maxretrieswithinmount = 4409;
}

// ------------- Retrieve Jobs -------------------------------------------------

// The status of the individual retrieve jobs. The jobs are materialised 
// by table entries in the RetrieveToFileRequest.
// This life cycle represented by the following enum

enum RetrieveJobStatus {
  RJS_LinkingToTape = 0;
  RJS_Pending = 1;
  RJS_Selected = 2;
  RJS_Complete = 3;
  RJS_Failed = 99;
}

message RetrieveJobEntry {
  required uint32 copynb = 4700;
  required string tape = 4701;
  required string tapeaddress = 4702;
  required uint64 fseq = 4703;
  required uint64 blockid = 4704;
  required RetrieveJobStatus status = 4705;
  required uint32 totalretries = 4706;
  required uint32 retrieswithinmount = 4707;
  required uint64 compressedsize = 4708;
  required uint64 creationtime = 4709;
}

message RetrieveToFileRequest {
  required string remotefile = 4800;
  required ArchiveFile archivefile = 4801;
  required uint64 size = 4802;
  repeated RetrieveJobEntry jobs = 4803;
  required uint64 priority = 4804;
  required CreationLog log = 4805;
  required uint64 diskfileid = 4806;
  optional string retrievetodiraddress = 4807;
}

// ------------- Drives handling  ----------------------------------------------



message DriveState {
  required string drivename = 5000;
  required string logicallibrary = 5001;
  optional uint64 sessionid = 5002;
  optional uint64 bytestransferedinsession = 5003;
  optional uint64 filestransferedinsession = 5004;
  optional double latestbandwidth = 5005;
  optional uint64 sessionstarttime = 5006;
  optional uint64 mountstarttime = 5007;
  optional uint64 transferstarttime = 5008;
  optional uint64 unloadstarttime = 5009;
  optional uint64 unmountstarttime = 5010;
  optional uint64 drainingstarttime = 5011;
  optional uint64 downorupstarttime = 5012;
  optional uint64 cleanupstarttime = 5013;
  optional uint64 lastupdatetime = 5014;
  required MountType mounttype = 5015;
  required DriveStatus drivestatus = 5016;
  optional string currentvid = 5017;
  optional string currenttapepool = 5018;
  required CreationLog creationlog = 5019;
}

message DriveRegister {
  repeated DriveState drives = 7000;
}

// ------------- Scheduler global lock handling  -------------------------------

message SchedulerGlobalLock {
  required uint64 nextmountid = 8000;
}

// ------------- New interface  ------------------------------------------------

message User {
  required string name = 8800;
  required string group = 8810;
}

message DiskFileInfo {
  required string recoveryBlob = 8900;
  required string group = 8910;
  required string owner = 8930;
  required string path = 8940;
}

message EntryLog {
  required string username = 8950;
  required string host = 8960;
  required uint64 time = 8970;
}

message MountPolicy {
  required string name = 8980;
  required uint64 minRequestAge = 8981;
  required uint64 priority = 8982;
  required uint64 maxDrives = 8983;
}

message ArchiveRequest {
  required uint64 archiveFileID = 8990;
  required MountPolicy mountPolicy = 8995;
  required string checksumtype = 9000;
  required string checksumvalue = 9010;
  required uint64 creationtime = 9015;
  required uint64 reconcilationtime = 9017;
  required string diskpoolName = 9020;
  required uint64 diskpoolThroughput = 9030;
  required DiskFileInfo diskFileInfo = 9040;
  required string diskFileID = 9050;
  required string diskinstance = 9055;
  required uint64 fileSize = 9060;
  required User requester = 9070;
  required string srcURL = 9080;
  required string storageClass = 9090;
  required EntryLog creationLog = 9091;
  repeated ArchiveJobEntry jobs = 9092;
}

message RetrieveRequest {
  required ArchiveFile archivefile = 9100;
  required MountPolicy mountPolicy = 9105;
  required string diskpoolName = 9110;
  required uint64 diskpoolThroughput = 9120;
  required DiskFileInfo diskFileInfo = 9130;
  required string dstURL = 9140;
  required string diskinstance = 9145;
  required uint64 reconcilationtime = 9147;
  required User requester = 9150;
  required EntryLog creationLog = 9151;
  repeated RetrieveJobEntry jobs = 9152;
  required string storageclass = 9153;
}

message ValueCountPair {
  required uint64 value = 9201;
  required uint64 count = 9202;
}

message ArchiveQueue {
  required string tapepool = 10000;
  repeated ArchiveJobPointer pendingarchivejobs = 10010;
  repeated ArchiveJobPointer orphanedarchivejobsnscreation = 10020;
  repeated ArchiveJobPointer orphanedarchivejobsnsdeletion = 10030;
  repeated ValueCountPair prioritymap = 10031;
  repeated ValueCountPair minarchiverequestagemap = 10032;
  repeated ValueCountPair maxdrivesallowedmap = 10033;
  required uint64 archivejobstotalsize = 10040;
  required uint64 oldestjobcreationtime = 10050;
}

message RetrieveQueue {
  required string vid = 10100;
  repeated RetrieveJobPointer retrievejobs = 10110;
  required uint64 retrievejobstotalsize = 10120;
  required uint64 oldestjobtime = 10130;
}