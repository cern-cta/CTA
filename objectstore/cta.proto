// The CERN Tape Archive (CTA) project
// Copyright (C) 2015  CERN
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
syntax = "proto2";
package cta.objectstore.serializers;

// The types of the objects. It will be used to allow introspection
// for the contents.
enum ObjectType {
  RootEntry_t = 0;
  AgentRegister_t = 1;
  Agent_t = 2;
  DriveRegister_t = 3;
  SchedulerGlobalLock_t = 6;
  ArchiveRequest_t = 7;
  RetrieveRequest_t = 8;
  ArchiveQueue_t = 9;
  RetrieveQueue_t = 10;
  GenericObject_t = 1000;
}

// The base object header. This will allow introspection and automatic
// "garbage collection", i.e. returning an unprocessed object belonging
// to a dead agent to the right queue or container.
// - The type allows automatic management of the content without knowing its
// payload.
// - The version allows multi schema to be used at the object level (smooth schema 
// evolution, on an object by object basis).
// - The owner is the authoritative source of ownership for the object.
// It allows arbitration of the actual owner in case the object is pointed
// to by several containers (during a transition, or after a failure).
// - The backup owner allows the object to be returned to a previous container
// in case of failure of a owner (when it is an agent).
message ObjectHeader {
  required ObjectType type = 1;
  required uint64 version = 2;
  required string owner = 3;
  required string backupowner = 4;
  required bytes payload = 5;
}

// A placeholder object for the implementation of neutral object handlers
message GenericObject {
}

// ===========================  Root Entry =====================================
// The objects making up the root entry.

// A user information record
message UserIdentity {
  required string name = 10;
  required string group = 11;
}

// Pointer to the drive register (register defined further)
message DriveRegisterPointer {
  required string address = 90;
  required EntryLog log = 91;
}

// Pointer to the agent register (register defined further)
message AgentRegisterPointer {
  required string address = 100;
  required EntryLog log = 101;
}

// Pointer to the scheduler global lock
message SchedulerGlobalLockPointer {
  required string address = 110;
  required EntryLog log = 111;
}

// Pointer to the archive queue
message ArchiveQueuePointer {
  required string address = 120;
  required string name = 121;
}

// Pointer to the tape queue
message RetrieveQueuePointer {
  required string address = 130;
  required string vid = 131;
}

// The root entry. This entry contains all the most static information, i.e.
// the admin handled configuration information
message RootEntry {
  repeated ArchiveQueuePointer archivequeuepointers = 1050;
  repeated RetrieveQueuePointer retrievequeuepointers = 1060; //new queues by tape 
  // vid that will replace the old retrieve queues (these are pointers because queues 
  // change often and are volatile and we shouldn't lock th root entry for each change)
  optional DriveRegisterPointer driveregisterpointer = 1070;
  optional AgentRegisterPointer agentregisterpointer = 1080;
  optional string agentregisterintent = 1090;
  optional SchedulerGlobalLockPointer schedulerlockpointer = 1100;
}

//=========== Sub-objects ======================================================

// ------------- Agent handling ------------------------------------------------

// The agent object represents a running process. It is a payload to an object
// itself, and it can be owned by a watchdog or a global agent registry, which
// lists the agents not yet watched by a watchdog.
// - The description is a freetext string used for logging.
// - The watchdogs themselves own the agents they are watching, so the agents can
// be returned to the agent registry when they fail.
// - The heartbeat is incremented from time to time by the agent.
// - The timeout_us is the amount of microseconds after which the absence of
// change to the heartbeat can be interpreted as agent failure.
// - The ownedobject list is an ownership intent log that points to the objects
// that the agent is about to create, intends to own, or fully owns.
// The objects in this list can be considered for being returned to a backup
// owner.
message Agent {
  required string description = 2000;
  required uint64 heartbeat = 2001;
  required uint64 timeout_us = 2002;
  repeated string ownedobjects = 2003;
}

message AgentRegister {
  repeated string agents = 2100;
  repeated string untrackedagents = 2101;
}

// ------------- Jobs handling -------------------------------------------------

message ArchiveJobPointer {
  required uint64 fileid = 3000;
  required uint64 size = 3001;
  required string address = 3002;
  required uint32 copynb = 3003;
  required uint64 priority = 3004;
  required uint64 minarchiverequestage = 3005;
  required uint64 maxdrivesallowed = 3006;
}

message RetrieveJobPointer {
  required uint64 size = 3101;
  required string address = 3102;
  required uint32 copynb = 3103;
  required uint64 fseq = 3107;
  required uint64 priority = 3104;
  required uint64 minretrieverequestage = 3105;
  required uint64 maxdrivesallowed = 3106;
}

// ------------- Mount criteria and quota  -------------------------------------

message MountCriteria {
  required uint64 maxFilesBeforeMount = 3200;
  required uint64 maxBytesBeforeMount = 3201;
  required uint64 maxSecondsBeforeMount = 3202;
  required uint32 quota = 3203;
}

message TapeFile {
  required string vid = 9120;
  required uint64 fseq = 9121;
  required uint64 blockid = 9122;
  required uint64 compressedsize = 9123;
  required uint64 copynb = 9124;
  required uint64 creationtime = 9125;
  required string checksumtype = 9126;
  required string checksumvalue = 9127;
}

message DiskFileInfo {
  required string recoveryBlob = 8900;
  required string group = 8910;
  required string owner = 8930;
  required string path = 8940;
}

message ArchiveFile {
  required uint64 archivefileid = 4351;
  required uint64 filesize = 4352;
  required string diskfileid = 4353;
  required string diskinstance= 4354;
  required DiskFileInfo diskfileinfo= 4355;
  required string checksumtype = 4356;
  required string checksumvalue = 4357;
  required uint64 creationtime = 4358;
  repeated TapeFile tapefiles = 4359;
  required uint64 reconciliationtime = 4360;
  required string storageclass = 4361;
}

// ------------- Archive Jobs --------------------------------------------------

// The status of the individual archive jobs. The jobs are materialised 
// by table entries in the ArchiveRequest.
// This life cycle represented by the following enum

enum ArchiveJobStatus {
  AJS_PendingNsCreation = 0;
  AJS_LinkingToArchiveQueue = 1;
  AJS_PendingMount = 2;
  AJS_PendingNsDeletion = 99;
  AJS_Selected = 3;
  AJS_Complete = 4;
  AJS_Failed = 999;
}

message FilePathAndStatus {
  required string path = 4450;
  required uint64 mode = 4451;
  required uint64 size = 4452;
  required UserIdentity owner = 4453;
}

message ArchiveJobEntry {
  required uint32 copynb = 4400;
  required string tapepool = 4401;
  required string archivequeueaddress = 4402;
  required string owner = 4403;
  required ArchiveJobStatus status = 4404;
  required uint32 totalretries = 4405;
  required uint32 retrieswithinmount = 4406;
  required uint64 lastmountwithfailure = 4407;
  required uint32 maxtotalretries = 4408;
  required uint32 maxretrieswithinmount = 4409;
}

// ------------- Retrieve Jobs -------------------------------------------------

// The status of the individual retrieve jobs. The jobs are materialised 
// by table entries in the RetrieveRequest.
// This life cycle represented by the following enum

enum RetrieveJobStatus {
  RJS_LinkingToTape = 0;
  RJS_Pending = 1;
  RJS_Selected = 2;
  RJS_Complete = 3;
  RJS_Failed = 99;
}

message RetrieveJobEntry {
  required uint32 copynb = 4700;
  required string tape = 4701;
  required string tapeaddress = 4702;
  required uint64 fseq = 4703;
  required uint64 blockid = 4704;
  required RetrieveJobStatus status = 4705;
  required uint32 totalretries = 4706;
  required uint32 retrieswithinmount = 4707;
  required uint64 compressedsize = 4708;
  required uint64 creationtime = 4709;
}

// ------------- Drives handling  ----------------------------------------------



message DriveState {
  required string drivename = 5000;
  required string host = 5001;
  required string logicallibrary = 5002;
  optional uint64 sessionid = 5003;
  optional uint64 bytestransferedinsession = 5004;
  optional uint64 filestransferedinsession = 5005;
  optional double latestbandwidth = 5006;
  optional uint64 sessionstarttime = 5007;
  optional uint64 mountstarttime = 5008;
  optional uint64 transferstarttime = 5009;
  optional uint64 unloadstarttime = 5010;
  optional uint64 unmountstarttime = 5011;
  optional uint64 drainingstarttime = 5012;
  optional uint64 downorupstarttime = 5013;
  optional uint64 cleanupstarttime = 5014;
  optional uint64 lastupdatetime = 5015;
  optional uint64 startstarttime = 5016;
  required uint32 mounttype = 5017;
  required uint32 drivestatus = 5018;
  required bool desiredUp = 5019;
  required bool desiredForceDown = 5020;
  optional string currentvid = 5021;
  optional string currenttapepool = 5022;
  optional uint32 nextmounttype = 5023;
  optional string nextvid = 5024;
  optional string nexttapepool = 5025;
// TODO: implement or remove  required EntryLog creationlog = 5023;
}

message DriveRegister {
  repeated DriveState drives = 7000;
}

// ------------- Scheduler global lock handling  -------------------------------

message SchedulerGlobalLock {
  required uint64 nextmountid = 8000;
}

// ------------- New interface  ------------------------------------------------

message User {
  required string name = 8800;
  required string group = 8810;
}

message EntryLog {
  required string username = 8950;
  required string host = 8960;
  required uint64 time = 8970;
}

message MountPolicy {
  required string name = 8980;
  required uint64 archivepriority = 8981;
  required uint64 archiveminrequestage = 8982;
  required uint64 retrievepriority = 8983;
  required uint64 retieveminrequestage = 8984;
  required uint64 maxdrivesallowed = 8985;
  required EntryLog creationlog = 8986;
  required EntryLog lastmodificationlog = 8987;
  required string comment = 8988;
}

message ArchiveRequest {
  required uint64 archiveFileID = 8990;
  required MountPolicy mountpolicy = 8995;
  required string checksumtype = 9000;
  required string checksumvalue = 9010;
  required uint64 creationtime = 9015;
  required uint64 reconcilationtime = 9017;
  required DiskFileInfo diskfileinfo = 9040;
  required string diskfileid = 9050;
  required string diskinstance = 9055;
  required string archivereporturl = 9057;
  required uint64 filesize = 9060;
  required User requester = 9070;
  required string srcurl = 9080;
  required string storageclass = 9090;
  required EntryLog creationlog = 9091;
  repeated ArchiveJobEntry jobs = 9092;
}

message SchedulerRetrieveRequest {
  required UserIdentity requester = 9100;
  required uint64 ArchiveFileId = 9101;
  required string dstURL = 9102;
  required DiskFileInfo diskfileinfo = 9103;
  required EntryLog entrylog = 9106;
}

message RetrieveJob {
  required uint64 copynb = 9200;
  required uint32 maxtotalretries = 9201;
  required uint32 maxretrieswithinmount = 9202;
  required uint32 retrieswithinmount = 9203;
  required uint32 totalretries = 9204;
  required RetrieveJobStatus status = 9205;
}

message RetrieveRequest {
  required SchedulerRetrieveRequest schedulerrequest = 9150;
  required MountPolicy mountpolicy = 9151;
  required ArchiveFile archivefile = 9152;
  required uint32 activecopynb = 9153;
  repeated RetrieveJob jobs = 9154;
}

message ValueCountPair {
  required uint64 value = 9301;
  required uint64 count = 9302;
}

message ArchiveQueue {
  required string tapepool = 10000;
  repeated ArchiveJobPointer pendingarchivejobs = 10010;
  repeated ArchiveJobPointer orphanedarchivejobsnscreation = 10020;
  repeated ArchiveJobPointer orphanedarchivejobsnsdeletion = 10030;
  repeated ValueCountPair prioritymap = 10031;
  repeated ValueCountPair minarchiverequestagemap = 10032;
  repeated ValueCountPair maxdrivesallowedmap = 10033;
  required uint64 archivejobstotalsize = 10040;
  required uint64 oldestjobcreationtime = 10050;
  required uint64 mapsrebuildcount = 10060;
}

message RetrieveQueue {
  required string vid = 10100;
  repeated RetrieveJobPointer retrievejobs = 10110;
  repeated ValueCountPair prioritymap = 10131;
  repeated ValueCountPair minretrieverequestagemap = 10132;
  repeated ValueCountPair maxdrivesallowedmap = 10133;
  required uint64 retrievejobstotalsize = 10140;
  required uint64 oldestjobcreationtime = 10150;
  required uint64 mapsrebuildcount = 10160;
}
