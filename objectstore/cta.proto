package cta.objectstore.serializers;

// The types of the objects. It will be used to allow introspection
// for the contents.
enum ObjectType {
  RootEntry_t = 0;
  AgentRegister_t = 1;
  Agent_t = 2;
  TapePool_t = 3;
  DriveRegister_t = 4;
  Tape_t = 5;
  ArchiveToFileRequest_t = 6;
  RetrieveToFileRequest_t = 7;
  SchedulerGlobalLock_t = 8;
  ArchiveRequest_t = 9;
  RetrieveRequest_t = 10;
  TapePoolQueue_t = 11;
  TapeQueue_t = 12;
  GenericObject_t = 1000;
}

// The types of mounts
enum MountType {
  NoMount = 0;
  Archive = 1;
  Retrieve = 2;
}

// The drive statuses
enum DriveStatus {
    Down = 0;
    Up = 1;
    Starting = 2;
    Mounting = 3;
    Transfering = 4;
    Unloading = 5;
    Unmounting = 6;
    DrainingToDisk = 7;
    CleaningUp = 8;
};

// The base object header. This will allow introspection and automatic
// "garbage collection", i.e. returning an unprocessed object belonging
// to a dead agent to the right queue or container.
// - The type allows automatic management of the content without knowing its
// payload.
// - The version allows multi schema to be used at the object level (smooth schema 
// evolution, on an object by object basis).
// - The owner is the authoritative source of ownership for the object.
// It allows arbitration of the actual owner in case the object is pointed
// to by several containers (during a transition, or after a failure).
// - The backup owner allows the object to be returned to a previous container
// in case of failure of a owner (when it is an agent).
message ObjectHeader {
  required ObjectType type = 1;
  required uint64 version = 2;
  required string owner = 3;
  required string backupowner = 4;
  required bytes payload = 5;
}

// A placeholder object for the implementation of neutral object handlers
message GenericObject {
}

// ===========================  Root Entry =====================================
// The objects making up the root entry.

// A user information record
message UserIdentity {
  required uint32 uid = 10;
  required uint32 gid = 11;
}

// The creation log attached to each element
message CreationLog {
  required UserIdentity user = 20;
  required string host = 21;
  required uint64 time = 22;
  optional string comment = 23;
}

// The admin host
message AdminHost {
  required string hostname = 30;
  required CreationLog log = 31;
}

message AdminUser {
  required UserIdentity user = 40;
  required CreationLog log = 41;
}

// The Archive route
message ArchiveRoute {
  required uint32 copynb = 50;
  required string tapepool = 51;
  required CreationLog log = 52;
}

// The Storage Class
message StorageClass {
  required string name = 60;
  required uint32 copycount = 61;
  repeated ArchiveRoute routes = 62;
  required CreationLog log = 63;
}

// Pointer to a tape pool (tape pool defined further)
message TapePoolPointer {
  required string name = 70;
  required string address  = 71;
  required uint32 nbpartialtapes = 72;
  required CreationLog log = 73;
}

// Description of a library
message Library {
  required string name = 80;
  required CreationLog log = 81;
}

// Pointer to the drive register (register defined further)
message DriveRegisterPointer {
  required string address = 90;
  required CreationLog log = 91;
}

// Pointer to the agent register (register defined further)
message AgentRegisterPointer {
  required string address = 100;
  required CreationLog log = 101;
}

// Pointer to the scheduler global lock
message SchedulerGlobalLockPointer {
  required string address = 110;
  required CreationLog log = 111;
}

// Pointer to the tapepool queue
message TapePoolQueuePointer {
  required string address = 120;
  required string name = 121;
}

// Pointer to the tape queue
message TapeQueuePointer {
  required string address = 130;
  required string vid = 131;
}

// The root entry. This entry contains all the most static information, i.e.
// the admin handled configuration information
message RootEntry {
  repeated AdminHost adminhosts = 1000;
  repeated AdminUser adminusers = 1010;
  repeated StorageClass storageclasses = 1020;
  repeated TapePoolPointer tapepoolpointers = 1030;
  repeated Library libraries = 1040;
  repeated TapePoolQueuePointer tapepoolqueuepointers = 1050; //new queues by tapepool name that will replace the old archive queues (these are pointers because queues change often and are volatile and we shouldn't lock th root entry for each change)
  repeated TapeQueuePointer tapequeuepointers = 1060; //new queues by tape vid that will replace the old retrieve queues (these are pointers because queues change often and are volatile and we shouldn't lock th root entry for each change)
  optional DriveRegisterPointer driveregisterpointer = 1070;
  optional AgentRegisterPointer agentregisterpointer = 1080;
  optional string agentregisterintent = 1090;
  optional SchedulerGlobalLockPointer schedulerlockpointer = 1100;
}

//=========== Sub-objects ======================================================

// ------------- Agent handling ------------------------------------------------

// The agent object represents a running process. It is a payload to an object
// itself, and it can be owned by a watchdog or a global agent registry, which
// lists the agents not yet watched by a watchdog.
// - The description is a freetext string used for logging.
// - The watchdogs themselves own the agents they are watching, so the agents can
// be returned to the agent registry when they fail.
// - The heartbeat is incremented from time to time by the agent.
// - The timeout_us is the amount of microseconds after which the absence of
// change to the heartbeat can be interpreted as agent failure.
// - The ownedobject list is an ownership intent log that points to the objects
// that the agent is about to create, intends to own, or fully owns.
// The objects in this list can be considered for being returned to a backup
// owner.
message Agent {
  required string description = 2000;
  required uint64 heartbeat = 2001;
  required uint64 timeout_us = 2002;
  repeated string ownedobjects = 2003;
}

message AgentRegister {
  repeated string agents = 2100;
  repeated string untrackedagents = 2101;
}

// ------------- Jobs handling -------------------------------------------------

message ArchiveJobPointer {
  required string path = 3000;
  required uint64 size = 3001;
  required string address = 3002;
  required uint32 copynb = 3003;
}

message RetrieveJobPointer {
  required uint64 size = 3101;
  required string address = 3102;
  required uint32 copynb = 3103;
}

// ------------- Mount criteria and quota  -------------------------------------

message MountCriteria {
  required uint64 maxFilesBeforeMount = 3200;
  required uint64 maxBytesBeforeMount = 3201;
  required uint64 maxSecondsBeforeMount = 3202;
  required uint32 quota = 3203;
}

// ------------- Tape pools  ---------------------------------------------------

message TapePointer {
  required string vid = 4000;
  required string address  = 4001;
  required string library = 4002;
  required uint64 capacity = 4003;
  required CreationLog log = 4004;
}

message TapePool {
  required string name = 4100;
  repeated TapePointer tapes = 4101;
  repeated ArchiveJobPointer pendingarchivejobs = 4102;
  repeated ArchiveJobPointer orphanedarchivejobsnscreation = 4103;
  repeated ArchiveJobPointer orphanedarchivejobsnsdeletion = 4104;
  required uint64 ArchiveJobsTotalSize = 4105;
  required uint64 oldestJobCreationTime = 4106;
  required MountCriteria archivemountcriteria = 4107;
  required MountCriteria retievemountcriteria = 4108;
  required uint64 priority = 4109;
  required uint32 maxretriespermount = 4110;
  required uint32 maxtotalretries = 4111;
}

// ------------- Tape ----------------------------------------------------------

message MountInfo {
  required string host = 4200;
  required string drivevendor = 4201;
  required string drivemodel = 4202;
  required string driveserial = 4203;
  required string drivename = 4204;
  required uint64 time = 4205;
}

message Tape {
  required string vid = 4300;
  required string logicallibrary = 4301;
  // Statistics about what is stored in the tape
  required uint64 lastfseq = 4302;
  required uint64 bytesstored = 4303;
  // Tape lifetime statistics
  repeated MountInfo readmounts = 4304;
  repeated MountInfo writemounts = 4305;
  // Information about retrive jobs queued on this tape
  repeated RetrieveJobPointer retrievejobs = 4306;
  required uint64 retrievejobstotalsize = 4307;
  required uint64 oldestjobtime = 4308;
  required uint64 priority = 4309;
  // There are no per tape mount criteria/quotas (they are per tape pool).
  // Tape status
  required bool busy = 4310;
  required MountType currentmounttype = 4311;
  required MountInfo currentmount = 4312;
  required bool archived = 4313;
  required bool disabled = 4314;
  required bool readonly = 4315;
  required bool full = 4316;
  // Creation log
  required CreationLog log = 4317;
}

message ArchiveFile {
  required string path = 4350;
  required string nsHostName = 4351;
  required uint64 fileId = 4352;
  required uint64 size = 4353;
  required uint32 checksum = 4354;
  required uint64 lastModificationTime = 4355;
}

// ------------- Archive Jobs --------------------------------------------------

// The status of the individual archive jobs. The jobs are materialised 
// by table entries in the ArchiveToFileRequest.
// This life cycle represented by the following enum

enum ArchiveJobStatus {
  AJS_PendingNsCreation = 0;
  AJS_LinkingToTapePool = 1;
  AJS_PendingMount = 2;
  AJS_PendingNsDeletion = 99;
  AJS_Selected = 3;
  AJS_Complete = 4;
  AJS_Failed = 999;
}

message FilePathAndStatus {
  required string path = 4450;
  required uint64 mode = 4451;
  required uint64 size = 4452;
  required UserIdentity owner = 4453;
}

message ArchiveJobEntry {
  required uint32 copynb = 4400;
  required string tapepool = 4401;
  required string tapepooladdress = 4402;
  required string owner = 4403;
  required ArchiveJobStatus status = 4404;
  required uint32 totalretries = 4405;
  required uint32 retrieswithinmount = 4406;
  required uint64 lastmountwithfailure = 4407;
  required uint32 maxretrieswithinmount = 4408;
  required uint32 maxtotalretries = 4409;
}

message ArchiveToFileRequest {
  required FilePathAndStatus remotefile = 4500;
  required ArchiveFile archivefile = 4501;
  repeated ArchiveJobEntry jobs = 4502;
  required uint64 priority = 4503;
  required CreationLog log = 4504;
  optional string archivetodiraddress = 4505;
}

message ArchiveToDirRequest {
  required string archivedir = 4600;
  repeated string filerequestsaddresses = 4601;
  required uint64 priority = 4602;
  required CreationLog log = 4603;
}

// ------------- Retrieve Jobs -------------------------------------------------

// The status of the individual retrieve jobs. The jobs are materialised 
// by table entries in the RetrieveToFileRequest.
// This life cycle represented by the following enum

enum RetrieveJobStatus {
  RJS_LinkingToTape = 0;
  RJS_Pending = 1;
  RJS_Selected = 2;
  RJS_Complete = 3;
  RJS_Failed = 99;
}

message RetrieveJobEntry {
  required uint32 copynb = 4700;
  required string tape = 4701;
  required string tapeaddress = 4702;
  required uint64 fseq = 4703;
  required uint64 blockid = 4704;
  required RetrieveJobStatus status = 4705;
  required uint32 totalretries = 4706;
  required uint32 retrieswithinmount = 4707;
}

message RetrieveToFileRequest {
  required string remotefile = 4800;
  required ArchiveFile archivefile = 4801;
  required uint64 size = 4802;
  repeated RetrieveJobEntry jobs = 4803;
  required uint64 priority = 4804;
  required CreationLog log = 4805;
  optional string retrievetodiraddress = 4806;
}

message RetrieveToDirRequest {
  required string retrievedir = 4900;
  repeated string filerequestsaddresses = 4901;
  required uint64 priority = 4902;
  required CreationLog log = 4903;
}

// ------------- Drives handling  ----------------------------------------------



message DriveState {
  required string drivename = 5000;
  required string logicallibrary = 5001;
  optional uint64 sessionid = 5002;
  optional uint64 bytestransferedinsession = 5003;
  optional uint64 filestransferedinsession = 5004;
  optional double latestbandwidth = 5005;
  optional uint64 sessionstarttime = 5006;
  optional uint64 mountstarttime = 5007;
  optional uint64 transferstarttime = 5008;
  optional uint64 unloadstarttime = 5009;
  optional uint64 unmountstarttime = 5010;
  optional uint64 drainingstarttime = 5011;
  optional uint64 downorupstarttime = 5012;
  optional uint64 cleanupstarttime = 5013;
  optional uint64 lastupdatetime = 5014;
  required MountType mounttype = 5015;
  required DriveStatus drivestatus = 5016;
  optional string currentvid = 5017;
  optional string currenttapepool = 5018;
  required CreationLog creationlog = 5019;
}

message DriveRegister {
  repeated DriveState drives = 7000;
}

// ------------- Scheduler global lock handling  -------------------------------

message SchedulerGlobalLock {
  required uint64 nextmountid = 8000;
}

// ------------- New interface  ------------------------------------------------

message User {
  required string name = 8800;
  required string group = 8810;
}

message DRData {
  required string drBlob = 8900;
  required string drGroup = 8910;
  required string drOwner = 8930;
  required string drPath = 8940;
}

message EntryLog {
  required string name = 8950;
  required string group = 8955;
  required string host = 8960;
  required uint64 time = 8970;
}

message MountPolicy {
  required uint64 minRequestAge = 8985;
  required uint64 priority = 8987;
  required uint64 maxDrives = 8989;
}

message ArchiveRequest {
  required uint64 archiveFileID = 8990;
  required MountPolicy mountPolicy = 8995;
  required string checksumtype = 9000;
  required string checksumValue = 9010;
  required string diskpoolName = 9020;
  required uint64 diskpoolThroughput = 9030;
  required DRData drData = 9040;
  required string diskFileID = 9050;
  required string instance = 9055;
  required uint64 fileSize = 9060;
  required User requester = 9070;
  required string srcURL = 9080;
  required string storageClass = 9090;
  required EntryLog creationLog = 9091;
  repeated ArchiveJobEntry jobs = 9092;
}

message RetrieveRequest {
  required uint64 archiveFileID = 9100;
  required MountPolicy mountPolicy = 9105;
  required string diskpoolName = 9110;
  required uint64 diskpoolThroughput = 9120;
  required DRData drData = 9130;
  required string dstURL = 9140;
  required User requester = 9150;
  required EntryLog creationLog = 9151;
  repeated RetrieveJobEntry jobs = 9152;
}

message TapePoolQueue {
  required string tapepoolname = 10000;
  repeated ArchiveJobPointer pendingarchivejobs = 10010;
  repeated ArchiveJobPointer orphanedarchivejobsnscreation = 10020;
  repeated ArchiveJobPointer orphanedarchivejobsnsdeletion = 10030;
  required uint64 ArchiveJobsTotalSize = 10040;
  required uint64 oldestJobCreationTime = 10050;
}

message TapeQueue {
  required string vid = 10100;
  repeated RetrieveJobPointer retrievejobs = 10110;
  required uint64 retrievejobstotalsize = 10120;
  required uint64 oldestjobtime = 10130;
}