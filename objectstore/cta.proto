package cta.objectstore.serializers;

// The types of the objects. It will be used to allow introspection
// for the contents.
enum ObjectType {
  RootEntry_t = 0;
  AgentRegister_t = 1;
  Agent_t = 2;
  TapePool_t = 3;
  DriveRegister_t = 4;
  Tape_t = 5;
  ArchiveToFileRequest_t = 6;
  RetrieveToFileRequest_t = 7;
  SchedulerGlobalLock_t = 8;
  GenericObject_t = 1000;
}

// The types of mounts
enum MountType {
  NoMount = 0;
  Archive = 1;
  Retrieve = 2;
}

// The drive statuses
enum DriveStatus {
    Down = 0;
    Up = 1;
    Starting = 2;
    Mounting = 3;
    Transfering = 4;
    Unloading = 5;
    Unmounting = 6;
    DrainingToDisk = 7;
    CleaningUp = 8;
};

// The base object header. This will allow introspection and automatic
// "garbage collection", i.e. returning an unprocessed object belonging
// to a dead agent to the right queue or container.
// - The type allows automatic management of the content without knowing its
// payload.
// - The version allows multi schema to be used at the object level (smooth schema 
// evolution, on an object by object basis).
// - The owner is the authoritative source of ownership for the object.
// It allows arbitration of the actual owner in case the object is pointed
// to by several containers (during a transition, or after a failure).
// - The backup owner allows the object to be returned to a previous container
// in case of failure of a owner (when it is an agent).
message ObjectHeader {
  required ObjectType type = 1;
  required uint64 version = 2;
  required string owner = 3;
  required string backupowner = 4;
  required bytes payload = 5;
}

// A placeholder object for the implementation of neutral object handlers
message GenericObject {
}

// ===========================  Root Entry =====================================
// The objects making up the root entry.

// A user information record
message UserIdentity {
  required uint32 uid = 10;
  required uint32 gid = 11;
}

// The creation log attached to each element
message CreationLog {
  required UserIdentity user = 20;
  required string host = 21;
  required uint64 time = 22;
  optional string comment = 23;
}

// The admin host
message AdminHost {
  required string hostname = 30;
  required CreationLog log = 31;
}

message AdminUser {
  required UserIdentity user = 40;
  required CreationLog log = 41;
}

// The Archive route
message ArchiveRoute {
  required uint32 copynb = 50;
  required string tapepool = 51;
  required CreationLog log = 52;
}

// The Storage Class
message StorageClass {
  required string name = 60;
  required uint32 copycount = 61;
  repeated ArchiveRoute routes = 62;
  required CreationLog log = 63;
}

// Pointer to a tape pool (tape pool defined further)
message TapePoolPointer {
  required string name = 70;
  required string address  = 71;
  required uint32 nbpartialtapes = 72;
  required CreationLog log = 73;
}

// Description of a library
message Library {
  required string name = 80;
  required CreationLog log = 81;
}

// Pointer to the drive register (register defined further)
message DriveRegisterPointer {
  required string address = 90;
  required CreationLog log = 91;
}

// Pointer to the agent register (register defined further)
message AgentRegisterPointer {
  required string address = 100;
  required CreationLog log = 101;
}

// Pointer to the scheduler global lock
message SchedulerGlobalLockPointer {
  required string address = 110;
  required CreationLog log = 111;
}

// The root entry. This entry contains all the most static information, i.e.
// the admin handled configuration information
message RootEntry {
  repeated AdminHost adminhosts = 1000;
  repeated AdminUser adminusers = 1001;
  repeated StorageClass storageclasses = 1002;
  repeated TapePoolPointer tapepoolpointers = 1003;
  repeated Library libraries = 1004;
  optional DriveRegisterPointer driveregisterpointer = 1005;
  optional AgentRegisterPointer agentregisterpointer = 1006;
  optional string agentregisterintent = 1007;
  optional SchedulerGlobalLockPointer schedulerlockpointer = 1008;
}

//=========== Sub-objects ======================================================

// ------------- Agent handling ------------------------------------------------

// The agent object represents a running process. It is a payload to an object
// itself, and it can be owned by a watchdog or a global agent registry, which
// lists the agents not yet watched by a watchdog.
// - The description is a freetext string used for logging.
// - The watchdogs themselves own the agents they are watching, so the agents can
// be returned to the agent registry when they fail.
// - The heartbeat is incremented from time to time by the agent.
// - The timeout_us is the amount of microseconds after which the absence of
// change to the heartbeat can be interpreted as agent failure.
// - The ownedobject list is an ownership intent log that points to the objects
// that the agent is about to create, intends to own, or fully owns.
// The objects in this list can be considered for being returned to a backup
// owner.
message Agent {
  required string description = 2000;
  required uint64 heartbeat = 2001;
  required uint64 timeout_us = 2002;
  repeated string ownedobjects = 2003;
}

message AgentRegister {
  repeated string agents = 2100;
  repeated string untrackedagents = 2101;
}

// ------------- Jobs handling -------------------------------------------------

message ArchiveJobPointer {
  required string path = 3000;
  required uint64 size = 3001;
  required string address = 3002;
  required uint32 copynb = 3003;
}

message RetrieveJobPointer {
  required uint64 size = 3101;
  required string address = 3102;
}

// ------------- Mount criteria and quota  -------------------------------------

message MountCriteria {
  required uint64 maxFilesBeforeMount = 3200;
  required uint64 maxBytesBeforeMount = 3201;
  required uint64 maxSecondsBeforeMount = 3202;
}

message MountQuota {
  required uint32 quota = 3300;
  required uint32 allowedoverhead = 3301;
}

// ------------- Tape pools  ---------------------------------------------------

message TapePointer {
  required string vid = 4000;
  required string address  = 4001;
  required string library = 4002;
  required uint64 capacity = 4003;
  required CreationLog log = 4004;
}

message TapePool {
  required string name = 4100;
  repeated TapePointer tapes = 4101;
  repeated ArchiveJobPointer pendingarchivejobs = 4102;
  repeated ArchiveJobPointer orphanedarchivejobsnscreation = 4103;
  repeated ArchiveJobPointer orphanedarchivejobsnsdeletion = 4104;
  required uint64 ArchiveJobsTotalSize = 4105;
  required uint64 oldestJobCreationTime = 4106;
  required MountCriteria archivemountcriteria = 4107;
  required MountCriteria retievemountcriteria = 4108;
  required MountQuota archivemountquota = 4109;
  required MountQuota retrievemountquota = 4110;
  required uint64 priority = 4111;
}

// ------------- Tape ----------------------------------------------------------

message MountInfo {
  required string host = 4200;
  required string drivevendor = 4201;
  required string drivemodel = 4202;
  required string driveserial = 4203;
  required string drivename = 4204;
  required uint64 time = 4205;
}

message Tape {
  required string vid = 4300;
  required string logicallibrary = 4301;
  // Statistics about what is stored in the tape
  required uint64 lastfseq = 4302;
  required uint64 bytesstored = 4303;
  // Tape lifetime statistics
  repeated MountInfo readmounts = 4304;
  repeated MountInfo writemounts = 4305;
  // Information about retrive jobs queued on this tape
  repeated RetrieveJobPointer retrievejobs = 4306;
  required uint64 retrievejobstotalsize = 4307;
  required uint64 oldestjobtime = 4308;
  required uint64 priority = 4309;
  // There are no per tape mount criteria/quotas (they are per tape pool).
  // Tape status
  required bool busy = 4310;
  required MountType currentmounttype = 4311;
  required MountInfo currentmount = 4312;
  required bool archived = 4313;
  required bool disabled = 4314;
  required bool readonly = 4315;
  required bool full = 4316;
}

// ------------- Archive Jobs --------------------------------------------------

// The status of the individual archive jobs. The jobs are materialised 
// by table entries in the ArchiveToFileRequest.
// This life cycle represented by the following enum

enum ArchiveJobStatus {
  AJS_PendingNsCreation = 0;
  AJS_LinkingToTapePool = 1;
  AJS_PendingMount = 2;
  AJS_PendingNsDeletion = 99;
  AJS_Selected = 2;
  AJS_Complete = 3;
  AJS_Failed = 999;
}

message FilePathAndStatus {
  required string path = 4450;
  required uint64 mode = 4451;
  required uint64 size = 4452;
  required UserIdentity owner = 4453;
}

message ArchiveJobEntry {
  required uint32 copynb = 4400;
  required string tapepool = 4401;
  required string tapepooladdress = 4402;
  required string owner = 4403;
  required ArchiveJobStatus status = 4404;
  required uint32 totalretries = 4405;
  required uint32 retrieswithinmount = 4406;
}

message ArchiveToFileRequest {
  required FilePathAndStatus remotefile = 4500;
  required string archivefile = 4501;
  repeated ArchiveJobEntry jobs = 4502;
  required uint64 priority = 4503;
  required CreationLog log = 4504;
  optional string archivetodiraddress = 4505;
}

message ArchiveToDirRequest {
  required string archivedir = 4600;
  repeated string filerequestsaddresses = 4601;
  required uint64 priority = 4602;
  required CreationLog log = 4603;
}

// ------------- Retrieve Jobs -------------------------------------------------

// The status of the individual retrieve jobs. The jobs are materialised 
// by table entries in the RetrieveToFileRequest.
// This life cycle represented by the following enum

enum RetrieveJobStatus {
  RJS_LinkingToTape = 0;
  RJS_Pending = 1;
  RJS_Selected = 2;
  RJS_Complete = 3;
  RJS_Failed = 99;
}

message RetrieveJobEntry {
  required uint32 copynb = 4700;
  required string tape = 4701;
  required string tapeaddress = 4702;
  required RetrieveJobStatus status = 4703;
  required uint32 totalretries = 4704;
  required uint32 retrieswithinmount = 4705;
}

message RetrieveToFileRequest {
  required string remotefile = 4800;
  required string archivefile = 4801;
  required uint64 size = 4802;
  repeated RetrieveJobEntry jobs = 4803;
  required uint64 priority = 4804;
  required CreationLog log = 4805;
  optional string retrievetodiraddress = 4806;
}

message RetrieveToDirRequest {
  required string retrievedir = 4900;
  repeated string filerequestsaddresses = 4901;
  required uint64 priority = 4902;
  required CreationLog log = 4903;
}

// ------------- Drives handling  ----------------------------------------------



message DriveState {
  required string drivename = 5000;
  required string logicallibrary = 5001;
  optional uint64 sessionid = 5002;
  optional uint64 bytestransferedinsession = 5003;
  optional uint64 filestransferedinsession = 5004;
  optional double latestbandwidth = 5005;
  optional uint64 sessionstarttime = 5006;
  optional uint64 mountstarttime = 5007;
  optional uint64 transferstarttime = 5008;
  optional uint64 unloadstarttime = 5009;
  optional uint64 unmountstarttime = 5010;
  optional uint64 drainingstarttime = 5011;
  optional uint64 downorupstarttime = 5012;
  optional uint64 cleanupstarttime = 5013;
  optional uint64 lastupdatetime = 5014;
  required MountType mounttype = 5015;
  required DriveStatus drivestatus = 5016;
  optional string currentvid = 5017;
  optional string currenttapepool = 5018;
  required CreationLog creationlog = 5019;
}

message DriveRegister {
  repeated DriveState drives = 7000;
}

// ------------- Scheduler global lock handling  -------------------------------

message SchedulerGlobalLock {
  required uint64 nextmountid = 8000;
}


